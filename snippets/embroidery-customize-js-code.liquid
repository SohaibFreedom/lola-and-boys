{% assign variant = product.selected_or_first_available_variant %}
<script>
  const product2 = {{ product | json }};
  const variantsContainer = document.getElementById('variants-container');

  product2.variants.forEach(variant => {
      const variantDiv = document.createElement('div');

      variantDiv.textContent = variant.title;
      variantDiv.setAttribute('variant-id', variant.id);
      variantsContainer.appendChild(variantDiv);
  });
</script>
<script>
  $(document).ready(function() {
    // Select the button using its class
    var embroiderbutton = $('.embroider-button');
    var embroidercontimuebutton = $('#emb_variants_conitinue_btn');
    var cartButtonemb = $('.customize-cart-button');
    var embroidercontimuebackbutton = $('.emb_patches_back_btn');

    // Add a click event listener to the button
   
     embroidercontimuebutton.on('click', function() {
    console.log('back color btn clicked');

    // Check if any .size_variants_circle has the .size_variants_active class
    if ($('.size_variants_circle').hasClass('size_variants_active')) {
        // Show the sidebar by setting visibility to 'visible'
        $('#emb_variants-selected-sidebar').css('visibility', 'visible');
        $('#emb_variants-selected-sidebar').css('display', 'flex');
        $('#emb_variants-selected-sidebar').css('flex-direction', 'column');
        
        // Handle visibility for smaller screens
        if (window.innerWidth < 769) {
            $('.emb-only-mobile-for-colors').css('display', 'block');
            $('.emb-only-mobile-for-styles').css('display', 'none');
        }

        // Show the continue button
        // $('.variants-continue-btn-invisible').css('display', 'block');

        // Hide the embroider continue button
        embroidercontimuebutton.css('visibility', 'hidden');
    } else {
        // If no .size_variants_circle has .size_variants_active, show the error div
        $('.size_variants_errors').css('display', 'block');
    }
});

     embroidercontimuebackbutton.on('click', function() {
        // Show the sidebar by setting visibility to 'visible'
        $('#emb_variants-selected-sidebar').css('visibility', 'hidden');
       $('#emb_variants-selected-sidebar').css('display', 'none');
       $('#emb_size_color_selector_sidebar').css('display', 'block');
         $('.emb-only-mobile-for-styles').css('display', 'none');
            if (window.innerWidth < 769) {
        // Execute this code if the screen width is smaller than 69px
        $('.emb-only-mobile-for-colors').css('display', 'none');
    }
        if (window.innerWidth < 769){
          $('.emb-only-mobile-for-styles').css('display', 'block');
       } 
      
        // Hide the button by setting visibility to 'hidden'
        embroidercontimuebutton.css('visibility', 'visible');
    });
    // Flag to indicate whether customization mode is active
    var isCustomizationActive = false;

    // Callback function to execute when mutations are observed
    var callback = function(mutationsList, observer) {
        for (var mutation of mutationsList) {
            if (mutation.type === 'childList' && mutation.addedNodes.length > 0) {
                mutation.addedNodes.forEach(function(node) {
                    if (node.classList && node.classList.contains('yotpo-banner-low')) {
                        if (isCustomizationActive) {
                            // Hide the element if customization is active
                            node.style.display = 'none';
                            console.log('.yotpo-banner-low is now hidden.');
                        }
                    }
                });
            } else if (mutation.type === 'attributes' && mutation.target.classList.contains('yotpo-banner-low')) {
                if (isCustomizationActive) {
                    // Hide the element if customization is active
                    mutation.target.style.display = 'none';
                    console.log('.yotpo-banner-low is now hidden (attribute change).');
                }
            }
        }
    };

    // Create an observer instance linked to the callback function
    var observer = new MutationObserver(callback);

    // Configuration of the observer:
    // We want to observe additions of nodes (childList) and attribute changes
    var config = { attributes: true, childList: true, subtree: true };

    // Start observing the document's body for configured mutations
    observer.observe(document.body, config);

    // Add a click event listener to the button
   embroiderbutton.click(function() {
        isCustomizationActive = true;
        console.log('embroider button clicked');

        // Hide the bannerLow if it already exists
        var bannerLow = document.querySelector('.yotpo-banner-low');
        if (bannerLow) {
            bannerLow.style.display = 'none';
        }

        // Select all elements with the hide-for-customization class and hide them
        $('.hide-for-customization').hide();
        $('#shopify-block-yotpo_product_reviews_ugc_reviews_MbrNNx').hide();

        $('.footer').hide();
        $('.annoucment-bar-top').hide();
        $('#header').hide();
        $('#some-id').hide();
        // $('.yotpo-banner-low').hide();

        // Show the product customization div
        $('.embroidery-customization').show();

        // Add classes to make other elements visible
        $('.announce-bar-slide-wrapper, .header-background--solid, .content').hide();
        $('.customize-cart-button').hide();

        // Add a class to cartButton to make it visible
        cartButtonemb.addClass('customize-cart-button-visible');
    });
  });
</script>
<script>
   // Make a request to your Remix app's API endpoint with the Shopify.shop parameter
   fetch(`https://lolaandtheboys.com/apps/data-pickup`)
     .then(response => {
       // Check if the response is successful
       if (!response.ok) {
         throw new Error('Network response was not ok');
       }

       // Parse the response as JSON
       return response.json();
     })
     .then(data => {
       // Log the data received from the API
       console.log('DATA', data);
       // const alphabets = data.alphabets;
       // const patches = data.patches;
       const imagesData = data.embImgData;
       const colorVariants = data.colorvariants;
         const sizeVariants = data.sizevariants;
       const fontVariants = data.fonts;
       const threadcolors = data.threadsColor;
        const parentDiv = document.querySelector('.all_emb_fonts');
       showcolorVariants();
      
       displayFonts(fontVariants);
       $('#emb_fonts_monogram_btn').click(function() {
    // Call the displayMonogramsFonts function with fontVariants as a parameter
    displayMonogramsFonts(fontVariants);
          $('.emb_fonts_words_btn_active').removeClass('emb_fonts_words_btn_active');

    // Add the class to the clicked button
    $(this).addClass('emb_fonts_words_btn_active');
    showmonogramfrontembinputs();
  });
      $('#emb_fonts_words_btn').click(function() {
    // Call the displayFonts function with fontVariants as a parameter
    displayFonts(fontVariants);

    // Remove the class from any other buttons or elements (if applicable)
    $('.emb_fonts_words_btn_active').removeClass('emb_fonts_words_btn_active');

    // Add the class to the clicked button
    $(this).addClass('emb_fonts_words_btn_active');
});
      $(document).ready(function() {
    // Add the .emb_fonts_words_btn_active class to the #emb_fonts_words_btn div on page load
    $('#emb_fonts_words_btn').addClass('emb_fonts_words_btn_active');
});

       const parentDivthreads = document.querySelector('.all_threads_colors');
      console.log(threadcolors)
     
       // console.log(sizeVariants); // This line will cause an error since sizeVariants is not defined
       // showcolorVariants();
       showFrontImage();
       showBackImage();
      

       function showFrontImage() {
    console.log('emb front area');
    const product = {{ product | json }};
    
    // Iterate over the variants to find the relevant image data
    let currentImageData = null;

    product.variants.some(variant => {
        console.log('Variant ID:', variant.id);
        console.log('Images Data:', imagesData);

        currentImageData = imagesData.find(item => item.FproductId.toString() === variant.id.toString());
        console.log('Found Image Data:', currentImageData);

        // Return true to stop the loop after finding the first match
        return currentImageData !== undefined;
    });

    console.log('Final currentImageData:', currentImageData);

    // Update the image source and CSS properties if data is found
    if (currentImageData) {
        // const img = document.getElementById("emb-Front-image");
        // img.src = currentImageData.FProductImg;

        // Update CSS properties of #embcenterBox
        const centerBox = document.getElementById("embcenterBox");
        centerBox.style.height = currentImageData.FHeight + '%';
        centerBox.style.width = currentImageData.FWidth + '%';
        centerBox.style.top = currentImageData.FTop + '%';
        centerBox.style.left = currentImageData.FLeft + '%';
        //arm emb area
        //right arm
        const frontRarmembcenterBox = document.getElementById("frontRarmembcenterBox");
        frontRarmembcenterBox.style.height = currentImageData.FRAHeight + '%';
        frontRarmembcenterBox.style.width = currentImageData.FRAWidth + '%';
        frontRarmembcenterBox.style.top = currentImageData.FRATop + '%';
        frontRarmembcenterBox.style.left = currentImageData.FRALeft + '%';
        const Rarmembarea = document.createElement('div');
        Rarmembarea.classList.add('Rarm-emb-font-type-area');
      
        frontRarmembcenterBox.appendChild(Rarmembarea);
        const FRarminputField = document.querySelector('.FRarminput');

      // Add an event listener for the input event to update the newDiv's content
      FRarminputField.addEventListener('input', function() {
      // Set the content of the dynamically created .emb-font-type-area div
      Rarmembarea.textContent = FRarminputField.value;
     });
        //left  arm
        const frontLarmembcenterBox = document.getElementById("frontLarmembcenterBox");
        frontLarmembcenterBox.style.height = currentImageData.FLAHeight + '%';
        frontLarmembcenterBox.style.width = currentImageData.FLAWidth + '%';
        frontLarmembcenterBox.style.top = currentImageData.FLATop + '%';
        frontLarmembcenterBox.style.left = currentImageData.FLALeft + '%';

          const Larmembarea = document.createElement('div');
        Larmembarea.classList.add('Larm-emb-font-type-area');
        frontLarmembcenterBox.appendChild(Larmembarea);
        const FLarminputField = document.querySelector('.FLarminput');

      // Add an event listener for the input event to update the newDiv's content
      FLarminputField.addEventListener('input', function() {
      // Set the content of the dynamically created .emb-font-type-area div
      Larmembarea.textContent = FLarminputField.value;
     });

        // Create a new child div with the class .emb-font-type-area
        const newDiv = document.createElement('div');
        newDiv.classList.add('emb-font-type-area');

        // Optionally, you can set some styles or text for the new div
        
        // newDiv.textContent = 'abc'; // or any other text you want

        // Append the new div to the centerBox
        centerBox.appendChild(newDiv);
        
        const inputField = document.querySelector('.Fchestinput');

      // Add an event listener for the input event to update the newDiv's content
      inputField.addEventListener('input', function() {
      // Set the content of the dynamically created .emb-font-type-area div
      newDiv.textContent = inputField.value;
    if (inputField.value.length <= 5) {
  newDiv.style.fontSize = '25px';
} 
      else {
  if (window.innerWidth < 769) {
    newDiv.style.setProperty('font-size', '10px', 'important');
  } else if (window.innerWidth >= 1024 && window.innerWidth <= 1300) {
    newDiv.style.setProperty('font-size', '15px', 'important');
  } else {
     newDiv.style.fontSize = '15px';
  }
}
     });
         
      const Fmonograminput = document.querySelector('.Fmonograminput');

      // Add an event listener for the input event to update the newDiv's content
      Fmonograminput.addEventListener('input', function() {
      // Set the content of the dynamically created .emb-font-type-area div
      newDiv.textContent = Fmonograminput.value;
     });
    }
         displayFonts(fontVariants);
}
function showthreadcolors(threadColors) {
    console.log('threadColors:', threadColors);
  
    // Clear previous colors (if any)
    $('#all_threads_colors').empty();

    threadColors.forEach(function(color, index) {
        // Create a new div for each color with custom data attributes for ColorTitle and ColorName
        var colorDiv = $('<div></div>')
            .css({
                'background-color': color.ColorName,  // Set background to ColorName
                'width': '60px',
                'height': '60px',
                'display': 'inline-block',
                'cursor': 'pointer',
                 'border-radius': '3px',
                'border': '2px solid transparent',  // Add transparent border
                'border-radius': '5px'
            })
            .attr('data-color-title', color.ColorTitle)  // Store ColorTitle in a custom attribute
            .attr('data-color-name', color.ColorName)  // Store ColorName in a custom attribute
            .on('click', function() {
                // Get values from data attributes
                var selectedColorTitle = $(this).attr('data-color-title');
                var selectedColorName = $(this).attr('data-color-name');
                
                // Remove 'selected-thread-color' class from all divs
                $('#all_threads_colors div').removeClass('selected-thread-color');
                
                // Add 'selected-thread-color' class to the clicked div
                $(this).addClass('selected-thread-color');
                const embFontcolorInput = $('#selective_font_color');
                if (embFontcolorInput.length) {
                embFontcolorInput.val(selectedColorTitle);
                console.log('Hidden input updated with font family:', selectedColorTitle);
              }

                // Update the #selected_color span and change the text color of .emb-font-type-area
                $('#selected_color').text(selectedColorTitle);  // Show the ColorTitle in span
                $('.emb-font-type-area').css('color', selectedColorName);  // Change text color in .emb-font-type-area
                $('.emb-back-type-area').css('color', selectedColorName);  // Change text color in .emb-font-type-area
            $('#frontLarmembcenterBox').css('color', selectedColorName);  // Change text color in .emb-font-type-area
            $('#frontRarmembcenterBox').css('color', selectedColorName);  // Change text color in .emb-font-type-area
            $('#brontLarmembcenterBox').css('color', selectedColorName);  // Change text color in .emb-font-type-area
            $('#brontRarmembcenterBox').css('color', selectedColorName);  // Change text color in .emb-font-type-area
            });

        // Append the new color div to #all_threads_colors
        $('#all_threads_colors').append(colorDiv);
        
        // Automatically handle the first color div
        if (index === 0) {
            // Add 'selected-thread-color' class to the first div
            colorDiv.addClass('selected-thread-color');
            
            // Use the data attributes to update the #selected_color span and text color
            var firstColorTitle = colorDiv.attr('data-color-title');
            var firstColorName = colorDiv.attr('data-color-name');
                     const embFontcolorInput = $('#selective_font_color');
                if (embFontcolorInput.length) {
                embFontcolorInput.val(firstColorTitle);
                console.log('Hidden input updated with font family:', firstColorTitle );
              }
            $('#selected_color').text(firstColorTitle);  // Show the ColorTitle in span
            $('.emb-font-type-area').css('color', firstColorName);  // Change text color in .emb-font-type-area
            $('.emb-back-type-area').css('color', firstColorName);  // Change text color in .emb-font-type-area
            $('#frontLarmembcenterBox').css('color', firstColorName);  // Change text color in .emb-font-type-area
            $('#frontRarmembcenterBox').css('color', firstColorName);  // Change text color in .emb-font-type-area
            $('#brontLarmembcenterBox').css('color', firstColorName);  // Change text color in .emb-font-type-area
            $('#brontRarmembcenterBox').css('color', firstColorName);  // Change text color in .emb-font-type-area
        }
    });
}

      function showBackImage() {
   // Get the variant ID
   const variantId = "{{variant.id}}"; // Replace "{{variant.id}}" with your actual variant ID

    let currentImageData = null;

    product.variants.some(variant => {
    console.log('Variant ID:', variant.id);
    console.log('Images Data:', imagesData);

    currentImageData = imagesData.find(item => item.FproductId.toString() === variant.id.toString());
    console.log('Found Image Data:', currentImageData);

    // Return true to stop the loop after finding the first match
    return currentImageData !== undefined;
});

   // Update the image source and CSS properties if data is found
   if (currentImageData) {
     // const img = document.getElementById("emb-Back-image");
     // img.src = currentImageData.Backimg;

     // Check if Backimg is empty and hide the div if it is
     const patchesWrapper = document.querySelector(".patches-customizations-btn-wrapper");
     const sizevariantscontaier = document.querySelector(".size_variants_section");
      if (productTags.includes("no-back-image")) {
       patchesWrapper.style.visibility = "hidden";
       sizevariantscontaier.style.visibility = "hidden";
     } else {
       patchesWrapper.style.visibility = "visible";
       sizevariantscontaier.style.visibility = "visible";
     }

     // Update CSS properties of #centerBox
     const centerBox = document.getElementById("embBackcenterBox");
     centerBox.style.height = currentImageData.BHeight + '%';
     centerBox.style.width = currentImageData.BWidth + '%';
     centerBox.style.top = currentImageData.BTop + '%';
     centerBox.style.left = currentImageData.BLeft + '%';

      //arm emb area
        //right arm
        const brontRarmembcenterBox = document.getElementById("brontRarmembcenterBox");
        brontRarmembcenterBox.style.height = currentImageData.BRAHeight + '%';
        brontRarmembcenterBox.style.width = currentImageData.BRAWidth + '%';
        brontRarmembcenterBox.style.top = currentImageData.BRATop + '%';
        brontRarmembcenterBox.style.left = currentImageData.BRALeft + '%';
        const Rarmembarea = document.createElement('div');
        Rarmembarea.classList.add('back-Rarm-emb-font-type-area');
        brontRarmembcenterBox.appendChild(Rarmembarea);
        const FRarminputField = document.querySelector('.BRarminput');

        // Add an event listener for the input event to update the newDiv's content
        FRarminputField.addEventListener('input', function() {
        // Set the content of the dynamically created .emb-font-type-area div
        Rarmembarea.textContent = FRarminputField.value;
        });
        //left  arm
        const brontLarmembcenterBox = document.getElementById("brontLarmembcenterBox");
        brontLarmembcenterBox.style.height = currentImageData.BLAHeight + '%';
        brontLarmembcenterBox.style.width = currentImageData.BLAWidth + '%';
        brontLarmembcenterBox.style.top = currentImageData.BLATop + '%';
        brontLarmembcenterBox.style.left = currentImageData.BLALeft + '%';

        const Larmembarea = document.createElement('div');
        Larmembarea.classList.add('back-Larm-emb-font-type-area');
        brontLarmembcenterBox.appendChild(Larmembarea);
        const FLarminputField = document.querySelector('.BLarminput');

      // Add an event listener for the input event to update the newDiv's content
      FLarminputField.addEventListener('input', function() {
      // Set the content of the dynamically created .emb-font-type-area div
      Larmembarea.textContent = FLarminputField.value;
     });
      // Create a new child div with the class .emb-font-type-area
        const newDiv = document.createElement('div');
        newDiv.classList.add('emb-back-type-area');

        // Optionally, you can set some styles or text for the new div
        // newDiv.textContent = 'abc'; // or any other text you want

        // Append the new div to the centerBox
        centerBox.appendChild(newDiv);
     showthreadcolors(threadcolors);
        const inputField = document.querySelector('.Bchestinput');

        // Add an event listener for the input event to update the newDiv's content
        inputField.addEventListener('input', function() {
        // Set the content of the dynamically created .emb-font-type-area div
        newDiv.textContent = inputField.value;
             newDiv.textContent = inputField.value;
      if (inputField.value.length <= 7) {
  newDiv.style.fontSize = '45px';
} 
      else {
  if (window.innerWidth < 769) {
    newDiv.style.setProperty('font-size', '10px', 'important');
  } else if (window.innerWidth >= 1024 && window.innerWidth <= 1300) {
    newDiv.style.setProperty('font-size', '25px', 'important');
  } else {
     newDiv.style.fontSize = '35px';
  }
}

     });

     const Bmonograminput = document.querySelector('.Bmonograminput');

      // Add an event listener for the input event to update the newDiv's content
      Bmonograminput.addEventListener('input', function() {
      // Set the content of the dynamically created .emb-font-type-area div
      newDiv.textContent = Bmonograminput.value;
     });
   }
        displayFonts(fontVariants);
}

     function showcolorVariants() {
    console.log('This is color variants', colorVariants);

    const product = {{ product | json }};

    // Clear any existing color variants
    const sidebarBtn = document.querySelector('.emb-color-variant-selector-sidebar-btn');
    sidebarBtn.innerHTML = '';

    let firstColorVariant; // Variable to store the first color variant div

    // Iterate over the product variants
    product.variants.forEach(variant => {
        // Check if the current variant matches any color variant
        colorVariants.forEach(colorVariant => {
            // Check if the product contains the tag "back-pack"
            const productTags = {{ product.tags | json }};
            if (productTags.includes("none-size-products")) {
              console.log('non size'); 
              if (colorVariant.id.toString() === variant.id.toString()){
                     const matchingVariants = product.variants.filter(variant => {
    return variant.title.toLowerCase().includes(colorVariant.colorname.toLowerCase());
});

console.log('matchingVariantsBack Pack',matchingVariants);
          let isAvailable = matchingVariants.length > 0 && matchingVariants[0].available;

if (isAvailable) {
    console.log("The variant is available.");
    console.log('back-pack');
   // Create a new div for each color variant
   const parentDiv = document.createElement('div');
   parentDiv.classList.add('parent-variant-wrapper');
   const newDiv = document.createElement('div');
   newDiv.style.backgroundColor = colorVariant.Variants;
   newDiv.classList.add('color-variant');
   newDiv.setAttribute('color-title', colorVariant.colorname);
   console.log(document.getElementById('Front-image'));
   console.log(colorVariant.productImg);
   // Set the images for the front and back
 

   // Add click event listener to each div
   newDiv.addEventListener('click', () => {
   // Remove the class from all color-variant divs
   document.querySelectorAll('.color-variant').forEach((div) => {
       div.classList.remove('selected-variant');
   });

   // Add the class to the clicked div
   newDiv.classList.add('selected-variant');
   const colorTitle = newDiv.getAttribute('color-title');
   console.log('colorTitle', colorTitle);

   // Update the content of the .color_selector_heading div
   const colorSelectorHeading = document.querySelector('.emb-color_selector_heading');
     console.log(colorSelectorHeading)
   if (colorSelectorHeading) {
     console.log('yes its existes colorSelectorHeading')
       colorSelectorHeading.textContent = colorTitle;
   }

   // Find the matching variant
   const matchingVariant = product.variants.find(variant =>
       variant.title.toLowerCase().includes(colorTitle.toLowerCase())
   );

   if (matchingVariant) {
       // Update the input value with the matching variant ID
       const hiddenInput = document.querySelector('input[name="emb-selective_variant_ID"]');
       if (hiddenInput) {
           hiddenInput.value = matchingVariant.id;
       }
   }

   // Set the src attribute of the image with id "Front-image" and "Back-image"
   document.getElementById('emb-Front-image').src = colorVariant.productImg;
   document.getElementById('emb-Back-image').src = colorVariant.backImg;
});


   // Append the new div to the div with class "variant-selector-sidebar-btn"
   parentDiv.appendChild(newDiv);
   sidebarBtn.appendChild(parentDiv);

   // Store the first color variant div
   if (!firstColorVariant) {
       firstColorVariant = newDiv;
   }
} else {
    console.log("The variant is not available.");
    // Perform actions if the condition is false
}
              }
            } 
            
            else {
              console.log('size product'); 
                                      // Assuming variants is an array of variant objects

 if (colorVariant.id.toString() === variant.id.toString()) {
                   const matchingVariants = product.variants.filter(variant => {
    return variant.title.toLowerCase().includes(colorVariant.colorname.toLowerCase());
});

console.log('matchingVariants',matchingVariants);
// Check if any of the matching variants are available
const isAnyVariantAvailable = matchingVariants.some(variant => variant.available);

if (isAnyVariantAvailable) {
    console.log('At least one variant is available.');
   
                          // Create a new div for each color variant
                    const parentDiv = document.createElement('div');
                    parentDiv.classList.add('parent-variant-wrapper');
                    const newDiv = document.createElement('div');
                    if (productTags.includes("gardient-patch-background")) {
                      console.log(newDiv,'gardient-patch-background');
    newDiv.style.backgroundImage = 'radial-gradient(circle, rgba(223, 221, 157, 1) 0%, rgba(238, 96, 183, 1) 35%, rgba(165, 134, 222, 1) 100%)';
} else {
    newDiv.style.backgroundColor = colorVariant.Variants;
}
                    newDiv.classList.add('color-variant');
                    newDiv.setAttribute('color-title', colorVariant.colorname);

                    // Set the images for the front and back
                    document.getElementById('emb-Front-image').src = colorVariant.productImg;
                    document.getElementById('emb-Back-image').src = colorVariant.backImg;

                    // Add click event listener to each div
                    newDiv.addEventListener('click', () => {
                        // Remove the class from all color-variant divs
                        document.querySelectorAll('.color-variant').forEach((div) => {
                            div.classList.remove('selected-variant');
                        });
                        
                        // Add the class to the clicked div
                        newDiv.classList.add('selected-variant');
                        const colorTitle = newDiv.getAttribute('color-title');
                        console.log('colorTitle', colorTitle);
                           const colorSelectorHeading = document.querySelector('.emb-color_selector_heading');
     console.log(colorSelectorHeading)
   if (colorSelectorHeading) {
     console.log('yes its existes colorSelectorHeading')
       colorSelectorHeading.textContent = colorTitle;
   }
                               const sizeSelectorHeading = document.querySelector('.color_selector_heading');
     console.log(sizeSelectorHeading)
   if (sizeSelectorHeading) {
     console.log('yes its existes colorSelectorHeading')
       sizeSelectorHeading.textContent = '';
   }
                        // Call createVariantDivs if not a "back-pack"
                        createVariantDivs(colorTitle);

                        // Set the src attribute of the image with id "Front-image" and "Back-image"
                         document.getElementById('emb-Front-image').src = colorVariant.productImg;
                         document.getElementById('emb-Back-image').src = colorVariant.backImg;
                    });

                    // Append the new div to the div with class "variant-selector-sidebar-btn"
                    parentDiv.appendChild(newDiv);
                    sidebarBtn.appendChild(parentDiv);

                    // Store the first color variant div
                    if (!firstColorVariant) {
                        firstColorVariant = newDiv;
                    }

} else {
    console.log('All variants are unavailable.');
    // Condition becomes false
}
                      }
                  
            }
        });
    });


    // Automatically move the first color variant to createVariantDivs
    if (firstColorVariant) {
        console.log('firstColorVariant');
        firstColorVariant.classList.add('selected-variant');
        // document.getElementById('Front-image').src = colorVariant.productImg;
        // document.getElementById('Back-image').src = colorVariant.backImg;
        const colorTitle = firstColorVariant.getAttribute('color-title');
        console.log('First color variant', colorTitle);
    const colorSelectorHeading = document.querySelector('.emb-color_selector_heading');
     console.log(colorSelectorHeading)
   if (colorSelectorHeading) {
     console.log('yes its existes colorSelectorHeading')
       colorSelectorHeading.textContent = colorTitle;
   }
        const productTags = {{ product.tags | json }};
        if (!productTags.includes("none-size-products")) {
            createVariantDivs(colorTitle);
        } 
        else {
          $('.size_variants_section').css('visibility', 'hidden');
            // If it's a back-pack, find the matching variant
            const matchingVariant = product.variants.find((variant) =>
                variant.title.toLowerCase().includes(colorTitle.toLowerCase())
            );

            if (matchingVariant) {
                // Update the input value with the matching variant ID
                const hiddenInput = document.querySelector('input[name="emb-selective_variant_ID"]');
                if (hiddenInput) {
                    hiddenInput.value = matchingVariant.id;
                }
            }
        }
        console.log('colorVariants:', colorVariants);
        console.log('colorTitle',colorTitle)

// Step 1: Find all color variants that match the title
const matchingColorVariants = colorVariants.filter(colorVariant => 
    colorVariant.colorname &&
    colorTitle &&
    colorVariant.colorname.toLowerCase() === colorTitle.toLowerCase()
);

console.log('matchingColorVariants', matchingColorVariants);

// Step 2: From the matching color variants, find the one where the IDs match
const firstColorVariantData = matchingColorVariants.find(colorVariant => 
    product.variants.some(variant =>
        variant.id.toString() === colorVariant.id.toString()
    )
);

console.log('firstColorVariantData', firstColorVariantData);

if (firstColorVariantData) {
    console.log('yes i am under ', firstColorVariantData.productImg);
    
    // Set the src attribute of the images with the found color variant data
    document.getElementById('emb-Front-image').src = firstColorVariantData.productImg;
    document.getElementById('emb-Back-image').src = firstColorVariantData.backImg;
}

    }
} 
       function createVariantDivs(colorTitle) {
  const product2 = {{ product | json }};
  const variantsContainer = document.getElementById('emb-variants-containers');
  
  // Clear existing variant divs
  variantsContainer.innerHTML = '';

  // Filter and create divs for matching variants
  product2.variants.forEach(variant => {
    if (
      variant.title.toLowerCase().includes(colorTitle.toLowerCase()) &&
      variant.available
    ) {
      const variantDiv = document.createElement('div');
      variantDiv.textContent = variant.option1;
      variantDiv.setAttribute('data-v-id', variant.id);
      variantDiv.classList.add('select_size', 'size_variants_circle', 'size_variants');
      variantsContainer.appendChild(variantDiv);

      // Add click event listener to each dynamically created div
      variantDiv.addEventListener('click', () => {
    // Remove 'size_variants_active' class from all '.select_size' divs
    const allSelectSizeDivs = document.querySelectorAll('.select_size');
    allSelectSizeDivs.forEach(div => {
        div.classList.remove('size_variants_active');
    });

    // Hide any size variant errors
    $('.size_variants_errors').css('display', 'none');

    // Add 'size_variants_active' class to the clicked div
    variantDiv.classList.add('size_variants_active');

    // Update the colorSelectorHeading with the variant option1
    const colorSelectorHeading = document.querySelector('.emb-size_selector_heading');
    if (colorSelectorHeading) {
        colorSelectorHeading.textContent = variant.option1;
    }

    // Get the value of the data-v-id attribute
    const vId = variantDiv.getAttribute('data-v-id');
    console.log('vId', vId);

    // Update the value of the hidden input with id 'selective_variant_ID'
    const hiddenInput = document.getElementById('emb-selective_variant_ID');
    if (hiddenInput) {
        hiddenInput.value = vId;
    }

    // Get the text content of the clicked div and assign it to the hidden input 'selective_variant_name'
    const clickedDivText = variantDiv.textContent.trim(); // Get the text of the clicked div
    const hiddenNameInput = document.getElementById('selective_variant_name');
    if (hiddenNameInput) {
        hiddenNameInput.value = clickedDivText; // Set the text content as the value of the hidden input
    }
});

    }
  });
}
  $('.size_variants').click(function() {
                // Remove 'size_variants_active' class from all elements with 'size_variants' class
                $('.size_variants').removeClass('size_variants_active');
                // Add 'size_variants_active' class to the clicked element
                $(this).addClass('size_variants_active');
                // Update hidden input value with the id of the clicked element
               $('#size_variants_data').val($(this).text());
            });
     $('#emb-small_variant').click(function() {
        console.log('change-text');
          $('.size_selector_heading').text('Small');
      });
      $('#emb-medium_variant').click(function() {
          $('.size_selector_heading').text('Medium');
      });
      $('#emb-large_variant').click(function() {
          $('.size_selector_heading').text('Large');
      });
      $('#emb-extra_large_variant').click(function() {
          $('.size_selector_heading').text('Extra Large');
      });
       
function displayFonts(fontVariants) {
    const allEmbFontsDiv = document.querySelector('.all_emb_fonts');
    allEmbFontsDiv.innerHTML = ''; // This will clear all existing content
    $('#Monogram_inputs').hide();
  $('#wordsletter_inputs').show();
  const fontEmbDivs = [];
    fontVariants.forEach(font => {
        // Create the .font_emb div
        if (font.Category === 'WM' || font.Category === 'W') {   
         const fontDiv = document.createElement('div');
        fontDiv.className = 'font_emb';
        fontDiv.setAttribute('font_family', font.fontName);

        // Create the img element
        const img = document.createElement('img');
        img.src = font.FeatureImagefont;
        img.alt = font.fontName;

        // Append the img to the .font_emb div
        fontDiv.appendChild(img);

        // Append the .font_emb div to the parent container
        parentDiv.appendChild(fontDiv);
           fontEmbDivs.push(fontDiv);
        fontDiv.addEventListener('click', function() {
            var fontFamily = fontDiv.getAttribute('font_family');
            console.log('font_emb_selected clicked');
            // Select the .emb-font-type-area element
            var embFontArea = document.querySelector('.emb-font-type-area');
            
            // Remove all classes except the default .emb-font-type-area class
            embFontArea.className = 'emb-font-type-area';
            
            // Add the fontFamily as a class to the .emb-font-type-area div
            embFontArea.classList.add(fontFamily);

          // Front arms embroidery area
             var embFontRarmArea = document.querySelector('.Rarm-emb-font-type-area');
            
            // Remove all classes except the default .emb-font-type-area class
            embFontRarmArea.className = 'Rarm-emb-font-type-area';
            
            // Add the fontFamily as a class to the .emb-font-type-area div
            embFontRarmArea.classList.add(fontFamily);

            var embFontLarmArea = document.querySelector('.Larm-emb-font-type-area');
            
            // Remove all classes except the default .emb-font-type-area class
            embFontLarmArea.className = 'Larm-emb-font-type-area';
            
            // Add the fontFamily as a class to the .emb-font-type-area div
            embFontLarmArea.classList.add(fontFamily);

           //Back area arms
            var BembFontRarmArea = document.querySelector('.back-Rarm-emb-font-type-area');
            
            // Remove all classes except the default .emb-font-type-area class
             BembFontRarmArea.className = 'back-Rarm-emb-font-type-area';
            
            // Add the fontFamily as a class to the .emb-font-type-area div
            BembFontRarmArea.classList.add(fontFamily);

            var BembFontLarmArea = document.querySelector('.back-Larm-emb-font-type-area');
            
            // Remove all classes except the default .emb-font-type-area class
            BembFontLarmArea.className = 'back-Larm-emb-font-type-area';
            
            // Add the fontFamily as a class to the .emb-font-type-area div
            BembFontLarmArea.classList.add(fontFamily);
            document.querySelector('#selected_font_style').textContent = fontFamily;
            console.log('Font family added as class:', fontFamily);

            const embFontInput = document.querySelector('#selective_emb_font');
    if (embFontInput) {
        embFontInput.value = fontFamily;
        console.log('Hidden input updated with font family:', fontFamily);
    }
        });
       }
     

      
    });

   // Automatically select and apply the font settings to the first .font_emb div
  if (fontEmbDivs.length > 0) {
    const firstFontEmbDiv = fontEmbDivs[0];
    firstFontEmbDiv.classList.add('font_emb_selected');
    const fontFamily = firstFontEmbDiv.getAttribute('font_family');
    applyFontFamily(fontFamily);
  }

 function applyFontFamily(fontFamily) {
    // Select and update the .emb-font-type-area element
    const embBackArea = document.querySelector('.emb-back-type-area');
    console.log('embBackArea:', embBackArea);
    if (embBackArea) {
        embBackArea.className = 'emb-back-type-area';
        embBackArea.classList.add(fontFamily);
    } 
    
    const embFontArea = document.querySelector('.emb-font-type-area');
    console.log('embFontArea:', embFontArea);
    if (embFontArea) {
        embFontArea.className = 'emb-font-type-area';
        embFontArea.classList.add(fontFamily);
    }

    // Front arms embroidery area
    const embFontRarmArea = document.querySelector('.Rarm-emb-font-type-area');
    console.log('embFontRarmArea:', embFontRarmArea);
    if (embFontRarmArea) {
        embFontRarmArea.className = 'Rarm-emb-font-type-area';
        embFontRarmArea.classList.add(fontFamily);
    }

    const embFontLarmArea = document.querySelector('.Larm-emb-font-type-area');
    console.log('embFontLarmArea:', embFontLarmArea);
    if (embFontLarmArea) {
        embFontLarmArea.className = 'Larm-emb-font-type-area';
        embFontLarmArea.classList.add(fontFamily);
    }

    // Back area arms
    const BembFontRarmArea = document.querySelector('.back-Rarm-emb-font-type-area');
    console.log('BembFontRarmArea:', BembFontRarmArea);
    if (BembFontRarmArea) {
        BembFontRarmArea.className = 'back-Rarm-emb-font-type-area';
        BembFontRarmArea.classList.add(fontFamily);
    }

    const BembFontLarmArea = document.querySelector('.back-Larm-emb-font-type-area');
    console.log('BembFontLarmArea:', BembFontLarmArea);
    if (BembFontLarmArea) {
        BembFontLarmArea.className = 'back-Larm-emb-font-type-area';
        BembFontLarmArea.classList.add(fontFamily);
    }

    // Update the displayed font style
    document.querySelector('#selected_font_style').textContent = fontFamily;
    console.log('Font family added as class:', fontFamily);

    // Update the value of the hidden input field for the font
    const embFontInput = document.querySelector('#selective_emb_font');
    if (embFontInput) {
        embFontInput.value = fontFamily;
        console.log('Hidden input updated with font family:', fontFamily);
    }
}


}
function displayMonogramsFonts(fontVariants) {
  const allEmbFontsDiv = document.querySelector('.all_emb_fonts');
  allEmbFontsDiv.innerHTML = ''; // This will clear all existing content

  // Show and hide the appropriate inputs
  $('#Monogram_inputs').show();
  $('#wordsletter_inputs').hide();

  // Array to store all .font_emb divs
  const fontEmbDivs = [];

  fontVariants.forEach(font => {
    if (font.Category === 'WM' || font.Category === 'M') {   
      const fontDiv = document.createElement('div');
      fontDiv.className = 'font_emb';
      fontDiv.setAttribute('font_family', font.fontName);

      // Create the img element
      const img = document.createElement('img');
      img.src = font.FeatureImagefont;
      img.alt = font.fontName;

      // Append the img to the .font_emb div
      fontDiv.appendChild(img);

      // Append the .font_emb div to the parent container
      allEmbFontsDiv.appendChild(fontDiv);

      // Add fontDiv to the array for later use
      fontEmbDivs.push(fontDiv);

      fontDiv.addEventListener('click', function() {
        console.log('Font div clicked');
        
        // Remove .font_emb_selected from all divs
        fontEmbDivs.forEach(div => div.classList.remove('font_emb_selected'));

        // Add .font_emb_selected class to the clicked div
        fontDiv.classList.add('font_emb_selected');

        // Get the fontFamily from the clicked .font_emb div
        const fontFamily = fontDiv.getAttribute('font_family');

        // Apply the fontFamily to the relevant elements
        applyFontFamily(fontFamily);
      });
    }
  });

  // Automatically select and apply the font settings to the first .font_emb div
  if (fontEmbDivs.length > 0) {
    const firstFontEmbDiv = fontEmbDivs[0];
    firstFontEmbDiv.classList.add('font_emb_selected');
    const fontFamily = firstFontEmbDiv.getAttribute('font_family');
    applyFontFamily(fontFamily);
  }

  function applyFontFamily(fontFamily) {
    // Select and update the .emb-font-type-area element
    const embFontArea = document.querySelector('.emb-font-type-area');
    embFontArea.className = 'emb-font-type-area';
    embFontArea.classList.add(fontFamily);

    // Front arms embroidery area
    const embFontRarmArea = document.querySelector('.Rarm-emb-font-type-area');
    embFontRarmArea.className = 'Rarm-emb-font-type-area';
    embFontRarmArea.classList.add(fontFamily);

    const embFontLarmArea = document.querySelector('.Larm-emb-font-type-area');
    embFontLarmArea.className = 'Larm-emb-font-type-area';
    embFontLarmArea.classList.add(fontFamily);

    // Back area arms
    const BembFontRarmArea = document.querySelector('.back-Rarm-emb-font-type-area');
    BembFontRarmArea.className = 'back-Rarm-emb-font-type-area';
    BembFontRarmArea.classList.add(fontFamily);

    const BembFontLarmArea = document.querySelector('.back-Larm-emb-font-type-area');
    BembFontLarmArea.className = 'back-Larm-emb-font-type-area';
    BembFontLarmArea.classList.add(fontFamily);
 document.querySelector('#selected_font_style').textContent = fontFamily;
    console.log('Font family added as class:', fontFamily);
      const embFontInput = document.querySelector('#selective_emb_font');
    if (embFontInput) {
        embFontInput.value = fontFamily;
        console.log('Hidden input updated with font family:', fontFamily);
    }
  }
  
}


//        function displayColors(threadcolors) {
//          console.log('threadcolors under function',threadcolors)
//     threadcolors.forEach(color => {
//         // Create the .emb_thread_colors div
//         const colorDiv = document.createElement('div');
//         colorDiv.className = 'emb_thread_colors';
//         colorDiv.style.backgroundColor = color.ColorName;
//         colorDiv.setAttribute('data-color-title', color.ColorTitle);

//         // Append the .emb_thread_colors div to the parent container
//         parentDivthreads.appendChild(colorDiv);
//     });
// }
     })

     .catch(error => {
       console.error('Fetch error:', error);
     });
</script>
<script>
    $(document).ready(function() {
       function showBackOrFront(event) {
        if (event.target.id === 'embshowFrontBtn') {
          $('#emb-Front-Area').removeClass('image-hidden').css('visibility', 'visible');
          $('#embshowBackBtnn').removeClass('patches-customization-btn-active');
          $('#embshowFrontBtn').addClass('patches-customization-btn-active');
         $('#emb-Back-area').css('visibility', 'hidden');
          showfrontembinputs();
          showmonogramfrontembinputs();
               $('#back_inputs_btn').removeClass('front_inputs_btn_active');
               $('#front_inputs_btn').addClass('front_inputs_btn_active');
                  $('#monogram_back_inputs_btn').removeClass('front_inputs_btn_active');
               $('#monogram_front_inputs_btn').addClass('front_inputs_btn_active');
        } else if (event.target.id === 'embshowBackBtnn') {
          showbackembinputs();
          showmonogrambackembinputs();
            var backArea = document.getElementById('emb-Back-area');
             backArea.style.top = '0px';
          $('#front_inputs_btn').removeClass('front_inputs_btn_active');
           $('#back_inputs_btn').addClass('front_inputs_btn_active');
                    $('#monogram_front_inputs_btn').removeClass('front_inputs_btn_active');
           $('#monogram_back_inputs_btn').addClass('front_inputs_btn_active');
          // Hide front image and show back image
          $('#embshowFrontBtn').removeClass('patches-customization-btn-active');
          $('#embshowBackBtnn').addClass('patches-customization-btn-active');
          $('#emb-Front-Area').addClass('image-hidden').css('visibility', 'hidden');
          $('#emb-Back-area').removeClass('image-hidden').css('visibility', 'visible');
          const backPatches = document.querySelectorAll('.BackcenterBox > .patches-containerr > .patch-action');

  backPatches.forEach(patch => {
    patch.style.display = 'block';
  });

        }
      }
      $('#embshowFrontBtn').click(showBackOrFront);
      $('#embshowBackBtnn').click(showBackOrFront);
      $('#emb-Front-Area').removeClass('image-hidden').css('visibility', 'visible');
       function showBackOrFrontemb(event) {
        if (event.target.id === 'front_inputs_btn') {
          $('#emb-Front-Area').removeClass('image-hidden').css('visibility', 'visible');
          $('#embshowBackBtnn').removeClass('patches-customization-btn-active');
          $('#embshowFrontBtn').addClass('patches-customization-btn-active');
         $('#emb-Back-area').css('visibility', 'hidden');
          showfrontembinputs();
          showmonogramfrontembinputs();
      
        } else if (event.target.id === 'back_inputs_btn') {
          showbackembinputs();
          showmonogrambackembinputs();
           
            var backArea = document.getElementById('emb-Back-area');
             backArea.style.top = '0px';
          // Hide front image and show back image
          $('#embshowFrontBtn').removeClass('patches-customization-btn-active');
          $('#embshowBackBtnn').addClass('patches-customization-btn-active');
          $('#emb-Front-Area').addClass('image-hidden').css('visibility', 'hidden');
          $('#emb-Back-area').removeClass('image-hidden').css('visibility', 'visible');
          const backPatches = document.querySelectorAll('.BackcenterBox > .patches-containerr > .patch-action');

  backPatches.forEach(patch => {
    patch.style.display = 'block';
  });

        }
      }
        $('#front_inputs_btn').click(showBackOrFrontemb);
      $('#back_inputs_btn').click(showBackOrFrontemb);
           function showBackOrFrontembmono(event) {
        if (event.target.id === 'monogram_front_inputs_btn') {
          $('#emb-Front-Area').removeClass('image-hidden').css('visibility', 'visible');
          $('#embshowBackBtnn').removeClass('patches-customization-btn-active');
          $('#embshowFrontBtn').addClass('patches-customization-btn-active');
         $('#emb-Back-area').css('visibility', 'hidden');
          showfrontembinputs();
          showmonogramfrontembinputs();
            
        } else if (event.target.id === 'monogram_back_inputs_btn') {
          showbackembinputs();
          showmonogrambackembinputs();

            var backArea = document.getElementById('emb-Back-area');
             backArea.style.top = '0px';
          
          // Hide front image and show back image
          $('#embshowFrontBtn').removeClass('patches-customization-btn-active');
          $('#embshowBackBtnn').addClass('patches-customization-btn-active');
          $('#emb-Front-Area').addClass('image-hidden').css('visibility', 'hidden');
          $('#emb-Back-area').removeClass('image-hidden').css('visibility', 'visible');
          const backPatches = document.querySelectorAll('.BackcenterBox > .patches-containerr > .patch-action');

  backPatches.forEach(patch => {
    patch.style.display = 'block';
  });

        }
      }
      $('#monogram_front_inputs_btn').click(showBackOrFrontembmono);
      $('#monogram_back_inputs_btn').click(showBackOrFrontembmono);
    });
</script>
<script>
    $('.emb-close-variant-selector-editor').click(function() {
      console.log('close-variant-selector-editor clicked')
      // Remove the class from any element that has it
      $('.all-sidebar-cross-alert').addClass('all-sidebar-cross-alert-visble');

      $('.patches-customization-container-overly').css('display', 'block');
  });
    $('.emb-all-sidebar-cross-neverMind-button').click(function() {
      console.log('close-variant-selector-editor clicked')
      // Remove the class from any element that has it
      $('.all-sidebar-cross-alert').removeClass('all-sidebar-cross-alert-visble');

      $('.patches-customization-container-overly').css('display', 'none');
  });
    $('.crosssvg-wrapper').click(function() {
      console.log('close-variant-selector-editor clicked')
      // Remove the class from any element that has it
      $('.all-sidebar-cross-alert').removeClass('all-sidebar-cross-alert-visble');

      $('.patches-customization-container-overly').css('display', 'none');
  });
  $('.emb-all-sidebar-cross-exit-button').click(function() {
       location.reload();
  });
</script>

<script>
  document.addEventListener('DOMContentLoaded', function() {
      const fontContainer = document.getElementById('all_emb_fonts');

      // Add event listener to the parent container
      fontContainer.addEventListener('click', function(event) {
          let target = event.target;

          // Traverse up the DOM to find the .font_emb parent
          while (target && !target.classList.contains('font_emb')) {
              target = target.parentElement;
          }

       if (target && target.classList.contains('font_emb')) {
    console.log("Font div clicked");
    
    // Remove 'font_emb_selected' from all elements with class 'font_emb'
    $('.font_emb').removeClass('font_emb_selected');
    
    // Toggle 'font_emb_selected' class on the clicked element
    $(target).toggleClass('font_emb_selected');
    
    // Get the font family from the clicked element
    const fontFamily = target.getAttribute('font_family');
    console.log(fontFamily);
    
    // Change the font family of the .emb-back-type-area element
    const embBackTypeArea = document.querySelector('.emb-back-type-area');
    console.log(embBackTypeArea);
    embBackTypeArea.style.fontFamily = fontFamily;
}

      });
  });
</script>
<script>
  showfrontembinputs(); // Call this function immediately when the script runs

  $('#front_inputs_btn').on('click', function() {
        $('#front_inputs_btn, #back_inputs_btn').removeClass('front_inputs_btn_active');
    
    // Add the active class to the clicked button
    $(this).addClass('front_inputs_btn_active');
    // Call the showfrontembinputs function on button click
    showfrontembinputs();
  });
  $('#back_inputs_btn').on('click', function() {
   $('#front_inputs_btn, #back_inputs_btn').removeClass('front_inputs_btn_active');
 // Add the active class to the clicked button
    $(this).addClass('front_inputs_btn_active');
    // Call the showfrontembinputs function on button click
    showbackembinputs();
  });
$('#monogram_front_inputs_btn').on('click', function() {
  $('#monogram_back_inputs_btn, #monogram_front_inputs_btn').removeClass('front_inputs_btn_active');
    
    // Add the active class to the clicked button
    $(this).addClass('front_inputs_btn_active');

    // Call the showmonogramfrontembinputs function on button click
    showmonogramfrontembinputs();
});
$(document).ready(function() {
    // Add the class .front_inputs_btn_active to both divs when the page loads
    $('#front_inputs_btn, #monogram_front_inputs_btn').addClass('front_inputs_btn_active');
});

$('#monogram_back_inputs_btn').on('click', function() {
  $('#monogram_back_inputs_btn, #monogram_front_inputs_btn').removeClass('front_inputs_btn_active');
    
    // Add the active class to the clicked button
    $(this).addClass('front_inputs_btn_active');
   
    // Call the showmonogrambackembinputs function on button click
    showmonogrambackembinputs();
});


  // Define the showfrontembinputs function correctly
  function showfrontembinputs() {
  // Show the #front_inputs div and hide the #back_inputs div
    $('#front_inputs').show();
    $('#back_inputs').hide();
  }
  function showbackembinputs() {
  // Show the #front_inputs div and hide the #back_inputs div
    $('#front_inputs').hide();
    $('#back_inputs').show();
  }
function showmonogramfrontembinputs() {
    // Show the #front_monogram_input div and hide the #back_monogram_input div
    $('.front_monogram_input').show();
    $('.back_monogram_input').hide();
}

function showmonogrambackembinputs() {
    // Show the #back_monogram_input div and hide the #front_monogram_input div
    $('.front_monogram_input').hide();
    $('.back_monogram_input').show();
}
</script>
<script>
const addembCartItemButton = document.querySelector('.emb_cart_btn');
const embcustomationcartbtn = document.querySelector('#emb-patches-customization-form-btn');
const embloader = document.querySelector('#emb-loader-cart');
const spanDiv = document.querySelector('.span-content');

addembCartItemButton.addEventListener('click', async function (event) {
   // Target specific inputs by their name attributes
    const Fchestinput = document.getElementsByName('Fchestinput')[0];
    const FRarminput = document.getElementsByName('FRarminput')[0];
    const FLarminput = document.getElementsByName('FLarminput')[0];

    // Check if all input values are empty
    if (
        Fchestinput.value.trim() === '' && 
        FRarminput.value.trim() === '' && 
        FLarminput.value.trim() === ''
    ) {
        // Display the error div if all inputs are empty
        document.querySelector('.emb-texterror-wrapper').style.display = 'block';
    } else {
      console.log('emb_cart_btn');
    embloader.style.display = 'block';
 addembCartItemButton.style.display = 'none';
 embcustomationcartbtn.style.pointerEvents = 'none';
 embcustomationcartbtn.style.opacity = '0.5';
 embcustomationcartbtn.style.backgroundColor = '#dfdfdf';
  embcustomationcartbtn.style.padding = '12px 71px';
embcustomationcartbtn.style.borderRadius = '20px';

    setTimeout(() => {
        embcaptureAndCombineScreenshots();
    }, 1);
    }
   
});
</script>

<script>
 async function embuploadBlob(pngImageURL, inputSelector,counter) {
  try {

    // Fetch the image URL
    const response = await fetch(pngImageURL);

    // Convert the fetched response to a blob
    const blob = await response.blob();

    // Use FormData to prepare the data for sending
    const formData = new FormData();
    formData.append('image', blob, 'upload.png');

    // Send the FormData to the server
    const result = await fetch('https://heroic-frangipane-c8c826.netlify.app/.netlify/functions/getdata/check', {
      method: 'POST',
      body: formData
    });

    // Assuming the server responds with JSON
    const jsonResponse = await result.json();
    console.log(jsonResponse);

    // Update the value of the input field with the file URL
    if (jsonResponse && jsonResponse.fileUrl) {
      document.querySelector(inputSelector).value = jsonResponse.fileUrl;
    } else {
      console.error('File URL not found in the response');
    }

    // Increment the counter and check condition
  embaddcartfiles();

  } catch (error) {
    console.error('Error uploading blob:', error);
  }
}


async function embaddcartfiles() {
    let Patchesdata; // Define Patchesdata outside the function

    // Fetch Patchesdata from the API endpoint
    try {
        const response = await fetch(`https://lolaandtheboys.com/apps/data-pickup`);
        if (!response.ok) {
            throw new Error('Network response was not ok');
        }
        const data = await response.json();
        console.log(data);
        // Assign the fetched data to Patchesdata
        Patchesdata = data;
    } catch (error) {
        console.error('Error fetching data:', error);
        return; // Exit the function if fetching fails
    }

    // Patchesdata is now available
    console.log('Patchesdata', Patchesdata);

    console.log('addcartfiles');
    const variantPrice = [];
    let productPrice = '{{ variant.price }}';
    console.log('this is product price', productPrice);
    let totalPrice = parseFloat(productPrice.slice(0, -2));

    const patchDivsPrice = document.querySelectorAll('.patch-');
    patchDivsPrice.forEach(patch => {
      const vId = patch.getAttribute('v-id');
      const Id = patch.getAttribute('id');
      const alphabets = Patchesdata.alphabets;
      const patches = Patchesdata.patches;

      const alphabetVariant = alphabets.find(item => item.id.toString() === vId);
      const patchVariant = patches.find(item => item.id.toString() === vId);

      const variant = { ...alphabetVariant, ...patchVariant };

      if (variant) {
        const price = parseFloat(variant.price);
        if (!isNaN(price)) { // Check if price is a valid number
          totalPrice += price;
        } else {
          console.error(`Invalid price for variant with v-id ${vId}`);
        }
      } else {
        console.error(`Variant not found for v-id ${vId}`);
      }
    });

    var currencyFormat = document.getElementById('currency-format').dataset.moneyFormat;
    var amountPlaceholder = currencyFormat.match(/\{\{amount\}\}/)[0];
    var currencySymbol = currencyFormat.replace(amountPlaceholder, '');
    var pricewithSymbol = currencySymbol.trim() + totalPrice;
    $('input[name="customized_price"]').val(pricewithSymbol);

    // event.preventDefault(); // Prevent the default button click behavior

    // Get the custom data from the hidden input fields
    const customizedImageUrl = document.querySelector('input[name="customized_image_url_front"]').value;
    const variantID = document.querySelector('input[name="emb-selective_variant_ID"]').value;
    const selectedfont = document.querySelector('input[name="selective_emb_font"]').value;
    const selectedfontcolor = document.querySelector('input[name="selective_font_color"]').value;

    try {
      const response = await embaddToCart(customizedImageUrl, variantID,selectedfont,selectedfontcolor );
      console.log('Cart Response:', response);
   if (response.status === 422) {
  const outOfStockDiv = document.getElementById('Out-of-stock-error');
  console.log(outOfStockDiv);
  if (outOfStockDiv) {
    const addItemDiv = document.querySelector('.add-item');
    if (addItemDiv) {
      addItemDiv.style.background = '#ffe2e8';
      addItemDiv.style.opacity = '1';
      addItemDiv.style.pointerEvents = '';
    }

    // Display .span-content div
    const spanContentDiv = document.querySelector('.span-content');
    if (spanContentDiv) {
      spanContentDiv.style.display = 'block';
    }
    
    const loaderCartDiv = document.querySelector('.loader-cart');
    if (loaderCartDiv) {
      loaderCartDiv.style.display = 'none';
    }
    
    console.log('yes exists');
    outOfStockDiv.style.display = 'block'; // Display the div
    outOfStockDiv.style.visibility = 'visible';
    outOfStockDiv.textContent = response.message; // Set the content to the error message
    
    // Call the function to hide the outOfStockDiv after 5 seconds
    hideOutOfStockDivAfterDelay();
  }
}else {
    // Redirect to cart if the response is successful
    window.location.href = '/cart';
     console.log('done');
  }
    } catch (error) {
      console.error('Error adding items to cart:', error);
      // Handle error
    }
    async function embaddToCart(customizedImageUrl, variantID,selectedfont,selectedfontcolor ) {
   try {
    // Prepare the first item to add to the cart
    const item1 = {
        id: variantID,  // Use the provided variant ID for the first item
        quantity: 1,  // Specify the quantity for the first item
        properties: {
             _embroideryProduct: 'Embroidery Product',
            _customized_image_url_front: customizedImageUrl,
            "Font": selectedfont,
             "Font Color": selectedfontcolor,
            _Timestamp: Date.now().toString(),
           _stichingvariantID: 42085140430950,
        }
    };

    // Prepare the second item to add to the cart
    const item2 = {
        id: 42085140430950,  // The second product's variant ID
        quantity: 1,  // Specify the quantity for the second item
        properties: {
          _Timestamp: Date.now().toString()
        }  // You can add custom properties here if needed
    };

    const formData = { items: [item1, item2] };

    // Send the request to add both items to the cart
    const response = await fetch(window.Shopify.routes.root + 'cart/add.js', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify(formData)
    });

    return await response.json();  // Return the response from Shopify
} catch (error) {
        console.error('Error adding item to cart:', error);
        throw error; // Re-throw the error for further handling
    }
}

}
  function hideOutOfStockDivAfterDelay() {
  setTimeout(() => {
    const outOfStockDiv = document.getElementById('Out-of-stock-error');
    if (outOfStockDiv) {
      outOfStockDiv.style.display = 'none';
      outOfStockDiv.style.visibility = 'none';
    }
  }, 5000); // Delay of 5 seconds
}
</script>
<script>
  function embcaptureAndCombineScreenshots() {




      function captureDiv(id) {
          return html2canvas(document.getElementById(id), {
              allowTaint: true,
              useCORS: true
          });
      }

      if (document.getElementById('emb-Front-Area').style.visibility === 'visible') {
          var backArea = document.getElementById('emb-Back-area');
          backArea.style.visibility = 'visible';
          backArea.style.zIndex = 0;
           backArea.style.top = '-9999px';
      } else {
          document.getElementById('emb-Front-Area').style.visibility = 'visible';
          document.getElementById('emb-Back-area').style.visibility = 'visible';

      }

      Promise.all([
          captureDiv('emb-Front-Area'),
          captureDiv('emb-Back-area')
      ]).then(function(canvases) {
          var canvas1 = canvases[0];
          var canvas2 = canvases[1];

          console.log('Canvas 1 dimensions:', canvas1.width, canvas1.height);
          console.log('Canvas 2 dimensions:', canvas2.width, canvas2.height);

          var combinedCanvas = document.createElement('canvas');
          var ctx = combinedCanvas.getContext('2d');

          combinedCanvas.width = Math.max(canvas1.width, canvas2.width);
          combinedCanvas.height = canvas1.height + canvas2.height;

          console.log('Combined canvas dimensions:', combinedCanvas.width, combinedCanvas.height);

          ctx.drawImage(canvas1, 0, 0);
          ctx.drawImage(canvas2, 0, canvas1.height);

          var combinedImageURL = combinedCanvas.toDataURL('image/png');
          var counter = 2;
          embuploadBlob(combinedImageURL, 'input[name="customized_image_url_front"]', counter);

          // var combinedScreenshotContainer = document.getElementById('combined-screenshot');
          // combinedScreenshotContainer.innerHTML = ''; // Clear previous content

          var img = new Image();
          img.src = combinedImageURL;

          img.onload = function() {
              console.log('Combined image loaded successfully.');
          };

          img.onerror = function() {
              console.error('Error loading combined image.');
          };

          // combinedScreenshotContainer.appendChild(img);
      }).catch(function(error) {
          console.error('Error capturing divs:', error);
      });
  }
</script>
