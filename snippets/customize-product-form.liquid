{% assign variant = product.selected_or_first_available_variant %}
<!--
  {{ variant.price | money }}
  {{ variant.id }}
-->
<!-- {{ variant | json}} -->

<style>
  .patch-not-allowed{
    height: 70px;
    width: 70px;
    display: flex;
    align-items: center;
    justify-content: center;
    border: 1px solid transparent;
    position: relative;
    flex-direction: column;
  }
  .span-content{
    font-size: 20px !important;
    text-transform: uppercase;
  }
    .variants-container {
      display: none;
      position: absolute;
      bottom: 61px;
      color: #747474;
      font-weight: 500;
      left: 0;
      width: 100%;
      background-color: white;
      animation: slide-up 0.5s ease forwards;
      padding: 29px 23px;
      border-top-left-radius: 25px;
      border-top-right-radius: 25px;
      background: rgb(255 255 255);
  }

  @keyframes slide-up {
      from {
          transform: translateY(100%);
      }
      to {
          transform: translateY(0);
      }
  }
  .patch-customization-offcanvas-form{
    position:relative;
  }
  .patch-customizaton-foter{
    bottom: 0;
    padding: 20px 40px;
    border-top: 1px solid #dddddd;
    width: 35%;
    position: fixed;
    background: #ffffff;
  }
  .patches-customization-form-buttons{
    display: flex;
    width: 100%;
    position: relative;
  }
  .fotter-Summary-button{
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight:600;
    gap: 10px;
    padding: 12px 36px;
    background: #f8f8f8;
    color: black;
    border-top-left-radius: 20px;
    border-bottom-left-radius: 20px;
    cursor:pointer;
    width: 40%;
  }
  .fotter-Summary-button > span {
    font-size: 17px;
  }
  .add-item{
    font-weight:600;
    padding: 12px;
    display: flex;
    align-items: center;
    justify-content: center;
    background: #ffe2e8;
    border-top-right-radius: 20px;
    border-bottom-right-radius: 20px;
    width: 60%;
    cursor: pointer;
  }
  .total-price{
    border-top: 1px solid #dddddd;
    margin-top: 20px;
    padding-top: 12px;
    display:flex;
    justify-content:space-between;
  }
  .customization-patch-product-information{
    display:flex;
    justify-content:space-between;
  }
  .loader-cart {
            border: 2px solid #f3f3f3; /* Light grey */
            border-top: 2px solid #ff5477; /* Blue */
            border-radius: 50%;
            width: 25px;
            height: 25px;
            animation: spin 2s linear infinite;
            display:none;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
  .loader-cart-contiune {
            border: 2px solid #f3f3f3; /* Light grey */
            border-top: 2px solid #ff5477; /* Blue */
            border-radius: 50%;
            width: 25px;
            height: 25px;
            animation: spin2 2s linear infinite;
            display:none;
        }

        @keyframes spin2 {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
  @media screen and (max-width: 1024px){
     .span-content {
    font-size: 17px !important;
    }
  }
  @media screen and (max-width: 376px){
    .span-content {
    font-size: 17px !important;
    }
  }
</style>

<div id="currency-format" data-money-format="{{ shop.money_format }}"></div>

<input type="hidden" name="customized_image_url_front" value="">
<input type="hidden" name="customized_image_url_back" value="">
<input type="hidden" name="customized_price" value="">
<input type="hidden" name="size_variants_data" id="size_variants_data" value="">
<input type="hidden" name="selective_variant_ID" id="selective_variant_ID" value="">
<input type="hidden" name="selective_variant_name" id="selective_variant_name" value="">
<div
  class="overlapping-correction-error"
  style=""
>
  Please correct overlapping error first
</div>
<div class="overlapping-correction-error" id="Out-of-stock-error"></div>
<div class="patch-customization-btn-wrap">
  <div class="complete-overly-wrapper"></div>
  <div id="variantsContainer" class="variants-container"></div>
  <div class="patches-customization-form-buttons">
    <div class="fotter-Summary-button">
      <span>Summary</span>
      <svg
        width="8"
        height="14"
        viewBox="0 0 8 14"
        fill="none"
        xmlns="http://www.w3.org/2000/svg"
        class="patches-arrow-top toggle-summary-svg toggle-summary-svg-active"
      >
        <path d="M7 13L1 7" stroke="currentColor" stroke-width="2" stroke-linecap="round"></path><path d="M1 7.00002L6.99994 1.00002" stroke="currentColor" stroke-width="2" stroke-linecap="round" ></path>
      </svg>
      <svg
        width="8"
        height="14"
        viewBox="0 0 8 14"
        fill="none"
        xmlns="http://www.w3.org/2000/svg"
        class="patches-arrow-left toggle-summary-svg"
      >
        <path d="M7 13L1 7" stroke="currentColor" stroke-width="2" stroke-linecap="round"></path><path d="M1 7.00002L6.99994 1.00002" stroke="currentColor" stroke-width="2" stroke-linecap="round" ></path>
      </svg>
    </div>
    <div class="add-item">
      <span class="span-content">Add to bag</span>
      <div class="loader-cart"></div>
    </div>
  </div>
</div>

<script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
<!-- REMOVE html2canvas; not needed anymore -->
<script>
/** =================== CONFIG =================== **/
const CURRENCY_FORMAT_EL_ID = 'currency-format';
const S3_UPLOAD_ENDPOINT = 'https://6ch1pxqng1.execute-api.ap-south-1.amazonaws.com/check';

/** =================== GLOBALS =================== **/
const $ = window.jQuery;
const product = {{ product | json }};
const PARENT_PROPS = new Map();
let   PATCHESDATA_CACHE = null;

(async () => {
  try {
    const r = await fetch('https://lolaandtheboys.com/apps/data-pickup', { cache: 'force-cache' });
    if (r.ok) PATCHESDATA_CACHE = await r.json();
  } catch (_) {}
})();

const SESSION_TOKEN = () =>
  (Date.now().toString(36) + Math.random().toString(36).slice(2, 8)).toUpperCase();

function moneySymbol() {
  const el = document.getElementById(CURRENCY_FORMAT_EL_ID);
  if (!el) return '$';
  const currencyFormat = el.dataset.moneyFormat || '{{amount}}';
  const amountPlaceholder = (currencyFormat.match(/\{\{amount\}\}/) || ['{{amount}}'])[0];
  return currencyFormat.replace(amountPlaceholder, '').trim();
}

/** ============== IMAGE COMPOSITOR (CANVAS) ============== **/

// CORS-safe image loader
function loadImageCORS(src) {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.crossOrigin = 'anonymous';
    img.decoding = 'async';
    img.onload = () => resolve(img);
    img.onerror = reject;
    img.src = src;
  });
}

// helpers for CSS -> number
const num = (v) => Math.max(0, parseFloat(v) || 0);

// parse object-position
function parseObjectPosition(opStr = '50% 50%') {
  const map = { left:'0% 50%', top:'50% 0%', center:'50% 50%', right:'100% 50%', bottom:'50% 100%' };
  opStr = (opStr || '').trim().toLowerCase();
  if (map[opStr]) opStr = map[opStr];
  const p = opStr.split(/\s+/);
  const toFrac = (t) => {
    if (!t) return 0.5;
    if (t.endsWith('%')) return Math.min(1, Math.max(0, parseFloat(t)/100));
    if (t === 'left' || t === 'top') return 0;
    if (t === 'center') return 0.5;
    if (t === 'right' || t === 'bottom') return 1;
    return 0.5;
  };
  return { x: toFrac(p[0]), y: toFrac(p[1] || p[0]) };
}

// compute rect for object-fit inside a given box (content box)
function computeObjectFitRect(nw, nh, boxW, boxH, fit='fill', pos={x:0.5,y:0.5}) {
  let w = boxW, h = boxH;
  if (fit === 'contain' || fit === 'cover' || fit === 'scale-down') {
    const sx = boxW / nw, sy = boxH / nh;
    let s = 1;
    if (fit === 'contain') s = Math.min(sx, sy);
    else if (fit === 'cover') s = Math.max(sx, sy);
    else s = Math.min(1, Math.min(sx, sy));
    w = nw * s; h = nh * s;
  } else if (fit === 'none') { w = nw; h = nh; } // 'fill' keeps boxW x boxH
  const offX = (boxW - w) * pos.x;
  const offY = (boxH - h) * pos.y;
  return { drawW: w, drawH: h, offsetX: offX, offsetY: offY };
}

// Compose one side: base + patches (respects object-fit & content-box)
async function composeArea({
  areaEl,
  baseImgSelector,
  patchSelector = '.patch-',
  background = '#ffffff',
  jpegQuality = 0.85
}) {
  if (!areaEl) throw new Error('composeArea: areaEl missing');
  const baseEl = areaEl.querySelector(baseImgSelector);
  if (!baseEl) throw new Error(`Base image not found by selector ${baseImgSelector}`);

  // load base at natural resolution
  const baseImg = await loadImageCORS(baseEl.currentSrc || baseEl.src);

  // DOM rendered size of base
  const baseRect = baseEl.getBoundingClientRect();
  const baseRenderedW = baseRect.width  || baseImg.naturalWidth;
  const baseRenderedH = baseRect.height || baseImg.naturalHeight;

  // DOMâ†’natural scale
  const scaleX = baseImg.naturalWidth  / baseRenderedW;
  const scaleY = baseImg.naturalHeight / baseRenderedH;

  // canvas at natural resolution
  const canvas = document.createElement('canvas');
  canvas.width  = baseImg.naturalWidth;
  canvas.height = baseImg.naturalHeight;
  const ctx = canvas.getContext('2d', { alpha: false });
  ctx.imageSmoothingEnabled = true; ctx.imageSmoothingQuality = 'high';

  // background + base
  ctx.fillStyle = background;
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  ctx.drawImage(baseImg, 0, 0, canvas.width, canvas.height);

  // draw patches
  const patchWrappers = areaEl.querySelectorAll(patchSelector);
  for (const wrap of patchWrappers) {
    const imgEl = wrap.querySelector('img.patch-image');
    if (!imgEl) continue;

    // wrapper border-box rect relative to base
    const a = wrap.getBoundingClientRect();
    const b = baseEl.getBoundingClientRect();
    let x = a.left - b.left, y = a.top - b.top, w = a.width, h = a.height;

    // convert to CONTENT box (remove border + padding to match object-fit spec)
    const ws = getComputedStyle(wrap);
    const bl = num(ws.borderLeftWidth), br = num(ws.borderRightWidth),
          bt = num(ws.borderTopWidth),  bb = num(ws.borderBottomWidth),
          pl = num(ws.paddingLeft),     pr = num(ws.paddingRight),
          pt = num(ws.paddingTop),      pb = num(ws.paddingBottom);
    const contentX = x + bl + pl;
    const contentY = y + bt + pt;
    const contentW = Math.max(0, w - bl - br - pl - pr);
    const contentH = Math.max(0, h - bt - bb - pt - pb);
    if (contentW <= 0 || contentH <= 0) continue;

    try {
      const img = await loadImageCORS(imgEl.currentSrc || imgEl.src);
      const cs = getComputedStyle(imgEl);
      const fit = (cs.objectFit || 'fill').toLowerCase();
      const pos = parseObjectPosition(cs.objectPosition || '50% 50%');

      const { drawW, drawH, offsetX, offsetY } =
        computeObjectFitRect(img.naturalWidth, img.naturalHeight, contentW, contentH, fit, pos);

      // clip to the CONTENT box
      const clipX = Math.floor(contentX * scaleX);
      const clipY = Math.floor(contentY * scaleY);
      const clipW = Math.floor(contentW * scaleX);
      const clipH = Math.floor(contentH * scaleY);

      ctx.save();
      ctx.beginPath();
      ctx.rect(clipX, clipY, clipW, clipH);
      ctx.clip();

      // destination in natural px (use floor to avoid 1-px overshoot)
      const dx = Math.round((contentX + offsetX) * scaleX);
      const dy = Math.round((contentY + offsetY) * scaleY);
      const dw = Math.floor(drawW * scaleX);
      const dh = Math.floor(drawH * scaleY);

      ctx.drawImage(img, dx, dy, dw, dh);
      ctx.restore();
    } catch (e) {
      console.warn('Patch failed to load (skipped):', e, wrap);
    }
  }

  // export + preview
  const blob = await new Promise(res => canvas.toBlob(b => res(b), 'image/jpeg', jpegQuality));
  const objectURL = URL.createObjectURL(blob);
  console.log(`[COMPOSITE:${areaEl.id}] preview:`, { w: canvas.width, h: canvas.height, url: objectURL });

  return { canvas, blob, objectURL };
}

// combine front+back vertically (back optional)
async function composeFrontBackAndExport({
  background = '#ffffff',
  jpegQuality = 0.85,
  maxWidth = 1200
} = {}) {
  const frontArea = document.getElementById('Front-Area');
  if (!frontArea) throw new Error('Front-Area not found');

  const backArea = document.getElementById('Back-Area') || document.getElementById('Back-area');

  const frontOut = await composeArea({
    areaEl: frontArea,
    baseImgSelector: '#Front-image',
    background, jpegQuality
  });

  let backOut = null;
  if (backArea && backArea.querySelector('#Back-image')) {
    try {
      backOut = await composeArea({
        areaEl: backArea,
        baseImgSelector: '#Back-image',
        background, jpegQuality
      });
    } catch (_) { backOut = null; }
  }

  if (!backOut) return frontOut;

  const width  = Math.max(frontOut.canvas.width, backOut.canvas.width);
  const height = frontOut.canvas.height + backOut.canvas.height;
  const combo  = document.createElement('canvas');
  combo.width  = width;
  combo.height = height;
  const cctx = combo.getContext('2d', { alpha: false });
  cctx.fillStyle = background;
  cctx.fillRect(0, 0, width, height);
  cctx.drawImage(frontOut.canvas, 0, 0);
  cctx.drawImage(backOut.canvas,  0, frontOut.canvas.height);

  // optional downscale for filesize
  let target = combo;
  if (maxWidth && combo.width > maxWidth) {
    const scale = maxWidth / combo.width;
    const down = document.createElement('canvas');
    down.width  = Math.round(combo.width * scale);
    down.height = Math.round(combo.height * scale);
    const dctx = down.getContext('2d', { alpha: false });
    dctx.fillStyle = background;
    dctx.fillRect(0, 0, down.width, down.height);
    dctx.drawImage(combo, 0, 0, down.width, down.height);
    target = down;
  }

  const blob = await new Promise(res => target.toBlob(b => res(b), 'image/jpeg', jpegQuality));
  const objectURL = URL.createObjectURL(blob);
  console.log('[COMPOSITE:FRONT+BACK] preview:', { w: target.width, h: target.height, url: objectURL });

  return { canvas: target, blob, objectURL };
}

/** ============== S3 + CART HELPERS ============== **/
async function uploadBlobToS3(blob) {
  const fd = new FormData();
  fd.append('image', blob, 'custom.jpg');
  const r = await fetch(S3_UPLOAD_ENDPOINT, { method: 'POST', body: fd });
  const json = await r.json();
  if (!json || !json.fileUrl) throw new Error('No fileUrl in S3 response');
  console.log('[S3] Uploaded URL:', json.fileUrl);
  return json.fileUrl;
}

async function updateLineItemPropsByKey(lineItemKey, newProps) {
  const r = await fetch('/cart/change.js', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ id: lineItemKey, properties: newProps })
  });
  if (!r.ok) throw new Error('Failed to update line item');
  return r.json();
}

async function getCart() {
  const r = await fetch('/cart.js', { cache: 'no-store' });
  return r.json();
}

/** ============== PRICE / SELECTIONS ============== **/
function collectPatchSelectionsAndPrice() {
  const symbol = moneySymbol();
  let productPrice = parseFloat(String('{{ product.price }}').replace(/[^\d.]/g, '')) || 0;
  const selected = [];
  const patchDivs = document.querySelectorAll('.patch-');

  const alphabets = PATCHESDATA_CACHE?.alphabets || [];
  const patches   = PATCHESDATA_CACHE?.patches   || [];
  document.querySelectorAll('.patch-').forEach(p => {
  console.log('Element:', p, 'v-id:', p.getAttribute('v-id'));
});
  console.log('Alphabets data:', PATCHESDATA_CACHE?.alphabets);
  patchDivs.forEach(patch => {
    const vId = patch.getAttribute('v-id');
    const Id  = patch.getAttribute('id');
    const alphabetVariant = alphabets.find(x => String(x.id) === String(vId));
    const patchVariant    = patches.find(x => String(x.id) === String(vId));
    const variant = { ...alphabetVariant, ...patchVariant };

    const priceNum = parseFloat(variant?.price);
      const variantIdNum = variant?.variant_id
    ? Number(variant.variant_id)
    : isNaN(Number(variant.name)) ? null : Number(variant.name);
console.log('Checking variant', variant, priceNum, variantIdNum);
    if (variant && !isNaN(priceNum) && !isNaN(variantIdNum) && variantIdNum > 0) {
      productPrice += priceNum;
      selected.push({
        id: Id,
        label: variant.alphabetname || variant.patchname || variant.name || String(variant.variant_id),
        variantId: variantIdNum
      });
    }
  });

  return { symbol, totalPrice: productPrice, selected };
}

/** ============== ADD TO CART (after image ready) ============== **/
async function addToCartWithImage(sessionId, s3Url) {
  const sizeVariants = document.querySelector('input[name="size_variants_data"]')?.value || '';
  const messageData  = document.querySelector('textarea[name="messagefield"]')?.value || '';
  const variantIDRaw = document.querySelector('input[name="selective_variant_ID"]')?.value || '';
  const variantID    = Number(variantIDRaw);
  if (!Number.isFinite(variantID)) throw new Error('Invalid parent variantID');

  const { symbol, totalPrice, selected } = collectPatchSelectionsAndPrice();
  $('input[name="customized_price"]').val(symbol + totalPrice);

  const now = Date.now().toString();
  const parentProps = {
    "Product Name": product.title,
    _customized_image_url_front: s3Url || 'pending',
    _customized_image_url_back:  s3Url || 'pending',
    _size: sizeVariants,
    _info: messageData,
    _patches_price: symbol + totalPrice,
    _Session: sessionId,
    _Parent: '1',
    _Timestamp: now
  };

  const items = [{ id: variantID, quantity: 1, properties: parentProps }];

  // children
  for (const sel of selected) {
    if (!Number.isFinite(sel.variantId)) continue;
    items.push({
      id: sel.variantId,
      quantity: 1,
      properties: {
        name: 'Custom Product',
        _parent_variant: variantID,
        _Session: sessionId,
        _ChildOf: '1',
        _Unique: `${sel.id}_${now}`,
        _Timestamp: now
      }
    });
  }

  const r = await fetch(`${window.Shopify?.routes?.root || '/'}cart/add.js`, {
    method: 'POST',
    headers: {'Content-Type': 'application/json'},
    body: JSON.stringify({ items })
  });
  if (!r.ok) throw new Error('add.js failed');

  // capture parent key (optional; handy for future updates)
  let parentKey = null;
  try {
    const resp = await r.clone().json();
    if (resp?.items?.length) {
      const addedParent = resp.items.find(it => it?.properties?._Session === sessionId && it?.properties?._Parent === '1');
      parentKey = addedParent?.key || null;
    } else if (resp?.key) {
      parentKey = resp.key;
    }
  } catch (_) {}

  if (!parentKey) {
    const cart = await getCart();
    const parent = cart.items.find(i => i.properties && i.properties._Session === sessionId && i.properties._Parent === '1');
    parentKey = parent?.key || null;
  }

  if (parentKey) PARENT_PROPS.set(parentKey, parentProps);

  console.log('[1] Products added to cart (with image) successfully');
  return { parentKey };
}

/** ============== OPTIONAL FEE CLEANUP ============== **/
async function maybeRemoveStitchingFee() {
  try {
    const cart = await getCart();
    const hasEmbroideryProduct = cart.items.some(i => i.properties && i.properties._embroideryProduct === 'Embroidery Product');
    if (!hasEmbroideryProduct) {
      const fee = cart.items.find(i => i.variant_id === 42085140430950);
      if (fee) {
        await fetch('/cart/change.js', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ id: fee.key, quantity: 0 })
        });
      }
    }
  } catch (_) {}
}

/** ============== BUTTON WIRING ============== **/
document.addEventListener('DOMContentLoaded', function () {
  const addBtn  = document.querySelector('.add-item');
  const loader  = document.querySelector('.loader-cart');
  const spanDiv = document.querySelector('.span-content');

  // Warm up cart
  setTimeout(() => { fetch('/cart.js', { cache: 'no-store' }).catch(()=>{}); }, 0);

  if (!addBtn) return;

  addBtn.addEventListener('click', async function () {
    if ($('.overlapping-error').css('visibility') === 'visible') {
      $('.overlapping-correction-error').css('display', 'block');
      return;
    }

    if (loader) loader.style.display = 'block';
    if (spanDiv) spanDiv.style.display = 'none';
    addBtn.style.pointerEvents = 'none';
    addBtn.style.opacity = '0.5';
    addBtn.style.backgroundColor = '#dfdfdf';

    // lock UI while building image
    document.querySelectorAll('.patch').forEach(el => {
      el.classList.remove('patch');
      el.classList.add('patch-not-allowed');
      el.setAttribute('draggable', 'false');
    });

    const sessionId = SESSION_TOKEN();

    try {
      // 1) Compose the image(s)
      const { blob } = await composeFrontBackAndExport({
        jpegQuality: 0.85,
        maxWidth: 1200
      });

      // 2) Upload to S3
      const s3Url = await uploadBlobToS3(blob);
      console.log('[S3] Uploaded and ready. URL:', s3Url);

      // 3) Add items to cart with the image URL already set
      await addToCartWithImage(sessionId, s3Url);

      // 4) Optional clean-up (same as before)
      await maybeRemoveStitchingFee();

    } catch (err) {
      const outDiv = document.getElementById('Out-of-stock-error');
      if (outDiv) {
        outDiv.style.display = 'block';
        outDiv.style.visibility = 'visible';
        outDiv.textContent = 'Error adding to cart';
        setTimeout(() => { outDiv.style.display = 'none'; outDiv.style.visibility = 'hidden'; }, 5000);
      }
      console.error('Add to cart (after image) failed:', err);
    } finally {
      // restore button UI
      if (loader) loader.style.display = 'none';
      if (spanDiv) spanDiv.style.display = 'block';
      addBtn.style.pointerEvents = 'auto';
      addBtn.style.opacity = '1';
      addBtn.style.backgroundColor = '';
    }
  });
});
</script>

