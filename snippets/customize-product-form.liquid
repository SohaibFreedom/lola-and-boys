{% assign variant = product.selected_or_first_available_variant %}
<!--
  {{ variant.price | money }}
  {{ variant.id }}
-->
<!-- {{ variant | json}} -->

<style>
  .fotter-Summary-button:hover{
    background:rgb(0, 0, 0);
    color: white;
  }
  .footer-Summary-button:hover svg path {
  stroke: #fff; /* or your desired hover color */
  transition: stroke 0.3s ease;
}
  .customization-patch-product-name{
    font-weight: 400;
    font-size: 16px;
    line-height: 1.4;
    color: #2c272d;
  }
  .total-price span{
    font-size: 16px;
    font-weight: 500;
    line-height: 1.4;
    color: #2c272d;
    padding-right: 5px;
  }
  .span-content{
    font-size: 16px !important;
    text-transform: uppercase;
  }
.variants-container {
  position: absolute;
  bottom: 0;
  right: 0;
  width: 100%;
  padding: 24px;
  padding-bottom: 48px;
  background-color: #fff;
  border-top-left-radius: 20px;
  border-top-right-radius: 20px;
  z-index: 2;
  
  /* Hidden state */
  transform: translateY(0);
  opacity: 0;
  pointer-events: none;
  
  /* Animation */
  transition: all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
}

.variants-container-open {
  transform: translateY(-30px);
  opacity: 1;
  pointer-events: auto;
}


  @keyframes slide-up {
      from {
          transform: translateY(100%);
      }
      to {
          transform: translateY(0);
      }
  }
  .patch-customization-offcanvas-form{
    position:relative;
  }
  .patch-customizaton-foter{
    bottom: 0;
    border-top: 1px solid #dddddd;
    width: 100%;
    position: absolute;
    background: #ffffff;
  }
  .patch-customization-btn-wrap{
   position:relative;
  }
  .patch-customization-btn-outer-wrapper, .variant-selector-sidebar-foter {
        padding: 13px 24px;
  }
  .patches-customization-form-buttons{
    display: flex;
    width: 100%;
    position: relative; 
    z-index:3;
  }
  .fotter-Summary-button{
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight:600;
    gap: 10px;
    padding: 12px 36px;
    color: black;
    border-radius: 100px 0 0 100px;
    cursor:pointer;
    background:white;
  }
  .fotter-Summary-button > span {
    font-size: 16px;
    text-transform: uppercase;
    letter-spacing: 0.32px !important;
  }
  .add-item{
    font-weight:600;
    padding: 12px;
    display: flex;
    align-items: center;
    justify-content: center;
    background: #2c272d;
    color: white;
   border-radius: 0 100px 100px 0;
    width: 50%;
    cursor: pointer;
  }
  .total-price{
    border-top: 1px solid #dddddd;
    padding-top: 16px;
    margin-top: 25px;
    display:flex;
    justify-content:space-between;
  }
  .customization-patch-product-information{
    display:flex;
    justify-content:space-between;
    margin-top: 12px;
  }
  .loader-cart {
             border: 2px solid #f3f3f3; /* Light grey */
            border-top: 2px solid  #2c272d; /* Blue */
            border-radius: 50%;
            width: 25px;
            height: 25px;
            animation: spin 2s linear infinite;
            display:none;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
  .loader-cart-contiune {
            border: 2px solid #f3f3f3; /* Light grey */
            border-top: 2px solid  #2c272d; /* Blue */
            border-radius: 50%;
            width: 25px;
            height: 25px;
            animation: spin2 2s linear infinite;
            display:none;
        }

        @keyframes spin2 {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
  @media screen and (max-width: 1024px){
     .span-content {
    font-size: 17px !important;
    }
  }
  @media screen and (max-width: 900px){
      .custom-cart-drawer-for-app-main-wrapp{
          padding: 40px 16px 0px 20px;
    }
  }
  @media screen and (max-width: 376px){
    .span-content {
    font-size: 14px !important;
    }
  }
</style>

<div id="currency-format" data-money-format="{{ shop.money_format }}"></div>

<input type="hidden" name="customized_image_url_front" value="">
<input type="hidden" name="customized_image_url_back" value="">
<input type="hidden" name="customized_price" value="">
<input type="hidden" name="size_variants_data" id="size_variants_data" value="">
<input type="hidden" name="selective_variant_ID" id="selective_variant_ID" value="">
<input type="hidden" name="selective_variant_name" id="selective_variant_name" value="">

<div class="patch-customization-btn-outer-wrapper">
  <div
  class="overlapping-correction-error"
  style=""
>
  Please correct overlapping error first
</div>
<div class="patch-customization-btn-wrap">
  <div class="complete-overly-wrapper"></div>
  <div id="variantsContainer" class="variants-container"></div>
  <div class="patches-customization-form-buttons add-to-bag-btns-wrapper">
    
    
    <div class="fotter-Summary-button">
      <span>Summary</span>
      <svg
        width="8"
        height="14"
        viewBox="0 0 8 14"
        fill="none"
        xmlns="http://www.w3.org/2000/svg"
        class="patches-arrow-top toggle-summary-svg toggle-summary-svg-active"
      >
        <path d="M7 13L1 7" stroke="currentColor" stroke-width="2" stroke-linecap="round"></path><path d="M1 7.00002L6.99994 1.00002" stroke="currentColor" stroke-width="2" stroke-linecap="round" ></path>
      </svg>
      <svg
        width="8"
        height="14"
        viewBox="0 0 8 14"
        fill="none"
        xmlns="http://www.w3.org/2000/svg"
        class="patches-arrow-left toggle-summary-svg"
      >
        <path d="M7 13L1 7" stroke="currentColor" stroke-width="2" stroke-linecap="round"></path><path d="M1 7.00002L6.99994 1.00002" stroke="currentColor" stroke-width="2" stroke-linecap="round" ></path>
      </svg>
    </div>
    <div class="add-item">
      <span class="span-content">Add to bag</span>
      <div class="loader-cart"></div>
    </div>
  </div>
</div>
</div>
<script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
<!-- REMOVE html2canvas; not needed anymore -->
<script>
  
/** =================== CONFIG =================== **/
const CURRENCY_FORMAT_EL_ID = 'currency-format';
const S3_UPLOAD_ENDPOINT = 'https://6ch1pxqng1.execute-api.ap-south-1.amazonaws.com/check';

/** =================== GLOBALS =================== **/
const $ = window.jQuery;
const product = {{ product | json }};
const PARENT_PROPS = new Map();
let   PATCHESDATA_CACHE = null;

(async () => {
  try {
    const r = await fetch('https://lolaandtheboys.com/apps/data-pickup', { cache: 'force-cache' });
    if (r.ok) PATCHESDATA_CACHE = await r.json();
  } catch (_) {}
})();

const SESSION_TOKEN = () =>
  (Date.now().toString(36) + Math.random().toString(36).slice(2, 8)).toUpperCase();

function moneySymbol() {
  const el = document.getElementById(CURRENCY_FORMAT_EL_ID);
  if (!el) return '$';
  const currencyFormat = el.dataset.moneyFormat || '{{amount}}';
  const amountPlaceholder = (currencyFormat.match(/\{\{amount\}\}/) || ['{{amount}}'])[0];
  return currencyFormat.replace(amountPlaceholder, '').trim();
}

/** ============== IMAGE COMPOSITOR (CANVAS) ============== **/

// CORS-safe image loader
function loadImageCORS(src) {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.crossOrigin = 'anonymous';
    img.decoding = 'async';
    img.onload = () => resolve(img);
    img.onerror = reject;
    img.src = src;
  });
}
/** Remove parent and its children (matched by _Timestamp or _Session) **/
/**
 * Remove all cart items that share the same _Timestamp or _Session.
 * Sequential removal to prevent grouping deletions.
 * Pass removeParent = false to avoid removing the parent.
 */
async function removeParentAndChildren(timestampOrSession, removeParent = true) {
  const cart = await getCart();
  if (!cart?.items?.length) return;

  // Define targets based on _Timestamp or _Session matching
  const targets = cart.items.filter(
    i =>
      i.properties &&
      (
        i.properties._Timestamp === timestampOrSession ||
        i.properties._Session === timestampOrSession
      )
  );

  if (targets.length === 0) {
    console.log('[CART] No matching items found to remove.');
    return;
  }

  // Sequential removal of each item (parent or child)
  for (const t of targets) {
    const isParent = t.properties?._Parent === '1' || !t.properties?._ChildOf && !t.properties?._parent_variant;

    // Skip removal of parent if removeParent = false
    if (!removeParent && isParent) {
      console.log('[CART] Skipping parent removal:', t.title, t.key);
      continue; // Skip parent if we're only removing patches
    }

    try {
      const response = await fetch('/cart/change.js', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ id: t.key, quantity: 0 }),
      });
      if (!response.ok) {
        console.warn('Failed to remove item:', t.title, t.key);
      } else {
        console.log(`[CART] Removed ${isParent ? 'parent' : 'child'} item:`, t.title, t.key);
      }
    } catch (err) {
      console.warn('Error removing item:', t, err);
    }
  }
}



// helpers for CSS -> number
const num = (v) => Math.max(0, parseFloat(v) || 0);

// parse object-position
function parseObjectPosition(opStr = '50% 50%') {
  const map = { left:'0% 50%', top:'50% 0%', center:'50% 50%', right:'100% 50%', bottom:'50% 100%' };
  opStr = (opStr || '').trim().toLowerCase();
  if (map[opStr]) opStr = map[opStr];
  const p = opStr.split(/\s+/);
  const toFrac = (t) => {
    if (!t) return 0.5;
    if (t.endsWith('%')) return Math.min(1, Math.max(0, parseFloat(t)/100));
    if (t === 'left' || t === 'top') return 0;
    if (t === 'center') return 0.5;
    if (t === 'right' || t === 'bottom') return 1;
    return 0.5;
  };
  return { x: toFrac(p[0]), y: toFrac(p[1] || p[0]) };
}

// compute rect for object-fit inside a given box (content box)
function computeObjectFitRect(nw, nh, boxW, boxH, fit='fill', pos={x:0.5,y:0.5}) {
  let w = boxW, h = boxH;
  if (fit === 'contain' || fit === 'cover' || fit === 'scale-down') {
    const sx = boxW / nw, sy = boxH / nh;
    let s = 1;
    if (fit === 'contain') s = Math.min(sx, sy);
    else if (fit === 'cover') s = Math.max(sx, sy);
    else s = Math.min(1, Math.min(sx, sy));
    w = nw * s; h = nh * s;
  } else if (fit === 'none') { w = nw; h = nh; } // 'fill' keeps boxW x boxH
  const offX = (boxW - w) * pos.x;
  const offY = (boxH - h) * pos.y;
  return { drawW: w, drawH: h, offsetX: offX, offsetY: offY };
}

function getRotationDegrees(el) {
  const style = window.getComputedStyle(el);
  const transform = style.transform || style.webkitTransform;

  // element has NO rotation
  if (!transform || transform === 'none') return 0;

  const matrix = transform.match(/matrix\(([^)]+)\)/);
  if (!matrix) return 0;

  const values = matrix[1].split(',');
  const a = parseFloat(values[0]); // cos
  const b = parseFloat(values[1]); // sin

  let angle = Math.atan2(b, a) * (180 / Math.PI);
  return Math.round(angle);
}

async function composeArea({
  areaEl,
  baseImgSelector,
  patchSelector = ".patch-",
  background = "#ffffff",
  jpegQuality = 0.85
}) {
  if (!areaEl) throw new Error("composeArea: areaEl missing");

  const baseEl = areaEl.querySelector(baseImgSelector);
  if (!baseEl) throw new Error(`Base image not found: ${baseImgSelector}`);

  // ---- LOAD BASE IMAGE ----
  const baseImg = await loadImageCORS(baseEl.currentSrc || baseEl.src);

  const baseRect = baseEl.getBoundingClientRect();
  const renderedW = baseRect.width || baseImg.naturalWidth;
  const renderedH = baseRect.height || baseImg.naturalHeight;

  const scaleX = baseImg.naturalWidth / renderedW;
  const scaleY = baseImg.naturalHeight / renderedH;

  // ---- SETUP CANVAS ----
  const canvas = document.createElement("canvas");
  canvas.width = baseImg.naturalWidth;
  canvas.height = baseImg.naturalHeight;

  const ctx = canvas.getContext("2d", { alpha: false });
  ctx.imageSmoothingEnabled = true;
  ctx.imageSmoothingQuality = "high";

  // Background + base
  ctx.fillStyle = background;
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  ctx.drawImage(baseImg, 0, 0, canvas.width, canvas.height);

  // ---- PATCHES ----
  const patches = areaEl.querySelectorAll(patchSelector);

  for (const wrap of patches) {
    const imgEl = wrap.querySelector("img.patch-image");
    if (!imgEl) continue;

    const wrapRect = wrap.getBoundingClientRect();
    const baseRect2 = baseEl.getBoundingClientRect();

    // DOM relative â†’ natural px
    let x = wrapRect.left - baseRect2.left;
    let y = wrapRect.top - baseRect2.top;
    const w = wrapRect.width;
    const h = wrapRect.height;

    const style = getComputedStyle(wrap);
    const bl = num(style.borderLeftWidth),
      br = num(style.borderRightWidth),
      bt = num(style.borderTopWidth),
      bb = num(style.borderBottomWidth),
      pl = num(style.paddingLeft),
      pr = num(style.paddingRight),
      pt = num(style.paddingTop),
      pb = num(style.paddingBottom);

    const contentX = x + bl + pl;
    const contentY = y + bt + pt;
    const contentW = Math.max(0, w - bl - br - pl - pr);
    const contentH = Math.max(0, h - bt - bb - pt - pb);

    if (contentW <= 0 || contentH <= 0) continue;

    // Load imag
    let img;
    try {
      img = await loadImageCORS(imgEl.currentSrc || imgEl.src);
    } catch (e) {
      console.warn("Patch load failed:", e);
      continue;
    }

    const cs = getComputedStyle(imgEl);
    const fit = (cs.objectFit || "fill").toLowerCase();
    const pos = parseObjectPosition(cs.objectPosition || "50% 50%");

    const { drawW, drawH, offsetX, offsetY } = computeObjectFitRect(
      img.naturalWidth,
      img.naturalHeight,
      contentW,
      contentH,
      fit,
      pos
    );

    // natural px rect
    const dx = Math.round((contentX + offsetX) * scaleX);
    const dy = Math.round((contentY + offsetY) * scaleY);
    const dw = Math.round(drawW * scaleX);
    const dh = Math.round(drawH * scaleY);

    const clipX = Math.round(contentX * scaleX);
    const clipY = Math.round(contentY * scaleY);
    const clipW = Math.round(contentW * scaleX);
    const clipH = Math.round(contentH * scaleY);

    ctx.save();
    ctx.beginPath();
    ctx.rect(clipX, clipY, clipW, clipH);
    ctx.clip();

    // ========== ROTATION FIX (No Size Enlargement) ==========
    const deg = getRotationDegrees(wrap);
    const rad = deg * Math.PI / 180;

    // Compute rotated bounding sizes
    const rotatedW = Math.abs(dw * Math.cos(rad)) + Math.abs(dh * Math.sin(rad));
    const rotatedH = Math.abs(dw * Math.sin(rad)) + Math.abs(dh * Math.cos(rad));

    // Compensation scale (prevent patch from becoming bigger)
    const scaleFix = Math.min(dw / rotatedW, dh / rotatedH);

    const cx = dx + dw / 2;
    const cy = dy + dh / 2;

    ctx.translate(cx, cy);
    ctx.rotate(rad);
    ctx.scale(scaleFix, scaleFix);

    ctx.drawImage(img, -dw / 2, -dh / 2, dw, dh);

    ctx.restore();
  }

  // ---- EXPORT CANVAS SAFELY (Shopify-proof) ----
  let blob, objectURL;
  try {
    blob = await new Promise(res =>
      canvas.toBlob(b => res(b), "image/jpeg", jpegQuality)
    );
    objectURL = URL.createObjectURL(blob);
  } catch (err) {
    console.warn("Canvas export blocked by Shopify/CSP:", err);
  }

  return { canvas, blob, objectURL };
}


// combine front+back vertically (back optional)
async function composeFrontBackAndExport({
  background = '#ffffff',
  jpegQuality = 0.85,
  maxWidth = 1200
} = {}) {
  const frontArea = document.getElementById('Front-Area');
  if (!frontArea) throw new Error('Front-Area not found');

  const backArea = document.getElementById('Back-Area') || document.getElementById('Back-area');

  const frontOut = await composeArea({
    areaEl: frontArea,
    baseImgSelector: '#Front-image',
    background, jpegQuality
  });

  let backOut = null;
  if (backArea && backArea.querySelector('#Back-image')) {
    try {
      backOut = await composeArea({
        areaEl: backArea,
        baseImgSelector: '#Back-image',
        background, jpegQuality
      });
    } catch (_) { backOut = null; }
  }

  if (!backOut) return frontOut;

  const width  = Math.max(frontOut.canvas.width, backOut.canvas.width);
  const height = frontOut.canvas.height + backOut.canvas.height;
  const combo  = document.createElement('canvas');
  combo.width  = width;
  combo.height = height;
  const cctx = combo.getContext('2d', { alpha: false });
  cctx.fillStyle = background;
  cctx.fillRect(0, 0, width, height);
  cctx.drawImage(frontOut.canvas, 0, 0);
  cctx.drawImage(backOut.canvas,  0, frontOut.canvas.height);

  // optional downscale for filesize
  let target = combo;
  if (maxWidth && combo.width > maxWidth) {
    const scale = maxWidth / combo.width;
    const down = document.createElement('canvas');
    down.width  = Math.round(combo.width * scale);
    down.height = Math.round(combo.height * scale);
    const dctx = down.getContext('2d', { alpha: false });
    dctx.fillStyle = background;
    dctx.fillRect(0, 0, down.width, down.height);
    dctx.drawImage(combo, 0, 0, down.width, down.height);
    target = down;
  }

  const blob = await new Promise(res => target.toBlob(b => res(b), 'image/jpeg', jpegQuality));
  const objectURL = URL.createObjectURL(blob);
  console.log('[COMPOSITE:FRONT+BACK] preview:', { w: target.width, h: target.height, url: objectURL });

  return { canvas: target, blob, objectURL };
}


/** ============== S3 + CART HELPERS ============== **/
async function uploadBlobToS3(blob) {
  const fd = new FormData();
  fd.append('image', blob, 'custom.jpg');
  const r = await fetch(S3_UPLOAD_ENDPOINT, { method: 'POST', body: fd });
  const json = await r.json();
  if (!json || !json.fileUrl) throw new Error('No fileUrl in S3 response');
  console.log('[S3] Uploaded URL:', json.fileUrl);
  return json.fileUrl;
}

async function updateLineItemPropsByKey(lineItemKey, newProps) {
  const r = await fetch('/cart/change.js', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ id: lineItemKey, properties: newProps })
  });
if (!r.ok) {
  const text = await r.text();
  console.log('erooorr')
  console.log("CHANGE ERROR:", text);
  throw new Error('Failed to update line item');
}
  return r.json();
}

async function getCart() {
  const r = await fetch('/cart.js', { cache: 'no-store' });
  return r.json();
}

/** ============== PRICE / SELECTIONS ============== **/
function collectPatchSelectionsAndPrice() {
  const symbol = moneySymbol();
  let productPrice = parseFloat(String('{{ product.price }}').replace(/[^\d.]/g, '')) || 0;
  const selected = [];
  const patchDivs = document.querySelectorAll('.patch-');

  const alphabets = PATCHESDATA_CACHE?.alphabets || [];
  const patches   = PATCHESDATA_CACHE?.patches   || [];
  document.querySelectorAll('.patch-').forEach(p => {
  console.log('Element:', p, 'v-id:', p.getAttribute('v-id'));
});
  console.log('Alphabets data:', PATCHESDATA_CACHE?.alphabets);
  patchDivs.forEach(patch => {
    const vId = patch.getAttribute('v-id');
    const Id  = patch.getAttribute('id');
    const alphabetVariant = alphabets.find(x => String(x.id) === String(vId));
    const patchVariant    = patches.find(x => String(x.id) === String(vId));
    const variant = { ...alphabetVariant, ...patchVariant };

    const priceNum = parseFloat(variant?.price);
      const variantIdNum = variant?.variant_id
    ? Number(variant.variant_id)
    : isNaN(Number(variant.name)) ? null : Number(variant.name);
console.log('Checking variant', variant, priceNum, variantIdNum);
    if (variant && !isNaN(priceNum) && !isNaN(variantIdNum) && variantIdNum > 0) {
      productPrice += priceNum;
      selected.push({
        id: Id,
        label: variant.alphabetname || variant.patchname || variant.name || String(variant.variant_id),
        variantId: variantIdNum
      });
    }
  });

  return { symbol, totalPrice: productPrice, selected };
}

/** ============== ADD TO CART (after image ready) ============== **/
async function addToCartWithImage(sessionId, s3Url) {
  const sizeVariants = document.querySelector('input[name="size_variants_data"]')?.value || '';
  const messageData  = document.querySelector('textarea[name="messagefield"]')?.value || '';
  const variantIDRaw = document.querySelector('input[name="selective_variant_ID"]')?.value || '';
  const variantID    = Number(variantIDRaw);
  if (!Number.isFinite(variantID)) throw new Error('Invalid parent variantID');

  const { symbol, totalPrice, selected } = collectPatchSelectionsAndPrice();
  $('input[name="customized_price"]').val(symbol + totalPrice);

  const now = Date.now().toString();
  const parentProps = {
    "Product Name": product.title,
    _customized_image_url_front: s3Url || 'pending',
    _customized_image_url_back:  s3Url || 'pending',
    _size: sizeVariants,
    _info: messageData,
    _patches_price: symbol + totalPrice,
    _Session: sessionId,
    _Parent: '1',
    _Timestamp: now
  };

  const items = [{ id: variantID, quantity: 1, properties: parentProps }];

  // children
  for (const sel of selected) {
    if (!Number.isFinite(sel.variantId)) continue;
    items.push({
      id: sel.variantId,
      quantity: 1,
      properties: {
        name: 'Custom Product',
        _parent_variant: variantID,
        _Session: sessionId,
        _ChildOf: '1',
        _Unique: `${sel.id}_${now}`,
        _Timestamp: now
      }
    });
  }

  const r = await fetch(`${window.Shopify?.routes?.root || '/'}cart/add.js`, {
    method: 'POST',
    headers: {'Content-Type': 'application/json'},
    body: JSON.stringify({ items })
  });
  if (!r.ok) throw new Error('add.js failed');

  // capture parent key (optional; handy for future updates)
  let parentKey = null;
  try {
    const resp = await r.clone().json();
    if (resp?.items?.length) {
      const addedParent = resp.items.find(it => it?.properties?._Session === sessionId && it?.properties?._Parent === '1');
      parentKey = addedParent?.key || null;
    } else if (resp?.key) {
      parentKey = resp.key;
    }
  } catch (_) {}

  if (!parentKey) {
    const cart = await getCart();
    const parent = cart.items.find(i => i.properties && i.properties._Session === sessionId && i.properties._Parent === '1');
    parentKey = parent?.key || null;
  }

  if (parentKey) PARENT_PROPS.set(parentKey, parentProps);

  console.log('[1] Products added to cart (with image) successfully');
  localStorage.setItem('latestSessionId', sessionId);
  renderCart();
  return { parentKey };
}

/** ============== OPTIONAL FEE CLEANUP ============== **/
async function maybeRemoveStitchingFee() {
  try {
    const cart = await getCart();
    const hasEmbroideryProduct = cart.items.some(i => i.properties && i.properties._embroideryProduct === 'Embroidery Product');
    if (!hasEmbroideryProduct) {
      const fee = cart.items.find(i => i.variant_id === 42085140430950);
      if (fee) {
        await fetch('/cart/change.js', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ id: fee.key, quantity: 0 })
        });
      }
    }
  } catch (_) {}
}

/** ============== BUTTON WIRING ============== **/
document.addEventListener('DOMContentLoaded', function () {
  const addBtn  = document.querySelector('.add-item');
  const loader  = document.querySelector('.loader-cart');
  const spanDiv = document.querySelector('.span-content');

  // Warm up cart
  setTimeout(() => { fetch('/cart.js', { cache: 'no-store' }).catch(()=>{}); }, 0);

  if (!addBtn) return;

  addBtn.addEventListener('click', async function () {
    if ($('.overlapping-error').css('visibility') === 'visible') {
      $('.overlapping-correction-error').css('display', 'block');
      return;
    }

    if (loader) loader.style.display = 'block';
    if (spanDiv) spanDiv.style.display = 'none';
    addBtn.style.pointerEvents = 'none';
    addBtn.style.backgroundColor = 'rgb(190 190 190)';

    // lock UI while building image
    document.querySelectorAll('.patch').forEach(el => {
     // el.classList.remove('patch');
      el.classList.add('patch-not-allowed');
      el.setAttribute('draggable', 'false');
    });

    const sessionId = SESSION_TOKEN();
const isUpdate = $('.span-content').text().trim() === 'Update';
const cartKey = localStorage.getItem('editCartKey');

if (isUpdate && cartKey) {
  try {
    if (loader) loader.style.display = 'block';
    if (spanDiv) spanDiv.style.display = 'none';
    addBtn.style.pointerEvents = 'none';
    addBtn.style.backgroundColor = 'rgb(190 190 190)';

    console.log('[UPDATE] Starting update for key:', cartKey);

    const cart = await getCart();
    const parentItem = cart.items.find(i => i.key === cartKey);
    if (!parentItem) throw new Error('Parent item not found');

    const oldTimestamp = parentItem.properties?._Timestamp;
    const session = parentItem.properties?._Session;
    const now = Date.now().toString();

    // 1ï¸âƒ£ First compose new image
    const { blob } = await composeFrontBackAndExport({
      jpegQuality: 0.85,
      maxWidth: 1200
    });

    // 2ï¸âƒ£ Upload image
    const s3Url = await uploadBlobToS3(blob);
    console.log('[UPDATE] S3 URL:', s3Url);
const { symbol, totalPrice, selected } = collectPatchSelectionsAndPrice();
const sizeVariants = document.querySelector('input[name="size_variants_data"]')?.value || '';
const messageData  = document.querySelector('textarea[name="messagefield"]')?.value || '';

    // 3ï¸âƒ£ Update parent FIRST (important)
  const updatedProps = {
  "Product Name": product.title,
  _customized_image_url_front: s3Url,
  _customized_image_url_back: s3Url,
  _size: sizeVariants,
  _info: messageData,
  _patches_price: String(totalPrice),   // NOW WORKS
  _Session: session,
  _Parent: '1',
  _Timestamp: now,
  _UpdatedAt: now
};

    console.log("ðŸ”¥ Updating parent with props:", updatedProps);

await updateLineItemPropsByKey(cartKey, updatedProps);

    console.log("[UPDATE] Parent updated. Now removing childrenâ€¦");

    // 4ï¸âƒ£ Now remove OLD children
    await removeParentAndChildren(oldTimestamp, false);

    console.log("[UPDATE] Old children removed. Adding new childrenâ€¦");

    // 5ï¸âƒ£ Add new children
    const variantID = parentItem.variant_id;
    for (const sel of selected) {
      await fetch('/cart/add.js', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          items: [
            {
              id: sel.variantId,
              quantity: 1,
              properties: {
                name: 'Custom Product',
                _parent_variant: variantID,
                _Session: session,
                _ChildOf: '1',
                _Unique: `${sel.id}_${now}`,
                _Timestamp: now
              }
            }
          ]
        })
      });
    }

    console.log('[UPDATE] All children added successfully');

    $('.span-content').text('Add to bag');
    localStorage.removeItem('editCartKey');
    localStorage.setItem('latestSessionId', session);

    await renderCart();

  } catch (err) {
    console.error('âŒ UPDATE ERROR:', err);
  } finally {
    if (loader) loader.style.display = 'none';
    if (spanDiv) spanDiv.style.display = 'block';
    addBtn.style.pointerEvents = 'auto';
    addBtn.style.backgroundColor = '';
  }

  return;
}



    try {
      // 1) Compose the image(s)
      const { blob } = await composeFrontBackAndExport({
        jpegQuality: 0.85,
        maxWidth: 1200
      });

      // 2) Upload to S3
      const s3Url = await uploadBlobToS3(blob);
      console.log('[S3] Uploaded and ready. URL:', s3Url);

      // 3) Add items to cart with the image URL already set
      await addToCartWithImage(sessionId, s3Url);

      // 4) Optional clean-up (same as before)
      await maybeRemoveStitchingFee();

    } catch (err) {
      const outDiv = document.getElementById('Out-of-stock-error');
      if (outDiv) {
        outDiv.style.display = 'block';
        outDiv.style.visibility = 'visible';
        outDiv.textContent = 'Error adding to cart';
        setTimeout(() => { outDiv.style.display = 'none'; outDiv.style.visibility = 'hidden'; }, 5000);
      }
      console.error('Add to cart (after image) failed:', err);
    } finally {
      // restore button UI
      if (loader) loader.style.display = 'none';
      if (spanDiv) spanDiv.style.display = 'block';
      addBtn.style.pointerEvents = 'auto';
      addBtn.style.opacity = '1';
      addBtn.style.backgroundColor = '';
         document.querySelectorAll('.patch').forEach(el => {
     // el.classList.remove('patch');
      el.classList.remove('patch-not-allowed');
      el.removeAttribute('draggable');
    });
    }
  });
});
</script>

<script>
    const addCartButton = document.querySelector('.add-item');
    document.addEventListener('DOMContentLoaded', function () {

        let Patchesdata; // Define Patchesdata outside the function

        // Fetch Patchesdata from the API endpoint
        fetch(`https://lolaandtheboys.com/apps/data-pickup`)
            .then(response => {
                if (!response.ok) {
                    throw new Error('Network response was not ok');
                }
                return response.json();
            })
            .then(data => {
                // Assign the fetched data to Patchesdata
                Patchesdata = data;
            })
            .catch(error => {
                console.error('Error fetching data:', error);
            });

  $('.fotter-Summary-button').click(function () {
   
      $('.toggle-summary-svg').toggleClass('toggle-summary-svg-active');
        const variants = [];
        // let totalPrice = 0; // Initialize total price
        let productactualPrice = '{{ product.price }}';
        let productPrice = parseFloat(productactualPrice.slice(0, -2));
        // Get all div elements with the class "patch-"
        const patchDivs = document.querySelectorAll('.patch-');
        var currencyFormat = document.getElementById('currency-format').dataset.moneyFormat;
        var amountPlaceholder = currencyFormat.match(/\{\{amount\}\}/)[0];
        var currencySymbol = currencyFormat.replace(amountPlaceholder, '');
    
        const variantPrice = currencySymbol.trim() + productPrice;
            // If a variant with the corresponding v-id is found, push its ID and name to the variants array
             variants.unshift({ id: '1', name: '{{ product.title }}', price: variantPrice });
    
        // Loop through each patch div
        patchDivs.forEach(patch => {
            // Get the variant ID from the v-id attribute
            const vId = patch.getAttribute('v-id');
            const Id = patch.getAttribute('id');

            const alphabets = Patchesdata.alphabets;
            const patches = Patchesdata.patches;
            // Find the corresponding variant object in Patchesdata
            const alphabetVariant = alphabets.find(item => item.id.toString() === vId);
            const patchVariant = patches.find(item => item.id.toString() === vId);

            // Merge the properties of both variant objects into a single object
            const variant = { ...alphabetVariant, ...patchVariant };

             

            

            if (variant) {
                const price = parseFloat(variant.price);
                const formattedPrice = currencySymbol.trim() + price.toFixed(0);
                variants.push({
                    id: Id,
                    name: variant.alphabetname || variant.patchname,
                    price: formattedPrice
                });
                
                // Add the formatted price to the total price
                productPrice +=  price;
            }

        });

        let variantsHTML = "";
        variantsHTML += `
  <div class="summary-cross-btn-contiue-summary-patches">
    <svg width="16" height="16" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg">
      <path d="M9.09809 8L16 14.9019L14.9019 16L8 9.0981L1.0981 16L0 14.9019L6.9019 8L0 1.0981L1.0981 0L8 6.90191L14.9019 0L16 1.0981L9.09809 8Z" fill="#2C272D"></path>
    </svg>
  </div>
`;
        variants.forEach(variant => {
            variantsHTML += `
            <div class="customization-patch-product-information">
                <div class="customization-patch-product-name">${variant.name}</div> <div class="customization-patch-product-name">${variant.price}</div></div>`;
        });

        variantsHTML += `<div class="total-price"><span>Subtotal</span> <span>${currencySymbol.trim()}${productPrice}</span></div>`;
    
        // Update the content of the variants container
        $('.variants-container').html(variantsHTML);

        // Toggle visibility of the variants container with animation
       $('.variants-container').toggleClass('variants-container-open');
       $('.complete-overly-wrapper').toggleClass('complete-overly-wrapper-active');
       $('.complete-overly-wrapper').toggleClass('complete-overly-wrapper-active');
       $('.complete-overly-wrapper').toggleClass('complete-overly-wrapper-active');
    });

    $(document).on('click', '.summary-cross-btn-contiue-summary-patches', function() {
    $('.variants-container').toggleClass('variants-container-open');
    $('.complete-overly-wrapper').toggleClass('complete-overly-wrapper-active');
    $('.complete-overly-wrapper').toggleClass('complete-overly-wrapper-active');
    $('.complete-overly-wrapper').toggleClass('complete-overly-wrapper-active');
});
});


</script>

<script>
document.addEventListener('DOMContentLoaded', async function () {
  const wrapper = document.querySelector('.custom-cart-drawer-for-app-main-wrapper');
  const counterDiv = document.querySelector('.custom_cart_item_counter');
  const totalPriceDiv = document.querySelector('.custom_cart_item_price');

  if (!wrapper) return;

  async function getCart() {
    const res = await fetch('/cart.js');
    if (!res.ok) throw new Error('Failed to fetch cart');
    return res.json();
  }

  async function renderCart() {
   
    console.log('wrapper',wrapper);
     if (window.innerWidth <= 900) {
    // Hide elements
    document.querySelectorAll('.patches-customization-container, .patches-full-screen-icon').forEach(el => {
      el.style.display = 'none';
    });

    // Apply CSS to the offcanvas menu
    const offcanvasMenu = document.getElementById('patches-customization-offcanvas-menu');
    if (offcanvasMenu) {
     offcanvasMenu.style.setProperty('height', '100%', 'important');
  offcanvasMenu.style.setProperty('min-height', '100vw', 'important');
    }
  }
    wrapper.innerHTML = '<p class="loading"></p>';
    
    // Hide the patch editor
    const editor = document.querySelector('.patches-editor-wrapper');
    if (editor) editor.style.display = 'none';

    // Show the overlay
    const overlay = document.querySelector('.patches-customization-container-overly');
    if (overlay) {
      overlay.style.display = 'block';
      overlay.style.opacity = '0';
      overlay.style.transition = 'opacity 0.3s ease';
      requestAnimationFrame(() => (overlay.style.opacity = '1'));
    }

    // Slide in the cart drawer
    const drawer = document.querySelector('.custom-cart-drawer-for-app');
    if (drawer) {
      drawer.style.display = 'block';
      drawer.style.position = 'absolute';
      drawer.style.top = '0';
      drawer.style.right = '0';
      drawer.style.height = '100%';
      drawer.style.width = '100%';
      drawer.style.background = 'white';
      drawer.style.boxShadow = '-3px 0 8px rgba(0, 0, 0, 0.2)';
      drawer.style.transform = 'translateX(100%)';
      drawer.style.transition = 'transform 0.4s ease';
      requestAnimationFrame(() => (drawer.style.transform = 'translateX(0)'));
    }

     try {
  const cart = await getCart();
  const items = cart.items || [];

  /* âœ… Hide Stitching Fee (child fee product) */
  const visibleItems = items.filter((i) => {
    const p = i.properties || {};
    const isStitchingFee =
      p._Product === "Stitching Fee" ||
      (i.handle && i.handle === "stitching-fee") ||
      (i.product_title && i.product_title.toLowerCase() === "stitching fee") ||
      (i.title && i.title.toLowerCase() === "stitching fee");

    return !isStitchingFee;
  });

  // Separate parents and children (from visible items only)
  const parentItems = visibleItems.filter(
    (i) => !i.properties || (!i.properties._ChildOf && !i.properties._parent_variant)
  );
  const childItems = visibleItems.filter(
    (i) => i.properties && (i.properties._ChildOf || i.properties._parent_variant)
  );

  // Totals (count excludes stitching fee, price stays Shopify total like before)
  const totalCount = visibleItems.length;
  const totalPrice = cart.total_price;
  const formattedTotal = Shopify.formatMoney(totalPrice, "{{ shop.money_format }}");

  if (counterDiv)
    counterDiv.textContent = `Subtotal (${totalCount} item${totalCount !== 1 ? 's' : ''})`;
  if (totalPriceDiv)
    totalPriceDiv.textContent = formattedTotal;

  // Empty state
  if (parentItems.length === 0) {
    wrapper.innerHTML = '<p class="empty-msg">Your cart is empty.</p>';
    return;
  }

  let html = '';

  // ðŸ”¹ Build item HTML (with child total merged)
  parentItems.forEach((parent) => {
    const props = parent.properties || {};
    const isCustomizedParent =
      props._Parent === '1' || props._customized_image_url_front;

    // Find child items linked to this parent
    const relatedChildren = childItems.filter(
      (child) =>
        child.properties &&
        (child.properties._parent_variant == parent.variant_id ||
          child.properties._ChildOf === '1') &&
        child.properties._Session === props._Session
    );

    // Calculate combined total (parent + its children)
    const parentTotal =
      parent.final_line_price +
      relatedChildren.reduce((sum, c) => sum + c.final_line_price, 0);

    const img =
      props._customized_image_url_front ||
      parent.image ||
      "{{ 'no-image.png' | asset_url }}";

    const title = parent.title || 'Untitled Product';
    const price = Shopify.formatMoney(parentTotal, "{{ shop.money_format }}");
    const id = parent.key;

    const latestSessionId = localStorage.getItem('latestSessionId');
    const isLatestProduct =
      isCustomizedParent && props._Session && props._Session === latestSessionId;

    const buttonsHTML = isCustomizedParent
      ? `
        ${isLatestProduct ? `<div class="custom-cart-app-edit-btn" data-key="${id}" data-session="${props._Session}">Edit</div>` : ''}
        <div class="custom-cart-app-remove-btn" data-key="${id}">Remove</div>
        <div class="custom-cart-app-make-another-btn">Create Another</div>
      `
      : `
        <div class="custom-cart-app-remove-btn" data-key="${id}">Remove</div>
      `;

    html += `
      <div class="custom-cart-item" data-key="${id}">
        <div class="custom-cart-item-img">
          <img src="${img}" alt="${title}" loading="lazy">
        </div>
        <div class="custom-cart-item-info">
          <div class="custom-cart-app-product-title">${title}</div>
          <p class="custom-cart-app-custom-price">${price}</p>
          <div class="custom-cart-app-custom-cart-actions">
            ${buttonsHTML}
          </div>
        </div>
      </div>
    `;
  });

  localStorage.removeItem('latestSessionId');
  wrapper.innerHTML = html;
  bindCartButtons();
} } catch (err) {
      console.error(err);
      wrapper.innerHTML = '<p class="error-msg">Failed to load cart.</p>';
    }
  }


  // Remove item
async function removeItem(key) {
  try {
    const cart = await getCart();
    const parent = cart.items.find(i => i.key === key);
    if (parent?.properties?._Timestamp || parent?.properties?._Session) {
      await removeParentAndChildren(parent.properties._Timestamp || parent.properties._Session);
    } else {
      // fallback â€“ normal remove
      await fetch('/cart/change.js', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ id: key, quantity: 0 }),
      });
    }

    await renderCart();
  } catch (err) {
    console.error('Failed to remove item:', err);
  }
}


  // Button bindings
 function bindCartButtons() {
  // Re-attach remove button functionality
  document.querySelectorAll('.custom-cart-app-remove-btn').forEach((btn) => {
    btn.removeEventListener('click', handleRemoveButtonClick); // Avoid multiple bindings
    btn.addEventListener('click', handleRemoveButtonClick); // Attach handler
  });

  document.querySelectorAll('.custom-cart-app-make-another-btn').forEach((btn) => {
    btn.removeEventListener('click', handleMakeAnotherButtonClick); // Avoid multiple bindings
    btn.addEventListener('click', handleMakeAnotherButtonClick);
  });
}

// Handle removing items from cart
async function handleRemoveButtonClick(e) {
    const wrapperMain = document.querySelector('.custom-cart-drawer-for-app-main-wrapper'); 
  if (wrapperMain) {
    wrapper.innerHTML = '<p class="loading"></p>';
  }
  const key = e.target.dataset.key;
  const cart = await getCart();
  const itemToRemove = cart.items.find(i => i.key === key);
  
  if (itemToRemove?.properties?._Session || itemToRemove?.properties?._Timestamp) {
    // If it's a parent or a child linked by session/timestamp, remove both
    await removeParentAndChildren(itemToRemove.properties._Session || itemToRemove.properties._Timestamp);
  } else {
    // Fallback to normal removal
    await fetch('/cart/change.js', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ id: key, quantity: 0 }),
    });
  }

  await renderCart();
}

// Handle creating another product (reloading)
function handleMakeAnotherButtonClick() {
  location.reload();
}


  // Expose globally
  window.renderCart = renderCart;
  //renderCart();
});

// Close handler
document.addEventListener('click', function (e) {
  const closeBtn = e.target.closest('.custom-cart-drawer-for-app-close');
  if (!closeBtn) return;
        document.querySelectorAll('.patch').forEach(el => {
     // el.classList.remove('patch');
      el.classList.remove('patch-not-allowed');
      el.setAttribute('draggable','true');
    });
if (window.innerWidth <= 900) {
    // Hide elements
    document.querySelectorAll('.patches-customization-container, .patches-full-screen-icon').forEach(el => {
      el.style.display = 'block';
    });

    // Apply CSS to the offcanvas menu
    const offcanvasMenu = document.getElementById('patches-customization-offcanvas-menu');
    if (offcanvasMenu) {
     offcanvasMenu.style.setProperty('height', 'calc(100% - 100vw)', 'important');
  offcanvasMenu.style.setProperty('min-height', '50vw', 'important');
    }
  }
  const editor = document.querySelector('.patches-editor-wrapper');
  if (editor) editor.style.display = 'block';

  const overlay = document.querySelector('.patches-customization-container-overly');
  if (overlay) {
    overlay.style.opacity = '1';
    overlay.style.transition = 'opacity 0.3s ease';
    overlay.style.opacity = '0';
    setTimeout(() => (overlay.style.display = 'none'), 300);
  }

  const drawer = document.querySelector('.custom-cart-drawer-for-app');
  if (drawer) {
    drawer.style.transition = 'transform 0.4s ease';
    drawer.style.transform = 'translateX(100%)';
    setTimeout(() => {
      drawer.style.display = 'none';
      drawer.style.transform = '';
    }, 400);
  }
 // $('.span-content').text('Update');
});

document.addEventListener('click', function (e) {
const editBtn = e.target.closest('.custom-cart-app-edit-btn');
  if (!editBtn) return;
         document.querySelectorAll('.patch').forEach(el => {
     // el.classList.remove('patch');
      el.classList.remove('patch-not-allowed');
      el.setAttribute('draggable','true');
    });
if (window.innerWidth <= 900) {
    // Hide elements
    document.querySelectorAll('.patches-customization-container, .patches-full-screen-icon').forEach(el => {
      el.style.display = 'block';
    });

    // Apply CSS to the offcanvas menu
    const offcanvasMenu = document.getElementById('patches-customization-offcanvas-menu');
    if (offcanvasMenu) {
     offcanvasMenu.style.setProperty('height', 'calc(100% - 100vw)', 'important');
  offcanvasMenu.style.setProperty('min-height', '50vw', 'important');
    }
  }
   const cartKey = editBtn.dataset.key;
  localStorage.setItem('editCartKey', cartKey); // store key for later update

  const editor = document.querySelector('.patches-editor-wrapper');
  if (editor) editor.style.display = 'block';

  const overlay = document.querySelector('.patches-customization-container-overly');
  if (overlay) {
    overlay.style.opacity = '1';
    overlay.style.transition = 'opacity 0.3s ease';
    overlay.style.opacity = '0';
    setTimeout(() => (overlay.style.display = 'none'), 300);
  }

  const drawer = document.querySelector('.custom-cart-drawer-for-app');
  if (drawer) {
    drawer.style.transition = 'transform 0.4s ease';
    drawer.style.transform = 'translateX(100%)';
    setTimeout(() => {
      drawer.style.display = 'none';
      drawer.style.transform = '';
    }, 400);
  }
  //$('.span-content').text('Update');
});

</script>

<script>
  $('.filter_all_categories_button_wrapp').on('click', function () {
    // Get all active checkboxes and their data-toggle-filter values
    const selectedCategories = $('.active_checkBox_category')
        .map(function () {
            return $(this).data('toggle-filter');  // or $(this).attr('data-toggle-filter')
        })
        .get()
        .filter(Boolean); // remove null/undefined/empty

    console.log('Selected categories:', selectedCategories);

    // Call your filter function with these categories
    filterPatches(selectedCategories);
    $('.filter_customization_wrapper_show_all_filter_dropdowns').hide();
});

</script>