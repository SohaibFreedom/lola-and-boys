{% assign variant = product.selected_or_first_available_variant %}
<!--
  {{ variant.price | money }}
  {{ variant.id }}
-->
<!-- {{ variant | json}} -->

<style>
  .patch-not-allowed{
    height: 70px;
    width: 70px;
    display: flex;
    align-items: center;
    justify-content: center;
    border: 1px solid transparent;
    position: relative;
    flex-direction: column;
  }
  .span-content{
    font-size: 20px !important;
    text-transform: uppercase;
  }
    .variants-container {
      display: none;
      position: absolute;
      bottom: 61px;
      color: #747474;
      font-weight: 500;
      left: 0;
      width: 100%;
      background-color: white;
      animation: slide-up 0.5s ease forwards;
      padding: 29px 23px;
      border-top-left-radius: 25px;
      border-top-right-radius: 25px;
      background: rgb(255 255 255);
  }

  @keyframes slide-up {
      from {
          transform: translateY(100%);
      }
      to {
          transform: translateY(0);
      }
  }
  .patch-customization-offcanvas-form{
    position:relative;
  }
  .patch-customizaton-foter{
    bottom: 0;
    padding: 20px 40px;
    border-top: 1px solid #dddddd;
    width: 35%;
    position: fixed;
    background: #ffffff;
  }
  .patches-customization-form-buttons{
    display: flex;
    width: 100%;
    position: relative;
  }
  .fotter-Summary-button{
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight:600;
    gap: 10px;
    padding: 12px 36px;
    background: #f8f8f8;
    color: black;
    border-top-left-radius: 20px;
    border-bottom-left-radius: 20px;
    cursor:pointer;
    width: 40%;
  }
  .fotter-Summary-button > span {
    font-size: 17px;
  }
  .add-item{
    font-weight:600;
    padding: 12px;
    display: flex;
    align-items: center;
    justify-content: center;
    background: #ffe2e8;
    border-top-right-radius: 20px;
    border-bottom-right-radius: 20px;
    width: 60%;
    cursor: pointer;
  }
  .total-price{
    border-top: 1px solid #dddddd;
    margin-top: 20px;
    padding-top: 12px;
    display:flex;
    justify-content:space-between;
  }
  .customization-patch-product-information{
    display:flex;
    justify-content:space-between;
  }
  .loader-cart {
            border: 2px solid #f3f3f3; /* Light grey */
            border-top: 2px solid #ff5477; /* Blue */
            border-radius: 50%;
            width: 25px;
            height: 25px;
            animation: spin 2s linear infinite;
            display:none;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
  .loader-cart-contiune {
            border: 2px solid #f3f3f3; /* Light grey */
            border-top: 2px solid #ff5477; /* Blue */
            border-radius: 50%;
            width: 25px;
            height: 25px;
            animation: spin2 2s linear infinite;
            display:none;
        }

        @keyframes spin2 {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
  @media screen and (max-width: 1024px){
     .span-content {
    font-size: 17px !important;
    }
  }
  @media screen and (max-width: 376px){
    .span-content {
    font-size: 17px !important;
    }
  }
</style>

<div id="currency-format" data-money-format="{{ shop.money_format }}"></div>

<input type="hidden" name="customized_image_url_front" value="">
<input type="hidden" name="customized_image_url_back" value="">
<input type="hidden" name="customized_price" value="">
<input type="hidden" name="size_variants_data" id="size_variants_data" value="">
<input type="hidden" name="selective_variant_ID" id="selective_variant_ID" value="">
<input type="hidden" name="selective_variant_name" id="selective_variant_name" value="">
<div
  class="overlapping-correction-error"
  style=""
>
  Please correct overlapping error first
</div>
 <div class="overlapping-correction-error" id="Out-of-stock-error"></div>
<div class="patch-customization-btn-wrap">
  <div class="complete-overly-wrapper"></div>
  <div id="variantsContainer" class="variants-container"></div>
  <div class="patches-customization-form-buttons">
    <div class="fotter-Summary-button">
      <span>Summary</span>
      <svg
        width="8"
        height="14"
        viewBox="0 0 8 14"
        fill="none"
        xmlns="http://www.w3.org/2000/svg"
        class="patches-arrow-top toggle-summary-svg toggle-summary-svg-active"
      >
        <path d="M7 13L1 7" stroke="currentColor" stroke-width="2" stroke-linecap="round"></path><path d="M1 7.00002L6.99994 1.00002" stroke="currentColor" stroke-width="2" stroke-linecap="round" ></path>
      </svg>
      <svg
        width="8"
        height="14"
        viewBox="0 0 8 14"
        fill="none"
        xmlns="http://www.w3.org/2000/svg"
        class="patches-arrow-left toggle-summary-svg"
      >
        <path d="M7 13L1 7" stroke="currentColor" stroke-width="2" stroke-linecap="round"></path><path d="M1 7.00002L6.99994 1.00002" stroke="currentColor" stroke-width="2" stroke-linecap="round" ></path>
      </svg>
    </div>
    <div class="add-item">
      <span class="span-content">Add to bag</span>
      <div class="loader-cart"></div>
    </div>
  </div>
</div>

<script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.3.2/html2canvas.min.js"></script>
<script>
    const addCartButton = document.querySelector('.add-item');
    document.addEventListener('DOMContentLoaded', function () {

        // async function addToCart(variants, customizedImageUrl, customizedPrice,sizeVariants,messagaeData,customizedBackImageUrl) {
        //     try {
        //         // Prepare data for adding to cart
        //         const items = variants.map(variant => {
        //             const item = {
        //                 id: variant.name,
        //                 image: customizedImageUrl,
        //                 quantity: 1
        //             };

        //             // Define properties based on variant ID
        //             if (variant.name === '{{ variant.id }}') {
        //                 item.properties = {
        //                     "Product Name": '{{ product.title }}',
        //                     _customized_image_url_front: customizedImageUrl,
        //                     _customized_image_url_back:customizedBackImageUrl,
        //                     _size:sizeVariants,
        //                     _info:messagaeData,
        //                     _patches_price: customizedPrice,
        //                    _Timestamp: Date.now().toString()
        //                 };
        //             } else {
        //                 item.properties = {
        //                     name: 'Custom Product',
        //                     _parent_variant: '{{ variant.id }}',
        //                     _Timestamp: Date.now().toString(),
        //                     _Unique: `${variant.id}_${Date.now()}`
        //                 };
        //             }
        //             return item;
        //         });

        //         const formData = { items };

        //         const response = await fetch(window.Shopify.routes.root + 'cart/add.js', {
        //             method: 'POST',
        //             headers: {
        //                 'Content-Type': 'application/json'
        //             },
        //             body: JSON.stringify(formData)
        //         });

        //         return await response.json();
        //     } catch (error) {
        //         console.error('Error adding items to cart:', error);
        //         throw error; // Re-throw the error for further handling
        //     }
        // }

        let Patchesdata; // Define Patchesdata outside the function

        // Fetch Patchesdata from the API endpoint
        fetch(`https://lolaandtheboys.com/apps/data-pickup`)
            .then(response => {
                if (!response.ok) {
                    throw new Error('Network response was not ok');
                }
                return response.json();
            })
            .then(data => {
                // Assign the fetched data to Patchesdata
                Patchesdata = data;
            })
            .catch(error => {
                console.error('Error fetching data:', error);
            });

  $('.fotter-Summary-button').click(function () {
   
      $('.toggle-summary-svg').toggleClass('toggle-summary-svg-active');
const container = $('.complete-overly-wrapper');
  if (!container.is(':visible')) {
        container.css('display', 'block');
    } else {
        container.css('display', 'none');
    }
        const variants = [];
        // let totalPrice = 0; // Initialize total price
        let productactualPrice = '{{ product.price }}';
        let productPrice = parseFloat(productactualPrice.slice(0, -2));
        // Get all div elements with the class "patch-"
        const patchDivs = document.querySelectorAll('.patch-');
        var currencyFormat = document.getElementById('currency-format').dataset.moneyFormat;
        var amountPlaceholder = currencyFormat.match(/\{\{amount\}\}/)[0];
        var currencySymbol = currencyFormat.replace(amountPlaceholder, '');
    
        const variantPrice = currencySymbol.trim() + productPrice;
            // If a variant with the corresponding v-id is found, push its ID and name to the variants array
             variants.unshift({ id: '1', name: '{{ product.title }}', price: variantPrice });
    
        // Loop through each patch div
        patchDivs.forEach(patch => {
            // Get the variant ID from the v-id attribute
            const vId = patch.getAttribute('v-id');
            const Id = patch.getAttribute('id');

            const alphabets = Patchesdata.alphabets;
            const patches = Patchesdata.patches;
            // Find the corresponding variant object in Patchesdata
            const alphabetVariant = alphabets.find(item => item.id.toString() === vId);
            const patchVariant = patches.find(item => item.id.toString() === vId);

            // Merge the properties of both variant objects into a single object
            const variant = { ...alphabetVariant, ...patchVariant };

             

            

            if (variant) {
                const price = parseFloat(variant.price);
                const formattedPrice = currencySymbol.trim() + price.toFixed(0);
                variants.push({
                    id: Id,
                    name: variant.alphabetname || variant.patchname,
                    price: formattedPrice
                });
                
                // Add the formatted price to the total price
                productPrice +=  price;
            }

        });

        let variantsHTML = "";
        variants.forEach(variant => {
            variantsHTML += `<div class="customization-patch-product-information">
                <div class="customization-patch-product-name">${variant.name}</div> <div class="customization-patch-product-name">${variant.price}</div></div>`;
        });

        variantsHTML += `<div class="total-price"><span>Total</span> <span>${currencySymbol.trim()}${productPrice}</span></div>`;

        // Update the content of the variants container
        $('.variants-container').html(variantsHTML);

        // Toggle visibility of the variants container with animation
        $('.variants-container').slideToggle();
    });

// function convertBothToPng() {
//   console.log('convertBothToPng')
//     let blobCounter = 0; // Counter to track the number of completed canvas.toBlob calls

//     // Function to handle conversion for either front or back image
//     function convertSingleToPng(isBack) {
//         var imageDiv = document.getElementById(isBack ? 'BackimageDiv' : 'imageDiv');
//         var patches = imageDiv.querySelectorAll('.patch- img');
//         var canvas = document.createElement('canvas');
//         var ctx = canvas.getContext('2d');

//         // Set canvas size to match the containing div's size
//         var imageDivRect = imageDiv.getBoundingClientRect();
//         canvas.width = imageDivRect.width;
//         canvas.height = imageDivRect.height;

//         // Draw the main image on the canvas with object-fit: contain
//         var sourceImage = document.getElementById(isBack ? 'Back-image' : 'Front-image');
//         if (!sourceImage) {
//             console.error('Source image not found');
//             return;
//         }

//         // Calculate dimensions and position based on object-fit: contain
//         var containerAspectRatio = canvas.width / canvas.height;
//         var imageAspectRatio = sourceImage.naturalWidth / sourceImage.naturalHeight;

//         var sourceWidth, sourceHeight, sourcePosX, sourcePosY;

//         if (containerAspectRatio > imageAspectRatio) {
//             // Container is wider than image
//             sourceWidth = canvas.height * imageAspectRatio;
//             sourceHeight = canvas.height;
//             sourcePosX = (canvas.width - sourceWidth) / 2;
//             sourcePosY = 0;
//         } else {
//             // Container is taller than image
//             sourceWidth = canvas.width;
//             sourceHeight = canvas.width / imageAspectRatio;
//             sourcePosX = 0;
//             sourcePosY = (canvas.height - sourceHeight) / 2;
//         }

//         ctx.drawImage(sourceImage, sourcePosX, sourcePosY, sourceWidth, sourceHeight);

//         // Draw patches on the canvas
//         patches.forEach(function (patch) {
//             var patchRect = patch.getBoundingClientRect();
//             var patchDivRect = patch.parentElement.getBoundingClientRect();
//             var patchPosX = patchDivRect.left - imageDivRect.left;
//             var patchPosY = patchDivRect.top - imageDivRect.top;

//             var patchWidth = patch.getAttribute('height');
//             var patchHeight = patch.getAttribute('width');
//             if (window.innerWidth <= 768) {
//                 var patcnaturalwidth = patch.getAttribute('height');
//                 var patchnaturalHeight = patch.getAttribute('width');
//                 patchWidth = patcnaturalwidth / 2 + 15;
//                 patchHeight = patchnaturalHeight / 2 + 15;
//             }

//             // Calculate dimensions and position based on object-fit: contain
//             var patchAspectRatio = patch.naturalWidth / patch.naturalHeight;

//             var drawWidth, drawHeight, drawPosX, drawPosY;

//             if (patchWidth / patchHeight > patchAspectRatio) {
//                 // Container is wider than patch
//                 drawWidth = patchHeight * patchAspectRatio;
//                 drawHeight = patchHeight;
//                 drawPosX = patchPosX + (patchWidth - drawWidth) / 2;
//                 drawPosY = patchPosY;
//             } else {
//                 // Container is taller than patch
//                 drawWidth = patchWidth;
//                 drawHeight = patchWidth / patchAspectRatio;
//                 drawPosX = patchPosX;
//                 drawPosY = patchPosY + (patchHeight - drawHeight) / 2;
//             }

//             // Get the rotation angle from the patch element's style
//             var rotation = 0;
//             var transform = patch.parentElement.style.transform;
//             if (transform) {
//                 var match = transform.match(/rotate\(([-\d.]+)deg\)/);
//                 if (match) {
//                     rotation = parseFloat(match[1]) * (Math.PI / 180); // Convert degrees to radians
//                 }
//             }

//             // Apply rotation and draw the patch
//             ctx.save();
//             ctx.translate(patchPosX + patchWidth / 2, patchPosY + patchHeight / 2); // Move to the center of the patch
//             ctx.rotate(rotation); // Rotate the canvas
//             ctx.drawImage(patch, -drawWidth / 2, -drawHeight / 2, drawWidth, drawHeight); // Draw the patch
//             ctx.restore();
//         });

//         // Convert canvas to Blob
//         canvas.toBlob(function (blob) {
         
                 
//             // Here, you have the image as a blob
//             // For example, to display the new blob image, convert blob to ObjectURL
//             var pngImageURL = URL.createObjectURL(blob);

//             // uploadBlob(pngImageURL, isBack ? 'input[name="customized_image_url_back"]' : 'input[name="customized_image_url_front"]');
      
            
//         }, 'image/png');
//     }

//     // Convert both front and back images
//     convertSingleToPng(true);  // Convert back image
//     convertSingleToPng(false); // Convert front image
// }







// // Call the function to convert both images
// // convertBothToPng();
// function  convertBothToPng() {
//   BackconvertToPng();
//   FrontconvertToPng();
// }
// function BackconvertToPng() {
//     var imageDiv = document.getElementById('BackimageDiv');
//     var patches = imageDiv.querySelectorAll('.patch- img');
//     var canvas = document.createElement('canvas');
//     var ctx = canvas.getContext('2d');

//     // Set canvas size to match the containing div's size
//     var imageDivRect = imageDiv.getBoundingClientRect();
//     canvas.width = imageDivRect.width;
//     canvas.height = imageDivRect.height;

//     // Draw the main image on the canvas with object-fit: contain
//     var sourceImage = document.getElementById('Back-image');
//     if (!sourceImage) {
//         console.error('Source image not found');
//         return;
//     }

//     // Calculate dimensions and position based on object-fit: contain
//     var containerAspectRatio = canvas.width / canvas.height;
//     var imageAspectRatio = sourceImage.naturalWidth / sourceImage.naturalHeight;

//     var sourceWidth, sourceHeight, sourcePosX, sourcePosY;

//     if (containerAspectRatio > imageAspectRatio) {
//         // Container is wider than image
//         sourceWidth = canvas.height * imageAspectRatio;
//         sourceHeight = canvas.height;
//         sourcePosX = (canvas.width - sourceWidth) / 2;
//         sourcePosY = 0;
//     } else {
//         // Container is taller than image
//         sourceWidth = canvas.width;
//         sourceHeight = canvas.width / imageAspectRatio;
//         sourcePosX = 0;
//         sourcePosY = (canvas.height - sourceHeight) / 2;
//     }

//     ctx.drawImage(sourceImage, sourcePosX, sourcePosY, sourceWidth, sourceHeight);

//     // Draw patches on the canvas
//     patches.forEach(function (patch) {
//         var patchRect = patch.getBoundingClientRect();
//         var patchDivRect = patch.parentElement.getBoundingClientRect();
//         var patchPosX = patchDivRect.left - imageDivRect.left;
//         var patchPosY = patchDivRect.top - imageDivRect.top;
//         var isMobile = window.innerWidth <= 768;
//         var isTablet = window.innerWidth > 768 && window.innerWidth <= 1024;

//        if (isMobile) {
//        var patcnaturalwidth = patch.getAttribute('height');
//        var patchnaturalHeight = patch.getAttribute('width');
//        var patchWidth = patcnaturalwidth / 2 - 3 ;
//        var patchHeight = patchnaturalHeight / 2 - 3;
//          console.log(patchWidth)
//        } 
//        else if (isTablet){
//        var patcnaturalwidth = patch.getAttribute('height');
//         var patchnaturalHeight = patch.getAttribute('width');
//        var patchWidth = patcnaturalwidth / 2 + 10 ;
//         var patchHeight = patchnaturalHeight / 2 + 10;
//          console.log(patchWidth)
//        }else{
//          var patchWidth = patch.getAttribute('height');
//         var patchHeight = patch.getAttribute('width');
//          console.log(patchWidth)
//        }
  
        
//         // Calculate dimensions and position based on object-fit: contain
//         var patchAspectRatio = patch.naturalWidth / patch.naturalHeight;

//         var drawWidth, drawHeight, drawPosX, drawPosY;

//         if (patchWidth / patchHeight > patchAspectRatio) {
//             // Container is wider than patch
//             drawWidth = patchHeight * patchAspectRatio;
//             drawHeight = patchHeight;
//             drawPosX = patchPosX + (patchWidth - drawWidth) / 2;
//             drawPosY = patchPosY;
//         } else {
//             // Container is taller than patch
//             drawWidth = patchWidth;
//             drawHeight = patchWidth / patchAspectRatio;
//             drawPosX = patchPosX;
//             drawPosY = patchPosY + (patchHeight - drawHeight) / 2;
//         }

//         // Get the rotation angle from the patch element's style
//         var rotation = 0;
//         var transform = patch.parentElement.style.transform;
//         if (transform) {
//             var match = transform.match(/rotate\(([-\d.]+)deg\)/);
//             if (match) {
//                 rotation = parseFloat(match[1]) * (Math.PI / 180); // Convert degrees to radians
//             }
//         }

//         // Apply rotation and draw the patch
//         ctx.save();
//         ctx.translate(patchPosX + patchWidth / 2, patchPosY + patchHeight / 2); // Move to the center of the patch
//         ctx.rotate(rotation); // Rotate the canvas
//         ctx.drawImage(patch, -drawWidth / 2, -drawHeight / 2, drawWidth, drawHeight); // Draw the patch
//         ctx.restore();
//     });

//     // Convert canvas to Blob
//     canvas.toBlob(function (blob) {
//         // Here, you have the image as a blob
//         // For example, to display the new blob image, convert blob to ObjectURL
//         var pngImageURL = URL.createObjectURL(blob);
//         var counter = 1;
//         uploadBlob(pngImageURL, 'input[name="customized_image_url_back"]', counter);

//         // Display the new image
//         var outputDiv = document.getElementById('BackoutputDiv');
//         var newImg = document.createElement('img');
//         newImg.src = pngImageURL;

//         outputDiv.innerHTML = ''; // Clear the output div before appending new image
//         outputDiv.appendChild(newImg);
//     }, 'image/png');
// }

// function FrontconvertToPng() {
//     var imageDiv = document.getElementById('imageDiv');
//     var patches = imageDiv.querySelectorAll('.patch- img');
//     var canvas = document.createElement('canvas');
//     var ctx = canvas.getContext('2d');

//     // Set canvas size to match the containing div's size
//     var imageDivRect = imageDiv.getBoundingClientRect();
//     canvas.width = imageDivRect.width;
//     canvas.height = imageDivRect.height;

//     // Draw the main image on the canvas with object-fit: contain
//     var sourceImage = document.getElementById('Front-image');
//     if (!sourceImage) {
//         console.error('Source image not found');
//         return;
//     }

//     // Calculate dimensions and position based on object-fit: contain
//     var containerAspectRatio = canvas.width / canvas.height;
//     var imageAspectRatio = sourceImage.naturalWidth / sourceImage.naturalHeight;

//     var sourceWidth, sourceHeight, sourcePosX, sourcePosY;

//     if (containerAspectRatio > imageAspectRatio) {
//         // Container is wider than image
//         sourceWidth = canvas.height * imageAspectRatio;
//         sourceHeight = canvas.height;
//         sourcePosX = (canvas.width - sourceWidth) / 2;
//         sourcePosY = 0;
//     } else {
//         // Container is taller than image
//         sourceWidth = canvas.width;
//         sourceHeight = canvas.width / imageAspectRatio;
//         sourcePosX = 0;
//         sourcePosY = (canvas.height - sourceHeight) / 2;
//     }

//     ctx.drawImage(sourceImage, sourcePosX, sourcePosY, sourceWidth, sourceHeight);

//     // Draw patches on the canvas
//     patches.forEach(function (patch) {
//         var patchRect = patch.getBoundingClientRect();
//         var patchDivRect = patch.parentElement.getBoundingClientRect();
//         var patchPosX = patchDivRect.left - imageDivRect.left;
//         var patchPosY = patchDivRect.top - imageDivRect.top;
//         var isMobile = window.innerWidth <= 768;
//         var isTablet = window.innerWidth > 768 && window.innerWidth <= 1024;

//        if (isMobile) {
//        var patcnaturalwidth = patch.getAttribute('height');
//        var patchnaturalHeight = patch.getAttribute('width');
//        var patchWidth = patcnaturalwidth / 2 - 3 ;
//        var patchHeight = patchnaturalHeight / 2 - 3;
//          console.log(patchWidth)
//        } 
//        else if (isTablet){
//        var patcnaturalwidth = patch.getAttribute('height');
//         var patchnaturalHeight = patch.getAttribute('width');
//        var patchWidth = patcnaturalwidth / 2 + 10 ;
//         var patchHeight = patchnaturalHeight / 2 + 10;
//          console.log(patchWidth)
//        }else{
//          var patchWidth = patch.getAttribute('height');
//         var patchHeight = patch.getAttribute('width');
//          console.log(patchWidth)
//        }
  

//         // Calculate dimensions and position based on object-fit: contain
//         var patchAspectRatio = patch.naturalWidth / patch.naturalHeight;

//         var drawWidth, drawHeight, drawPosX, drawPosY;

//         if (patchWidth / patchHeight > patchAspectRatio) {
//             // Container is wider than patch
//             drawWidth = patchHeight * patchAspectRatio;
//             drawHeight = patchHeight;
//             drawPosX = patchPosX + (patchWidth - drawWidth) / 2;
//             drawPosY = patchPosY;
//         } else {
//             // Container is taller than patch
//             drawWidth = patchWidth;
//             drawHeight = patchWidth / patchAspectRatio;
//             drawPosX = patchPosX;
//             drawPosY = patchPosY + (patchHeight - drawHeight) / 2;
//         }

//         // Get the rotation angle from the patch element's style
//         var rotation = 0;
//         var transform = patch.parentElement.style.transform;
//         console.log('transform',transform)
//         if (transform) {
//             var match = transform.match(/rotate\(([-\d.]+)deg\)/);
//            console.log('match',match)
//             if (match) {
//               console.log('matched')
//                 rotation = parseFloat(match[1]) * (Math.PI / 180); // Convert degrees to radians
//             }
//         }

//         // Apply rotation and draw the patch
//         ctx.save();
//         ctx.translate(patchPosX + patchWidth / 2, patchPosY + patchHeight / 2); // Move to the center of the patch
//         ctx.rotate(rotation); // Rotate the canvas
//         ctx.drawImage(patch, -drawWidth / 2, -drawHeight / 2, drawWidth, drawHeight); // Draw the patch
//         ctx.restore();
//     });

//     // Convert canvas to Blob
//     canvas.toBlob(function (blob) {
//         // Here, you have the image as a blob
//         // For example, to display the new blob image, convert blob to ObjectURL
//         var pngImageURL = URL.createObjectURL(blob);
//         var counter = 2;
//          uploadBlob(pngImageURL, 'input[name="customized_image_url_front"]',counter);

//         // Display the new image
//         var outputDiv = document.getElementById('outputDiv');
//         var newImg = document.createElement('img');
//         newImg.src = pngImageURL;

//         outputDiv.innerHTML = ''; // Clear the output div before appending new image
//         outputDiv.appendChild(newImg);
//     }, 'image/png');
// }


 const addCartItemButton = document.querySelector('.add-item');
 const loader = document.querySelector('.loader-cart');
 const spanDiv = document.querySelector('.span-content');
 const product = {{ product | json }};
addCartItemButton.addEventListener('click', async function (event) {
    const patchDivs = document.querySelectorAll('.patch');

    patchDivs.forEach(function (div) {
        div.classList.remove('patch');
        div.classList.add('patch-not-allowed');
        div.setAttribute('draggable', 'false');
    });

    if ($('.overlapping-error').css('visibility') === 'visible') {
        $('.overlapping-correction-error').css('display', 'block');
    } else {
        console.log('added');

        // Immediate style updates
        loader.style.display = 'block';
        spanDiv.style.display = 'none';
        addCartItemButton.style.pointerEvents = 'none';
        addCartItemButton.style.opacity = '0.5';
        addCartItemButton.style.backgroundColor = '#dfdfdf';

        // Force a reflow to apply styles
        loader.offsetHeight;

        // Perform UI updates in the next animation frame
        requestAnimationFrame(() => {
            $('.overlapping-correction-error').css('visibility', 'hidden');

            // Delay screenshot capture slightly to ensure UI updates are processed
            setTimeout(() => {
                captureAndCombineScreenshots();
            }, 10);
        });
    }
});



//  function loadCartSection(response) {
  
//             // Fetch the entire HTML page
//             $.get(window.location.href, function (data) {

//                 // Extract the content inside the #offcanvas-right element
//                 var offcanvasContent = $(data).find('#offcanvas-right').html();
//                 // Load the extracted content into the #offcanvas-right element
//                 $('#offcanvas-right').html(offcanvasContent);

//                 // Add class to .c-offcanvas--right if the cart is not empty
//                 const cartNotEmpty = response.items.length > 0;
//                 const offcanvasRight = document.querySelector('.c-offcanvas--right');
//                 if (cartNotEmpty) {
//                     offcanvasRight.classList.add('cart-drawer-open');
//                 } else {
//                     offcanvasRight.classList.remove('cart-drawer-open');
//                 }

//                 // Add class to .cart-drawer-overlay if the cart is not empty
//                 const cartDrawerOverlay = document.querySelector('.js-ajax-cart-set');
//                 if (cartNotEmpty) {
//                     cartDrawerOverlay.classList.add('cart-drawer-overlay');
//                 } else {
//                     cartDrawerOverlay.classList.remove('cart-drawer-overlay');
//                 }
//             });
    
// setTimeout(function() {
//     var addCartItemButton = document.querySelector('.add-item');
//    loader.style.display='none';
//     spanDiv.style.display='block';
//     addCartItemButton.style.pointerEvents = 'auto'; // Revert pointer-events to its default value
//     addCartItemButton.style.opacity = '1'; // Set opacity back to normal
//     addCartItemButton.style.backgroundColor = '#ffe2e8'; // Change background color
// }, 3000);
 
//     };
      
    });
</script>
<script>
  var allpathesDev = document.querySelectorAll('.patch-')
  console.log(allpathesDev)
</script>
<script>
 async function uploadBlob(pngImageURL, inputSelector,counter) {
  
  try {

    // Fetch the image URL
    const response = await fetch(pngImageURL);

    // Convert the fetched response to a blob
    const blob = await response.blob();

    // Use FormData to prepare the data for sending
    const formData = new FormData();
    formData.append('image', blob, 'screenshot.jpg');

    // Send the FormData to the server
    const result = await fetch('https://6ch1pxqng1.execute-api.ap-south-1.amazonaws.com/check', {
      method: 'POST',
      body: formData
    });

    // Assuming the server responds with JSON
    const jsonResponse = await result.json();
    console.log(jsonResponse);

    // Update the value of the input field with the file URL
    if (jsonResponse && jsonResponse.fileUrl) {
      document.querySelector(inputSelector).value = jsonResponse.fileUrl;
    } else {
      console.error('File URL not found in the response');
    }

    // Increment the counter and check condition
  addcartfiles();

  } catch (error) {
    console.error('Error uploading blob:', error);
  }
}


async function addcartfiles() {
    let Patchesdata; // Define Patchesdata outside the function

    // Fetch Patchesdata from the API endpoint
    try {
        const response = await fetch(`https://lolaandtheboys.com/apps/data-pickup`);
        if (!response.ok) {
            throw new Error('Network response was not ok');
        }
        const data = await response.json();
        console.log(data);
        // Assign the fetched data to Patchesdata
        Patchesdata = data;
    } catch (error) {
        console.error('Error fetching data:', error);
        return; // Exit the function if fetching fails
    }

    // Patchesdata is now available
    console.log('Patchesdata', Patchesdata);

    console.log('addcartfiles');
    const variantPrice = [];
    let productPrice = '{{ variant.price }}';
    console.log('this is product price', productPrice);
    let totalPrice = parseFloat(productPrice.slice(0, -2));

    const patchDivsPrice = document.querySelectorAll('.patch-');
    patchDivsPrice.forEach(patch => {
      const vId = patch.getAttribute('v-id');
      const Id = patch.getAttribute('id');
      const alphabets = Patchesdata.alphabets;
      const patches = Patchesdata.patches;

      const alphabetVariant = alphabets.find(item => item.id.toString() === vId);
      const patchVariant = patches.find(item => item.id.toString() === vId);

      const variant = { ...alphabetVariant, ...patchVariant };

      if (variant) {
        const price = parseFloat(variant.price);
        if (!isNaN(price)) { // Check if price is a valid number
          totalPrice += price;
        } else {
          console.error(`Invalid price for variant with v-id ${vId}`);
        }
      } else {
        console.error(`Variant not found for v-id ${vId}`);
      }
    });

    var currencyFormat = document.getElementById('currency-format').dataset.moneyFormat;
    var amountPlaceholder = currencyFormat.match(/\{\{amount\}\}/)[0];
    var currencySymbol = currencyFormat.replace(amountPlaceholder, '');
    var pricewithSymbol = currencySymbol.trim() + totalPrice;
    $('input[name="customized_price"]').val(pricewithSymbol);

    // event.preventDefault(); // Prevent the default button click behavior

    // Get the custom data from the hidden input fields
    const customizedImageUrl = document.querySelector('input[name="customized_image_url_front"]').value;
    const customizedBackImageUrl = document.querySelector('input[name="customized_image_url_back"]').value;
    const customizedPrice = document.querySelector('input[name="customized_price"]').value;
    const sizeVariants = document.querySelector('input[name="size_variants_data"]').value;
    const messagaeData = document.querySelector('textarea[name="messagefield"]').value;
    const variantID = document.querySelector('input[name="selective_variant_ID"]').value;

    // Initialize an empty array to store variant IDs and names
    const variants = [];

    // Get all div elements with the class "patch-"
    const patchDivs = document.querySelectorAll('.patch-');

    // Loop through each patch div
    patchDivs.forEach(patch => {
      // Get the variant ID from the v-id attribute
      const vId = patch.getAttribute('v-id');
      const Id = patch.getAttribute('id');
      
      const alphabets = Patchesdata.alphabets;
      const patches = Patchesdata.patches;

      // Find the corresponding variant object in Patchesdata
      const alphabetVariant = alphabets.find(item => item.id.toString() === vId);
      const patchVariant = patches.find(item => item.id.toString() === vId);

      // Merge the properties of both variant objects into a single object
      const variant = { ...alphabetVariant, ...patchVariant };
      
      // If a variant with the corresponding v-id is found, push its ID and name to the variants array
      if (variant) {
        variants.push({
          id: Id,
          name: variant.name || variant.variant_id
        });
      }
    });

    // Add {{ variant.id }} as the first item in the array
    variants.unshift({ id: '1', name:  variantID });
    console.log('these are variants array', variants);

  try {
      const response = await addToCart(variants, customizedImageUrl, customizedPrice, sizeVariants, messagaeData, customizedBackImageUrl);
      console.log('Cart Response:', response);
   if (response.status === 422) {
  const outOfStockDiv = document.getElementById('Out-of-stock-error');
  console.log(outOfStockDiv);
  if (outOfStockDiv) {
    const addItemDiv = document.querySelector('.add-item');
    if (addItemDiv) {
      addItemDiv.style.background = '#ffe2e8';
      addItemDiv.style.opacity = '1';
      addItemDiv.style.pointerEvents = '';
    }

    // Display .span-content div
    const spanContentDiv = document.querySelector('.span-content');
    if (spanContentDiv) {
      spanContentDiv.style.display = 'block';
    }
    
    const loaderCartDiv = document.querySelector('.loader-cart');
    if (loaderCartDiv) {
      loaderCartDiv.style.display = 'none';
    }
    
    console.log('yes exists');
    outOfStockDiv.style.display = 'none'; // Display the div
    outOfStockDiv.style.visibility = 'visible';
    outOfStockDiv.textContent = response.message; // Set the content to the error message
    
    // Call the function to hide the outOfStockDiv after 5 seconds
    hideOutOfStockDivAfterDelay();
  }
}else {
    // Redirect to cart if the response is successful
    window.location.href = '/cart';
  }
    } 
    catch (error) {
      console.error('Error adding items to cart:', error);
      // Handle error
    }
    async function addToCart(variants, customizedImageUrl, customizedPrice,sizeVariants,messagaeData,customizedBackImageUrl) {
            try {
                // Prepare data for adding to cart
                const items = variants.map(variant => {
                    const item = {
                        id: variant.name,
                        image: customizedImageUrl,
                        quantity: 1
                    };

                    // Define properties based on variant ID
                    if (variant.name ===  variantID) {
                        item.properties = {
                            "Product Name": '{{ product.title }}',
                            _customized_image_url_front: customizedImageUrl,
                            _customized_image_url_back:customizedBackImageUrl,
                            _size:sizeVariants,
                            _info:messagaeData,
                            _patches_price: customizedPrice,
                           _Timestamp: Date.now().toString()
                        };
                    } else {
                        item.properties = {
                            name: 'Custom Product',
                            _parent_variant:  variantID,
                            _Timestamp: Date.now().toString(),
                            _Unique: `${variant.id}_${Date.now()}`
                        };
                    }
                    return item;
                });

                const formData = { items };

                const response = await fetch(window.Shopify.routes.root + 'cart/add.js', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(formData)
                });

                return await response.json();
            } catch (error) {
                console.error('Error adding items to cart:', error);
                throw error; // Re-throw the error for further handling
            }
        }
}
   function hideOutOfStockDivAfterDelay() {
  setTimeout(() => {
    const outOfStockDiv = document.getElementById('Out-of-stock-error');
    if (outOfStockDiv) {
      outOfStockDiv.style.display = 'none';
      outOfStockDiv.style.visibility = 'none';
    }
  }, 5000); // Delay of 5 seconds
}
</script>
<script>
  function captureAndCombineScreenshots() {
console.log("Total elements in the DOM before capture:", document.querySelectorAll('*').length);
      function captureDiv(id) {
          return html2canvas(document.getElementById(id), {
              allowTaint: true,
              useCORS: true,
              logging: false,
              backgroundColor: null,
              ignoreElements: (el) => el.classList.contains('ignore-in-canvas'),
          });
      }

      if (document.getElementById('Front-Area').style.visibility === 'visible') {
          var backArea = document.getElementById('Back-area');
          backArea.style.visibility = 'visible';
          backArea.style.zIndex = 0;
           backArea.style.top = '-9999px';
      } else {
          document.getElementById('Front-Area').style.visibility = 'visible';
          document.getElementById('Back-area').style.visibility = 'visible';

      }

      Promise.all([
          captureDiv('Front-Area'),
          captureDiv('Back-area')
      ]).then(function(canvases) {
          var canvas1 = canvases[0];
          var canvas2 = canvases[1];

          console.log('Canvas 1 dimensions:', canvas1.width, canvas1.height);
          console.log('Canvas 2 dimensions:', canvas2.width, canvas2.height);

          var combinedCanvas = document.createElement('canvas');
          var ctx = combinedCanvas.getContext('2d');

          combinedCanvas.width = Math.max(canvas1.width, canvas2.width);
          combinedCanvas.height = canvas1.height + canvas2.height;

          console.log('Combined canvas dimensions:', combinedCanvas.width, combinedCanvas.height);

          ctx.drawImage(canvas1, 0, 0);
          ctx.drawImage(canvas2, 0, canvas1.height);

          var combinedImageURL = combinedCanvas.toDataURL('image/png');
          var counter = 2;
          uploadBlob(combinedImageURL, 'input[name="customized_image_url_front"]', counter);

          // var combinedScreenshotContainer = document.getElementById('combined-screenshot');
          // combinedScreenshotContainer.innerHTML = ''; // Clear previous content

          var img = new Image();
          img.src = combinedImageURL;

          img.onload = function() {
              console.log('Combined image loaded successfully.');
          };

          img.onerror = function() {
              console.error('Error loading combined image.');
          };

          // combinedScreenshotContainer.appendChild(img);
      }).catch(function(error) {
          console.error('Error capturing divs:', error);
      });
  }
</script>
