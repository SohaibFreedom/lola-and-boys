{% assign variant = product.selected_or_first_available_variant %}
<!--
  {{ variant.price | money }}
  {{ variant.id }}
-->
<!-- {{ variant | json}} -->

<style>
  .fotter-Summary-button:hover{
    background:rgb(0, 0, 0);
    color: white;
  }
  .footer-Summary-button:hover svg path {
  stroke: #fff; /* or your desired hover color */
  transition: stroke 0.3s ease;
}
  .customization-patch-product-name{
    font-weight: 400;
    font-size: 16px;
    line-height: 1.4;
    color: #2c272d;
  }
  .total-price span{
    font-size: 16px;
    font-weight: 500;
    line-height: 1.4;
    color: #2c272d;
    padding-right: 5px;
  }
  .span-content{
    font-size: 16px !important;
    text-transform: uppercase;
  }
.variants-container {
  position: absolute;
  bottom: 0;
  right: 0;
  width: 100%;
  padding: 24px;
  padding-bottom: 48px;
  background-color: #fff;
  border-top-left-radius: 20px;
  border-top-right-radius: 20px;
  z-index: 2;
  
  /* Hidden state */
  transform: translateY(0);
  opacity: 0;
  pointer-events: none;
  
  /* Animation */
  transition: all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
}

.variants-container-open {
  transform: translateY(-30px);
  opacity: 1;
  pointer-events: auto;
}


  @keyframes slide-up {
      from {
          transform: translateY(100%);
      }
      to {
          transform: translateY(0);
      }
  }
  .patch-customization-offcanvas-form{
    position:relative;
  }
  .patch-customizaton-foter{
    bottom: 0;
    border-top: 1px solid #dddddd;
    width: 100%;
    position: absolute;
    background: #ffffff;
  }
  .patch-customization-btn-wrap{
   position:relative;
  }
  .patch-customization-btn-outer-wrapper, .variant-selector-sidebar-foter {
        padding: 13px 24px;
  }
  .patches-customization-form-buttons{
    display: flex;
    width: 100%;
    position: relative; 
    z-index:3;
  }
  .fotter-Summary-button{
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight:600;
    gap: 10px;
    padding: 12px 36px;
    color: black;
    border-radius: 100px 0 0 100px;
    cursor:pointer;
    background:white;
  }
  .fotter-Summary-button > span {
    font-size: 16px;
    text-transform: uppercase;
    letter-spacing: 0.32px !important;
  }
  .add-item{
    font-weight:600;
    padding: 12px;
    display: flex;
    align-items: center;
    justify-content: center;
    background: #2c272d;
    color: white;
   border-radius: 0 100px 100px 0;
    width: 50%;
    cursor: pointer;
  }
  .total-price{
    border-top: 1px solid #dddddd;
    padding-top: 16px;
    margin-top: 25px;
    display:flex;
    justify-content:space-between;
  }
  .customization-patch-product-information{
    display:flex;
    justify-content:space-between;
    margin-top: 12px;
  }
  .loader-cart {
             border: 2px solid #f3f3f3; /* Light grey */
            border-top: 2px solid  #2c272d; /* Blue */
            border-radius: 50%;
            width: 25px;
            height: 25px;
            animation: spin 2s linear infinite;
            display:none;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
  .loader-cart-contiune {
            border: 2px solid #f3f3f3; /* Light grey */
            border-top: 2px solid  #2c272d; /* Blue */
            border-radius: 50%;
            width: 25px;
            height: 25px;
            animation: spin2 2s linear infinite;
            display:none;
        }

        @keyframes spin2 {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
  @media screen and (max-width: 1024px){
     .span-content {
    font-size: 17px !important;
    }
  }
  @media screen and (max-width: 376px){
    .span-content {
    font-size: 14px !important;
    }
  }
</style>

<div id="currency-format" data-money-format="{{ shop.money_format }}"></div>

<input type="hidden" name="customized_image_url_front" value="">
<input type="hidden" name="customized_image_url_back" value="">
<input type="hidden" name="customized_price" value="">
<input type="hidden" name="size_variants_data" id="size_variants_data" value="">
<input type="hidden" name="selective_variant_ID" id="selective_variant_ID" value="">
<input type="hidden" name="selective_variant_name" id="selective_variant_name" value="">

<div class="patch-customization-btn-outer-wrapper">
  <div
  class="overlapping-correction-error"
  style=""
>
  Please correct overlapping error first
</div>
<div class="patch-customization-btn-wrap">
  <div class="complete-overly-wrapper"></div>
  <div id="variantsContainer" class="variants-container"></div>
  <div class="patches-customization-form-buttons add-to-bag-btns-wrapper">
    
    
    <div class="fotter-Summary-button">
      <span>Summary</span>
      <svg
        width="8"
        height="14"
        viewBox="0 0 8 14"
        fill="none"
        xmlns="http://www.w3.org/2000/svg"
        class="patches-arrow-top toggle-summary-svg toggle-summary-svg-active"
      >
        <path d="M7 13L1 7" stroke="currentColor" stroke-width="2" stroke-linecap="round"></path><path d="M1 7.00002L6.99994 1.00002" stroke="currentColor" stroke-width="2" stroke-linecap="round" ></path>
      </svg>
      <svg
        width="8"
        height="14"
        viewBox="0 0 8 14"
        fill="none"
        xmlns="http://www.w3.org/2000/svg"
        class="patches-arrow-left toggle-summary-svg"
      >
        <path d="M7 13L1 7" stroke="currentColor" stroke-width="2" stroke-linecap="round"></path><path d="M1 7.00002L6.99994 1.00002" stroke="currentColor" stroke-width="2" stroke-linecap="round" ></path>
      </svg>
    </div>
    <div class="add-item">
      <span class="span-content">Add to bag</span>
      <div class="loader-cart"></div>
    </div>
  </div>
</div>
</div>
<script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
<!-- REMOVE html2canvas; not needed anymore -->
<script>
/** =================== CONFIG =================== **/
const CURRENCY_FORMAT_EL_ID = 'currency-format';
const S3_UPLOAD_ENDPOINT = 'https://6ch1pxqng1.execute-api.ap-south-1.amazonaws.com/check';

/** =================== GLOBALS =================== **/
const $ = window.jQuery;
const product = {{ product | json }};
const PARENT_PROPS = new Map();
let   PATCHESDATA_CACHE = null;

(async () => {
  try {
    const r = await fetch('https://lolaandtheboys.com/apps/data-pickup', { cache: 'force-cache' });
    if (r.ok) PATCHESDATA_CACHE = await r.json();
  } catch (_) {}
})();

const SESSION_TOKEN = () =>
  (Date.now().toString(36) + Math.random().toString(36).slice(2, 8)).toUpperCase();

function moneySymbol() {
  const el = document.getElementById(CURRENCY_FORMAT_EL_ID);
  if (!el) return '$';
  const currencyFormat = el.dataset.moneyFormat || '{{amount}}';
  const amountPlaceholder = (currencyFormat.match(/\{\{amount\}\}/) || ['{{amount}}'])[0];
  return currencyFormat.replace(amountPlaceholder, '').trim();
}

/** ============== IMAGE COMPOSITOR (CANVAS) ============== **/

// CORS-safe image loader
function loadImageCORS(src) {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.crossOrigin = 'anonymous';
    img.decoding = 'async';
    img.onload = () => resolve(img);
    img.onerror = reject;
    img.src = src;
  });
}

// helpers for CSS -> number
const num = (v) => Math.max(0, parseFloat(v) || 0);

// parse object-position
function parseObjectPosition(opStr = '50% 50%') {
  const map = { left:'0% 50%', top:'50% 0%', center:'50% 50%', right:'100% 50%', bottom:'50% 100%' };
  opStr = (opStr || '').trim().toLowerCase();
  if (map[opStr]) opStr = map[opStr];
  const p = opStr.split(/\s+/);
  const toFrac = (t) => {
    if (!t) return 0.5;
    if (t.endsWith('%')) return Math.min(1, Math.max(0, parseFloat(t)/100));
    if (t === 'left' || t === 'top') return 0;
    if (t === 'center') return 0.5;
    if (t === 'right' || t === 'bottom') return 1;
    return 0.5;
  };
  return { x: toFrac(p[0]), y: toFrac(p[1] || p[0]) };
}

// compute rect for object-fit inside a given box (content box)
function computeObjectFitRect(nw, nh, boxW, boxH, fit='fill', pos={x:0.5,y:0.5}) {
  let w = boxW, h = boxH;
  if (fit === 'contain' || fit === 'cover' || fit === 'scale-down') {
    const sx = boxW / nw, sy = boxH / nh;
    let s = 1;
    if (fit === 'contain') s = Math.min(sx, sy);
    else if (fit === 'cover') s = Math.max(sx, sy);
    else s = Math.min(1, Math.min(sx, sy));
    w = nw * s; h = nh * s;
  } else if (fit === 'none') { w = nw; h = nh; } // 'fill' keeps boxW x boxH
  const offX = (boxW - w) * pos.x;
  const offY = (boxH - h) * pos.y;
  return { drawW: w, drawH: h, offsetX: offX, offsetY: offY };
}

// Compose one side: base + patches (respects object-fit & content-box)
function getRotationDegrees(el) {
  const style = window.getComputedStyle(el);
  const transform = style.transform || style.webkitTransform;

  // element has NO rotation
  if (!transform || transform === 'none') return 0;

  const matrix = transform.match(/matrix\(([^)]+)\)/);
  if (!matrix) return 0;

  const values = matrix[1].split(',');
  const a = parseFloat(values[0]); // cos
  const b = parseFloat(values[1]); // sin

  let angle = Math.atan2(b, a) * (180 / Math.PI);
  return Math.round(angle);
}

async function composeArea({
  areaEl,
  baseImgSelector,
  patchSelector = ".patch-",
  background = "#ffffff",
  jpegQuality = 0.85
}) {
  if (!areaEl) throw new Error("composeArea: areaEl missing");

  const baseEl = areaEl.querySelector(baseImgSelector);
  if (!baseEl) throw new Error(`Base image not found: ${baseImgSelector}`);

  // ---- LOAD BASE IMAGE ----
  const baseImg = await loadImageCORS(baseEl.currentSrc || baseEl.src);

  const baseRect = baseEl.getBoundingClientRect();
  const renderedW = baseRect.width || baseImg.naturalWidth;
  const renderedH = baseRect.height || baseImg.naturalHeight;

  const scaleX = baseImg.naturalWidth / renderedW;
  const scaleY = baseImg.naturalHeight / renderedH;

  // ---- SETUP CANVAS ----
  const canvas = document.createElement("canvas");
  canvas.width = baseImg.naturalWidth;
  canvas.height = baseImg.naturalHeight;

  const ctx = canvas.getContext("2d", { alpha: false });
  ctx.imageSmoothingEnabled = true;
  ctx.imageSmoothingQuality = "high";

  // Background + base
  ctx.fillStyle = background;
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  ctx.drawImage(baseImg, 0, 0, canvas.width, canvas.height);

  // ---- PATCHES ----
  const patches = areaEl.querySelectorAll(patchSelector);

  for (const wrap of patches) {
    const imgEl = wrap.querySelector("img.patch-image");
    if (!imgEl) continue;

    const wrapRect = wrap.getBoundingClientRect();
    const baseRect2 = baseEl.getBoundingClientRect();

    // DOM relative â†’ natural px
    let x = wrapRect.left - baseRect2.left;
    let y = wrapRect.top - baseRect2.top;
    const w = wrapRect.width;
    const h = wrapRect.height;

    const style = getComputedStyle(wrap);
    const bl = num(style.borderLeftWidth),
      br = num(style.borderRightWidth),
      bt = num(style.borderTopWidth),
      bb = num(style.borderBottomWidth),
      pl = num(style.paddingLeft),
      pr = num(style.paddingRight),
      pt = num(style.paddingTop),
      pb = num(style.paddingBottom);

    const contentX = x + bl + pl;
    const contentY = y + bt + pt;
    const contentW = Math.max(0, w - bl - br - pl - pr);
    const contentH = Math.max(0, h - bt - bb - pt - pb);

    if (contentW <= 0 || contentH <= 0) continue;

    // Load image
    let img;
    try {
      img = await loadImageCORS(imgEl.currentSrc || imgEl.src);
    } catch (e) {
      console.warn("Patch load failed:", e);
      continue;
    }

    const cs = getComputedStyle(imgEl);
    const fit = (cs.objectFit || "fill").toLowerCase();
    const pos = parseObjectPosition(cs.objectPosition || "50% 50%");

    const { drawW, drawH, offsetX, offsetY } = computeObjectFitRect(
      img.naturalWidth,
      img.naturalHeight,
      contentW,
      contentH,
      fit,
      pos
    );

    // natural px rect
    const dx = Math.round((contentX + offsetX) * scaleX);
    const dy = Math.round((contentY + offsetY) * scaleY);
    const dw = Math.round(drawW * scaleX);
    const dh = Math.round(drawH * scaleY);

    const clipX = Math.round(contentX * scaleX);
    const clipY = Math.round(contentY * scaleY);
    const clipW = Math.round(contentW * scaleX);
    const clipH = Math.round(contentH * scaleY);

    ctx.save();
    ctx.beginPath();
    ctx.rect(clipX, clipY, clipW, clipH);
    ctx.clip();

    // ========== ROTATION FIX (No Size Enlargement) ==========
    const deg = getRotationDegrees(wrap);
    const rad = deg * Math.PI / 180;

    // Compute rotated bounding sizes
    const rotatedW = Math.abs(dw * Math.cos(rad)) + Math.abs(dh * Math.sin(rad));
    const rotatedH = Math.abs(dw * Math.sin(rad)) + Math.abs(dh * Math.cos(rad));

    // Compensation scale (prevent patch from becoming bigger)
    const scaleFix = Math.min(dw / rotatedW, dh / rotatedH);

    const cx = dx + dw / 2;
    const cy = dy + dh / 2;

    ctx.translate(cx, cy);
    ctx.rotate(rad);
    ctx.scale(scaleFix, scaleFix);

    ctx.drawImage(img, -dw / 2, -dh / 2, dw, dh);

    ctx.restore();
  }

  // ---- EXPORT CANVAS SAFELY (Shopify-proof) ----
  let blob, objectURL;
  try {
    blob = await new Promise(res =>
      canvas.toBlob(b => res(b), "image/jpeg", jpegQuality)
    );
    objectURL = URL.createObjectURL(blob);
  } catch (err) {
    console.warn("Canvas export blocked by Shopify/CSP:", err);
  }

  return { canvas, blob, objectURL };
}


// combine front+back vertically (back optional)
async function composeFrontBackAndExport({
  background = '#ffffff',
  jpegQuality = 0.85,
  maxWidth = 1200
} = {}) {
  const frontArea = document.getElementById('Front-Area');
  if (!frontArea) throw new Error('Front-Area not found');

  const backArea = document.getElementById('Back-Area') || document.getElementById('Back-area');

  const frontOut = await composeArea({
    areaEl: frontArea,
    baseImgSelector: '#Front-image',
    background, jpegQuality
  });

  let backOut = null;
  if (backArea && backArea.querySelector('#Back-image')) {
    try {
      backOut = await composeArea({
        areaEl: backArea,
        baseImgSelector: '#Back-image',
        background, jpegQuality
      });
    } catch (_) { backOut = null; }
  }

  if (!backOut) return frontOut;

  const width  = Math.max(frontOut.canvas.width, backOut.canvas.width);
  const height = frontOut.canvas.height + backOut.canvas.height;
  const combo  = document.createElement('canvas');
  combo.width  = width;
  combo.height = height;
  const cctx = combo.getContext('2d', { alpha: false });
  cctx.fillStyle = background;
  cctx.fillRect(0, 0, width, height);
  cctx.drawImage(frontOut.canvas, 0, 0);
  cctx.drawImage(backOut.canvas,  0, frontOut.canvas.height);

  // optional downscale for filesize
  let target = combo;
  if (maxWidth && combo.width > maxWidth) {
    const scale = maxWidth / combo.width;
    const down = document.createElement('canvas');
    down.width  = Math.round(combo.width * scale);
    down.height = Math.round(combo.height * scale);
    const dctx = down.getContext('2d', { alpha: false });
    dctx.fillStyle = background;
    dctx.fillRect(0, 0, down.width, down.height);
    dctx.drawImage(combo, 0, 0, down.width, down.height);
    target = down;
  }

  const blob = await new Promise(res => target.toBlob(b => res(b), 'image/jpeg', jpegQuality));
  const objectURL = URL.createObjectURL(blob);
  console.log('[COMPOSITE:FRONT+BACK] preview:', { w: target.width, h: target.height, url: objectURL });

  return { canvas: target, blob, objectURL };
}

/** ============== S3 + CART HELPERS ============== **/
async function uploadBlobToS3(blob) {
  const fd = new FormData();
  fd.append('image', blob, 'custom.jpg');
  const r = await fetch(S3_UPLOAD_ENDPOINT, { method: 'POST', body: fd });
  const json = await r.json();
  if (!json || !json.fileUrl) throw new Error('No fileUrl in S3 response');
  console.log('[S3] Uploaded URL:', json.fileUrl);
  return json.fileUrl;
}

async function updateLineItemPropsByKey(lineItemKey, newProps) {
  const r = await fetch('/cart/change.js', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ id: lineItemKey, properties: newProps })
  });
  if (!r.ok) throw new Error('Failed to update line item');
  return r.json();
}

async function getCart() {
  const r = await fetch('/cart.js', { cache: 'no-store' });
  return r.json();
}

/** ============== PRICE / SELECTIONS ============== **/
function collectPatchSelectionsAndPrice() {
  const symbol = moneySymbol();
  let productPrice = parseFloat(String('{{ product.price }}').replace(/[^\d.]/g, '')) || 0;
  const selected = [];
  const patchDivs = document.querySelectorAll('.patch-');

  const alphabets = PATCHESDATA_CACHE?.alphabets || [];
  const patches   = PATCHESDATA_CACHE?.patches   || [];
  document.querySelectorAll('.patch-').forEach(p => {
  console.log('Element:', p, 'v-id:', p.getAttribute('v-id'));
});
  console.log('Alphabets data:', PATCHESDATA_CACHE?.alphabets);
  patchDivs.forEach(patch => {
    const vId = patch.getAttribute('v-id');
    const Id  = patch.getAttribute('id');
    const alphabetVariant = alphabets.find(x => String(x.id) === String(vId));
    const patchVariant    = patches.find(x => String(x.id) === String(vId));
    const variant = { ...alphabetVariant, ...patchVariant };

    const priceNum = parseFloat(variant?.price);
      const variantIdNum = variant?.variant_id
    ? Number(variant.variant_id)
    : isNaN(Number(variant.name)) ? null : Number(variant.name);
console.log('Checking variant', variant, priceNum, variantIdNum);
    if (variant && !isNaN(priceNum) && !isNaN(variantIdNum) && variantIdNum > 0) {
      productPrice += priceNum;
      selected.push({
        id: Id,
        label: variant.alphabetname || variant.patchname || variant.name || String(variant.variant_id),
        variantId: variantIdNum
      });
    }
  });

  return { symbol, totalPrice: productPrice, selected };
}

/** ============== ADD TO CART (after image ready) ============== **/
async function addToCartWithImage(sessionId, s3Url) {
  const sizeVariants = document.querySelector('input[name="size_variants_data"]')?.value || '';
  const messageData  = document.querySelector('textarea[name="messagefield"]')?.value || '';
  const variantIDRaw = document.querySelector('input[name="selective_variant_ID"]')?.value || '';
  const variantID    = Number(variantIDRaw);
  if (!Number.isFinite(variantID)) throw new Error('Invalid parent variantID');

  const { symbol, totalPrice, selected } = collectPatchSelectionsAndPrice();
  $('input[name="customized_price"]').val(symbol + totalPrice);

  const now = Date.now().toString();
  const parentProps = {
    "Product Name": product.title,
    _customized_image_url_front: s3Url || 'pending',
    _customized_image_url_back:  s3Url || 'pending',
    _size: sizeVariants,
    _info: messageData,
    _patches_price: symbol + totalPrice,
    _Session: sessionId,
    _Parent: '1',
    _Timestamp: now
  };

  const items = [{ id: variantID, quantity: 1, properties: parentProps }];

  // children
  for (const sel of selected) {
    if (!Number.isFinite(sel.variantId)) continue;
    items.push({
      id: sel.variantId,
      quantity: 1,
      properties: {
        name: 'Custom Product',
        _parent_variant: variantID,
        _Session: sessionId,
        _ChildOf: '1',
        _Unique: `${sel.id}_${now}`,
        _Timestamp: now
      }
    });
  }

  const r = await fetch(`${window.Shopify?.routes?.root || '/'}cart/add.js`, {
    method: 'POST',
    headers: {'Content-Type': 'application/json'},
    body: JSON.stringify({ items })
  });
  if (!r.ok) throw new Error('add.js failed');

  // capture parent key (optional; handy for future updates)
  let parentKey = null;
  try {
    const resp = await r.clone().json();
    if (resp?.items?.length) {
      const addedParent = resp.items.find(it => it?.properties?._Session === sessionId && it?.properties?._Parent === '1');
      parentKey = addedParent?.key || null;
    } else if (resp?.key) {
      parentKey = resp.key;
    }
  } catch (_) {}

  if (!parentKey) {
    const cart = await getCart();
    const parent = cart.items.find(i => i.properties && i.properties._Session === sessionId && i.properties._Parent === '1');
    parentKey = parent?.key || null;
  }

  if (parentKey) PARENT_PROPS.set(parentKey, parentProps);

  console.log('[1] Products added to cart (with image) successfully');
  return { parentKey };
}

/** ============== OPTIONAL FEE CLEANUP ============== **/
async function maybeRemoveStitchingFee() {
  try {
    const cart = await getCart();
    const hasEmbroideryProduct = cart.items.some(i => i.properties && i.properties._embroideryProduct === 'Embroidery Product');
    if (!hasEmbroideryProduct) {
      const fee = cart.items.find(i => i.variant_id === 42085140430950);
      if (fee) {
        await fetch('/cart/change.js', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ id: fee.key, quantity: 0 })
        });
      }
    }
  } catch (_) {}
}

/** ============== BUTTON WIRING ============== **/
document.addEventListener('DOMContentLoaded', function () {
  const addBtn  = document.querySelector('.add-item');
  const loader  = document.querySelector('.loader-cart');
  const spanDiv = document.querySelector('.span-content');

  // Warm up cart
  setTimeout(() => { fetch('/cart.js', { cache: 'no-store' }).catch(()=>{}); }, 0);

  if (!addBtn) return;

  addBtn.addEventListener('click', async function () {
    if ($('.overlapping-error').css('visibility') === 'visible') {
      $('.overlapping-correction-error').css('display', 'block');
      return;
    }

    if (loader) loader.style.display = 'block';
    if (spanDiv) spanDiv.style.display = 'none';
    addBtn.style.pointerEvents = 'none';
    addBtn.style.backgroundColor = 'rgb(190 190 190)';

    // lock UI while building image
    document.querySelectorAll('.patch').forEach(el => {
     // el.classList.remove('patch');
      el.classList.add('patch-not-allowed');
      el.setAttribute('draggable', 'false');
    });

    const sessionId = SESSION_TOKEN();

    try {
      // 1) Compose the image(s)
      const { blob } = await composeFrontBackAndExport({
        jpegQuality: 0.85,
        maxWidth: 1200
      });

      // 2) Upload to S3
      const s3Url = await uploadBlobToS3(blob);
      console.log('[S3] Uploaded and ready. URL:', s3Url);

      // 3) Add items to cart with the image URL already set
      await addToCartWithImage(sessionId, s3Url);

      // 4) Optional clean-up (same as before)
      await maybeRemoveStitchingFee();

    } catch (err) {
      const outDiv = document.getElementById('Out-of-stock-error');
      if (outDiv) {
        outDiv.style.display = 'block';
        outDiv.style.visibility = 'visible';
        outDiv.textContent = 'Error adding to cart';
        setTimeout(() => { outDiv.style.display = 'none'; outDiv.style.visibility = 'hidden'; }, 5000);
      }
      console.error('Add to cart (after image) failed:', err);
    } finally {
      // restore button UI
      if (loader) loader.style.display = 'none';
      if (spanDiv) spanDiv.style.display = 'block';
      addBtn.style.pointerEvents = 'auto';
      addBtn.style.opacity = '1';
      addBtn.style.backgroundColor = '';
         document.querySelectorAll('.patch').forEach(el => {
     // el.classList.remove('patch');
      el.classList.remove('patch-not-allowed');
      el.removeAttribute('draggable');
    });
    }
  });
});
</script>

<script>
    const addCartButton = document.querySelector('.add-item');
    document.addEventListener('DOMContentLoaded', function () {

        let Patchesdata; // Define Patchesdata outside the function

        // Fetch Patchesdata from the API endpoint
        fetch(`https://lolaandtheboys.com/apps/data-pickup`)
            .then(response => {
                if (!response.ok) {
                    throw new Error('Network response was not ok');
                }
                return response.json();
            })
            .then(data => {
                // Assign the fetched data to Patchesdata
                Patchesdata = data;
            })
            .catch(error => {
                console.error('Error fetching data:', error);
            });

  $('.fotter-Summary-button').click(function () {
   
      $('.toggle-summary-svg').toggleClass('toggle-summary-svg-active');
        const variants = [];
        // let totalPrice = 0; // Initialize total price
        let productactualPrice = '{{ product.price }}';
        let productPrice = parseFloat(productactualPrice.slice(0, -2));
        // Get all div elements with the class "patch-"
        const patchDivs = document.querySelectorAll('.patch-');
        var currencyFormat = document.getElementById('currency-format').dataset.moneyFormat;
        var amountPlaceholder = currencyFormat.match(/\{\{amount\}\}/)[0];
        var currencySymbol = currencyFormat.replace(amountPlaceholder, '');
    
        const variantPrice = currencySymbol.trim() + productPrice;
            // If a variant with the corresponding v-id is found, push its ID and name to the variants array
             variants.unshift({ id: '1', name: '{{ product.title }}', price: variantPrice });
    
        // Loop through each patch div
        patchDivs.forEach(patch => {
            // Get the variant ID from the v-id attribute
            const vId = patch.getAttribute('v-id');
            const Id = patch.getAttribute('id');

            const alphabets = Patchesdata.alphabets;
            const patches = Patchesdata.patches;
            // Find the corresponding variant object in Patchesdata
            const alphabetVariant = alphabets.find(item => item.id.toString() === vId);
            const patchVariant = patches.find(item => item.id.toString() === vId);

            // Merge the properties of both variant objects into a single object
            const variant = { ...alphabetVariant, ...patchVariant };

             

            

            if (variant) {
                const price = parseFloat(variant.price);
                const formattedPrice = currencySymbol.trim() + price.toFixed(0);
                variants.push({
                    id: Id,
                    name: variant.alphabetname || variant.patchname,
                    price: formattedPrice
                });
                
                // Add the formatted price to the total price
                productPrice +=  price;
            }

        });

        let variantsHTML = "";
        variantsHTML += `
  <div class="summary-cross-btn-contiue-summary-patches">
    <svg width="16" height="16" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg">
      <path d="M9.09809 8L16 14.9019L14.9019 16L8 9.0981L1.0981 16L0 14.9019L6.9019 8L0 1.0981L1.0981 0L8 6.90191L14.9019 0L16 1.0981L9.09809 8Z" fill="#2C272D"></path>
    </svg>
  </div>
`;
        variants.forEach(variant => {
            variantsHTML += `
            <div class="customization-patch-product-information">
                <div class="customization-patch-product-name">${variant.name}</div> <div class="customization-patch-product-name">${variant.price}</div></div>`;
        });

        variantsHTML += `<div class="total-price"><span>Subtotal</span> <span>${currencySymbol.trim()}${productPrice}</span></div>`;
    
        // Update the content of the variants container
        $('.variants-container').html(variantsHTML);

        // Toggle visibility of the variants container with animation
       $('.variants-container').toggleClass('variants-container-open');
       $('.complete-overly-wrapper').toggleClass('complete-overly-wrapper-active');
       $('.complete-overly-wrapper').toggleClass('complete-overly-wrapper-active');
       $('.complete-overly-wrapper').toggleClass('complete-overly-wrapper-active');
    });

    $(document).on('click', '.summary-cross-btn-contiue-summary-patches', function() {
    $('.variants-container').toggleClass('variants-container-open');
    $('.complete-overly-wrapper').toggleClass('complete-overly-wrapper-active');
    $('.complete-overly-wrapper').toggleClass('complete-overly-wrapper-active');
    $('.complete-overly-wrapper').toggleClass('complete-overly-wrapper-active');
});
});


</script>

