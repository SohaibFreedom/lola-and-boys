{% assign variant = product.selected_or_first_available_variant %}
<script>
console.log("check patch js code load rwquests");
  
    document.addEventListener('DOMContentLoaded', function () {
       console.log('gardient-color-before');
        const product = {{ product | json }};
                 console.log(product.available);
         if (!product.available) {
        // Hide the button if the product is not available
        $('.customize-button').hide();
           console.log('PRODUCT IS OUT OF STOCK');
    }
        if (Array.isArray(product.tags) && product.tags.includes('gardient-color')) {
        
            $('.size_variants_section_color_heading').css('display', 'none');
            $('.variant-selector-sidebar-btn').css('display', 'none');
            $('.size_variants_section').css('margin-top', '0px');
        }
    });
</script>

<script>
$(document).ready(function() {
    $('.patches-back-button-relaod').click(function() {
        console.log('#patches-back-button clicked');
        location.reload();
    });
});


   console.log('product',{{product | json}})
  var product = {{product | json}};
  if (product.tags && product.tags.includes('patch-customizer')) {
      console.log('hide the zakeke customiz bnm')
      var button = document.querySelector('#zakeke-product-button-custom');
      if (button) {
        button.style.display = 'none';
      }
    }
  $(document).ready(function() {
      $('#small_variant').click(function() {
        console.log('change-text');
          $('.size_selector_heading').text('Small');
      });
      $('#medium_variant').click(function() {
          $('.size_selector_heading').text('Medium');
      });
      $('#large_variant').click(function() {
          $('.size_selector_heading').text('Large');
      });
      $('#extra_large_variant').click(function() {
          $('.size_selector_heading').text('Extra Large');
      });
  });
</script>
<script>
   function tidyEditbtnfuncion() {
      if (window.matchMedia("(max-width: 769px)").matches) {
          $('.patches-tidy-editor-btn').css('visibility', 'visible');
          $('.only-mobile-eidt-btn').css('visibility', 'visible');
      } else {
          $('.patches-tidy-editor-btn').css('visibility', 'hidden');
          $('.only-mobile-edit-btn').css('visibility', 'hidden');
      }
  }
</script>
<script>
    function changefillColors() {
        console.log('changefillColors');

        let patchActionCount;
        const patchesContainer = document.querySelector('.patches-container');
        const patchesBackContainer = document.querySelector('.patches-containerr');

        if (document.getElementById('Front-Area').style.visibility === 'visible') {
            const patches = patchesContainer.querySelectorAll('.patch-action');
            patchActionCount = patches.length;
            console.log(patchActionCount);
        } else {
            const patches = patchesBackContainer.querySelectorAll('.patch-action');
            patchActionCount = patches.length;
            console.log(patchActionCount);
        }

        const paths = document.querySelectorAll('.custom_fill_path');
        console.log('These are paths:', paths);
        console.log('patchActionCount', patchActionCount);

        paths.forEach(path => {
            if (patchActionCount < 2) {
                console.log('Adding custom_fill class');
                path.classList.add('custom_fill');
            } else {
                console.log('Removing custom_fill class');
                path.classList.remove('custom_fill');
            }
        });


        const positionsDivs = document.querySelectorAll('.change_svg_color');
      const rangeDiv = document.getElementById('myRange');
      console.log(rangeDiv);
        console.log('These are paths:', paths);
        console.log('patchActionCount', patchActionCount);

      positionsDivs.forEach(position => {
      if (patchActionCount < 1) {
          console.log('Adding custom_fill class');
          position.classList.add('custom_svg_color');
          rangeDiv.classList.remove('range-sliderr');
      } else {
          console.log('Removing custom_fill class');
          position.classList.remove('custom_svg_color');
            rangeDiv.classList.add('range-sliderr');
      }
  });


    }
</script>

<script>
    const patchesContainerr = document.querySelector('.patches-container');
    const patchesBackContainerr = document.querySelector('.patches-containerr');
    const alignHorizontall = document.getElementById('align-horizontal');
    const alignVerticalall = document.getElementById('align-vertical');
    const aligndiagnolrightall = document.getElementById('align-diagonal-right');
    const aligndiagnolleftall = document.getElementById('align-diagonal-left');
    const gap10 = document.getElementById('gap10');
    const gap15 = document.getElementById('gap15');
    const gap20 = document.getElementById('gap20');
    const gap25 = document.getElementById('gap25');



    function checkPatches() {
        let patchActionCount;

        if (document.getElementById('Front-Area').style.visibility === 'visible') {
            const patches = patchesContainerr.querySelectorAll('.patch-action');
            patchActionCount = patches.length;
            console.log(patchActionCount);
        } else {
            const patches = patchesBackContainerr.querySelectorAll('.patch-action');
            patchActionCount = patches.length;
            console.log(patchActionCount);
        }

        if (patchActionCount < 2) {
            alignHorizontall.classList.add('not-allowed');
            alignVerticalall.classList.add('not-allowed');
           aligndiagnolrightall.classList.add('not-allowed');
           aligndiagnolleftall.classList.add('not-allowed');
           gap10.classList.add('not-allowed');
           gap15.classList.add('not-allowed');
           gap20.classList.add('not-allowed');
           gap25.classList.add('not-allowed');
        } else {
            alignHorizontall.classList.remove('not-allowed');
             alignVerticalall.classList.remove('not-allowed');
             aligndiagnolrightall.classList.remove('not-allowed');
             aligndiagnolleftall.classList.remove('not-allowed');
             gap10.classList.remove('not-allowed');
             gap15.classList.remove('not-allowed');
             gap20.classList.remove('not-allowed');
             gap25.classList.remove('not-allowed');

        }
    }

    alignHorizontall.addEventListener('mouseenter', checkPatches);
    alignVerticalall.addEventListener('mouseenter', checkPatches);
    aligndiagnolrightall.addEventListener('mouseenter', checkPatches);
    aligndiagnolleftall.addEventListener('mouseenter', checkPatches);
   gap10.addEventListener('mouseenter', checkPatches);
   gap15.addEventListener('mouseenter', checkPatches);
   gap20.addEventListener('mouseenter', checkPatches);
  gap25.addEventListener('mouseenter', checkPatches);
</script>
<script>
     const movetop = document.getElementById('move-top');
     const moveleft = document.getElementById('move-left');
     const movecenter = document.getElementById('move-center');
     const moveright = document.getElementById('move-right');
     const movebottom = document.getElementById('move-bottom');
     const rangeSlider = document.getElementById('myRange');
     const decrementButtonNN = document.getElementById('decrementButton');
     const incrementButtonNN = document.getElementById('incrementButton');
     const messagefieldNot = document.getElementById('messagefield');
     const deleteBtnOt = document.querySelector('.tidy-patches-delete-btn');



     function checkPatches1() {
         let patchActionCount;

         if (document.getElementById('Front-Area').style.visibility === 'visible') {
             const patches = patchesContainerr.querySelectorAll('.patch-action');
             patchActionCount = patches.length;
             console.log(patchActionCount);
         } else {
             const patches = patchesBackContainerr.querySelectorAll('.patch-action');
             patchActionCount = patches.length;
             console.log(patchActionCount);
         }

         if (patchActionCount < 1) {
             movetop.classList.add('not-allowed');
             moveleft.classList.add('not-allowed');
            movecenter.classList.add('not-allowed');
            moveright.classList.add('not-allowed');
            movebottom.classList.add('not-allowed');
           // Disable the slider and change the cursor to not-allowed
             rangeSlider.disabled = true;
             decrementButtonNN.disabled = true;
             incrementButtonNN.disabled = true;
             messagefieldNot.disabled = true;
             messagefieldNot.classList.add('not-allowed');
             deleteBtnOt.disabled = true;
             deleteBtnOt.classList.add('not-allowed');

         } else {
             movetop.classList.remove('not-allowed');
              moveleft.classList.remove('not-allowed');
              movecenter.classList.remove('not-allowed');
              moveright.classList.remove('not-allowed');
               movebottom.classList.remove('not-allowed');
           rangeSlider.disabled = false;
             decrementButtonNN.disabled = false;
             incrementButtonNN.disabled = false;
             messagefieldNot.disabled =  false;
             messagefieldNot.classList.remove('not-allowed');
             deleteBtnOt.disabled =  false;
             deleteBtnOt.classList.remove('not-allowed');

         }
     }

     movetop.addEventListener('mouseenter', checkPatches1);
     moveleft.addEventListener('mouseenter', checkPatches1);
     movecenter.addEventListener('mouseenter', checkPatches1);
    moveright.addEventListener('mouseenter', checkPatches1);
    movebottom.addEventListener('mouseenter', checkPatches1);
     rangeSlider.addEventListener('mouseenter', checkPatches1);
    decrementButton.addEventListener('mouseenter', checkPatches1);
   incrementButton.addEventListener('mouseenter', checkPatches1);
  messagefieldNot.addEventListener('mouseenter', checkPatches1);
</script>

<script>
  var ismainDragging = false;
  var order = 1; // Initialize order counter
  var orderBack = 1;
</script>
<script>
    function closePopup() {
    console.log('close the pop up');
      const popup = document.querySelector('.popup');
      if (popup) {
          popup.classList.add('fade-out');
          popup.classList.remove('active');
          setTimeout(() => {
              popup.remove();
          }, 300); // Wait for the transition to finish before removing the pop-up
      }
  }
</script>
<script>
  $(document).ready(function() {

          // Check if .patch-selected-by-btn class exists within .edit-btn-patch-selected
          if ($('.edit-btn-patch-selected').hasClass('patch-selected-by-both')) {
              $('.delete-patches-wrapper-sidebar > .tidy-patches-delete-btn-wrraper').show();
          } else {
              $('.delete-patches-wrapper-sidebar > .tidy-patches-delete-btn-wrraper').hide();
          }
      });
</script>
<script>
      $(document).ready(function() {
        $(document).on('click', '.add-patch-pop-up-btn', function() {
            // Extract data attributes from the clicked element
            var patchSrc = $(this).attr('data-patch-src-popup');
            var patchId = $(this).attr('data-patch-id-popup');
            var patchHeight = $(this).attr('data-patch-height-popup');
            var patchWidth = $(this).attr('data-patch-width-popup');

            if (document.getElementById('Front-Area').style.visibility === 'visible') {
           addPatchToCenterBox(patchSrc, patchId, patchHeight, patchWidth);
               closePopup();
        } else if (document.getElementById('Back-area').style.visibility === 'visible') {
            addPatchToBackcenterBox(patchSrc, patchId, patchHeight, patchWidth);
               closePopup();
        }
  closePopup();
        });
    });
</script>
<script>
   $(document).on('click', '.edit-left-btn', function(event) {
       if ($(this).hasClass('patches-customization-tidy-delete-btn-active')) {
           console.log('.tidy-right-btn hon my');
          changefillColors();
          $('.edit-delete-btn').removeClass('patches-customization-tidy-delete-btn-active');
           $('.patches-customization-editor').addClass('patches-customization-editor-active');
           $('.patches-customization-editor').css('display', 'block');
           $('.patches-editor-wrapper').css('display', 'none');
           $('.only-mobile-colors-wrapper').css('display', 'none');
           $('.delete-patches-wrapper-sidebar').css('display', 'none');
    
           if (window.matchMedia("(max-width: 768px)").matches){
               $('.only-mobile-tdy-header').css('display', 'block');
           } else {
               $('.only-mobile-tdy-header').css('display', 'none');  
           }

           if (document.getElementById('Front-Area').style.visibility === 'visible') {
               $('.back-tdiy-patches-btn').removeClass('tdiy-patches-btn-active');
               $('.front-tdiy-patches-btn').addClass('tdiy-patches-btn-active');
               $('.select-patches-for-back').removeClass('select-patches-active');
               $('.select-patches-for-front').addClass('select-patches-active');
               $('.patches-container .patch-').each(function() {
                   var patchId = $(this).attr('id');
        
                   // Check if the patch with the same ID already exists in .select-patches
                   if (!$('.select-patches-for-front').find('[data-patch-id="' + patchId + '"]').length) {
                       // Get image source
                       var imageSrc = $(this).find('.patch-image').attr('src');

                       // Create a new div with class .selected-patch-for-customization
                       var selectedPatchDiv = $(`<div class="selected-patch-for-customization selected-patch-for-customization-for-front" id="${patchId}"></div>`);

                       // Create an img element with the same src as the original image
                       var imageElement = $('<img>').attr('src', imageSrc);

                       // Append the image to the new div
                       selectedPatchDiv.append(imageElement);

                       // Append the patchId as a data attribute
                       selectedPatchDiv.attr('data-patch-id', patchId);

                       // Append the new div to .select-patches
                       $('.select-patches-for-front').append(selectedPatchDiv);
                   }
               });
           } else if (document.getElementById('Back-area').style.visibility === 'visible') {
               $('.front-tdiy-patches-btn').removeClass('tdiy-patches-btn-active');
               $('.back-tdiy-patches-btn').addClass('tdiy-patches-btn-active');
               $('.select-patches-for-front').removeClass('select-patches-active');
               $('.select-patches-for-back').addClass('select-patches-active');
               $('.patches-container .patch-').each(function() {
                   var patchId = $(this).attr('id');
        
                   // Check if the patch with the same ID already exists in .select-patches
                   if (!$('.select-patches-for-back').find('[data-patch-id="' + patchId + '"]').length) {
                       // Get image source
                       var imageSrc = $(this).find('.patch-image').attr('src');

                       // Create a new div with class .selected-patch-for-customization
                       var selectedPatchDiv = $(`<div class="selected-patch-for-customization selected-patch-for-customization-for-back" id="${patchId}"></div>`);

                       // Create an img element with the same src as the original image
                       var imageElement = $('<img>').attr('src', imageSrc);

                       // Append the image to the new div
                       selectedPatchDiv.append(imageElement);

                       // Append the patchId as a data attribute
                       selectedPatchDiv.attr('data-patch-id', patchId);

                       // Append the new div to .select-patches
                       $('.select-patches-for-back').append(selectedPatchDiv);
                   }
               });
           }

           setTimeout(function() {
               $('.patches-customization-editor').css('right', '0');
           }, 100);
       } 
       else {
         $('.tidy-right-btn').removeClass('patches-customization-tidy-delete-btn-active');
              $(this).addClass('patches-customization-tidy-delete-btn-active');
           if ($('.edit-btn-patch-selected').hasClass('patch-selected-by-both')) {
               $('.delete-patches-wrapper-sidebar > .tidy-patches-delete-btn-wrraper').show();
           } else {
               $('.delete-patches-wrapper-sidebar > .tidy-patches-delete-btn-wrraper').hide();
           }
          
           console.log('.tidy-right-btn hon my jani');
         changefillColors();
           $('.delete-patches-wrapper-sidebar').css('display', 'block');
           $('.patches-customization-editor').css('display', 'none');
           $('.patches-editor-wrapper').css('display', 'none');
           $('.only-mobile-colors-wrapper').css('display', 'none');
    
           if (window.matchMedia("(max-width: 768px)").matches){
               $('.only-mobile-tdy-header').css('display', 'block');
           } else {
               $('.only-mobile-tdy-header').css('display', 'none');  
           }

           if (document.getElementById('Front-Area').style.visibility === 'visible') {
               $('.back-tdiy-patches-btn').removeClass('tdiy-patches-btn-active');
               $('.front-tdiy-patches-btn').addClass('tdiy-patches-btn-active');
               $('.select-patches-for-back').removeClass('select-patches-active');
               $('.select-patches-for-front').addClass('select-patches-active');
               $('.patches-container .patch-').each(function() {
                   var patchId = $(this).attr('id');
        
                   // Check if the patch with the same ID already exists in .select-patches
                   if (!$('.select-patches-for-front').find('[data-patch-id="' + patchId + '"]').length) {
                       // Get image source
                       var imageSrc = $(this).find('.patch-image').attr('src');

                       // Create a new div with class .selected-patch-for-customization
                       var selectedPatchDiv = $(`<div class="selected-patch-for-customization selected-patch-for-customization-for-front" id="${patchId}"></div>`);

                       // Create an img element with the same src as the original image
                       var imageElement = $('<img>').attr('src', imageSrc);

                       // Append the image to the new div
                       selectedPatchDiv.append(imageElement);

                       // Append the patchId as a data attribute
                       selectedPatchDiv.attr('data-patch-id', patchId);

                       // Append the new div to .select-patches
                       $('.select-patches-for-front').append(selectedPatchDiv);
                   }
               });
           } else if (document.getElementById('Back-area').style.visibility === 'visible') {
               $('.front-tdiy-patches-btn').removeClass('tdiy-patches-btn-active');
               $('.back-tdiy-patches-btn').addClass('tdiy-patches-btn-active');
               $('.select-patches-for-front').removeClass('select-patches-active');
               $('.select-patches-for-back').addClass('select-patches-active');
               $('.patches-container .patch-').each(function() {
                   var patchId = $(this).attr('id');
        
                   // Check if the patch with the same ID already exists in .select-patches
                   if (!$('.select-patches-for-back').find('[data-patch-id="' + patchId + '"]').length) {
                       // Get image source
                       var imageSrc = $(this).find('.patch-image').attr('src');

                       // Create a new div with class .selected-patch-for-customization
                       var selectedPatchDiv = $(`<div class="selected-patch-for-customization selected-patch-for-customization-for-back" id="${patchId}"></div>`);

                       // Create an img element with the same src as the original image
                       var imageElement = $('<img>').attr('src', imageSrc);

                       // Append the image to the new div
                       selectedPatchDiv.append(imageElement);

                       // Append the patchId as a data attribute
                       selectedPatchDiv.attr('data-patch-id', patchId);

                       // Append the new div to .select-patches
                       $('.select-patches-for-back').append(selectedPatchDiv);
                   }
               });
           }

           setTimeout(function() {
               $('.patches-customization-editor').css('right', '0');
           }, 100);
       }
   });
</script>

<script>
   $(document).on('click', '.tidy-right-btn', function(event) {
      $('.edit-left-btn').removeClass('patches-customization-tidy-delete-btn-active');

      // Add the class to the clicked element
      $(this).addClass('patches-customization-tidy-delete-btn-active');

    console.log('.tidy-right-btn');
    changefillColors();
    $('.patches-customization-editor').addClass('patches-customization-editor-active');
    $('.patches-customization-editor').css('display', 'block');
    $('.patches-editor-wrapper').css('display', 'none');
    $('.only-mobile-colors-wrapper').css('display', 'none');
     $('.delete-patches-wrapper-sidebar').css('display', 'none');
    
    if (window.matchMedia("(max-width: 768px)").matches){
       $('.only-mobile-tdy-header').css('display', 'block');
    }else{
       $('.only-mobile-tdy-header').css('display', 'none');  
}

      if (document.getElementById('Front-Area').style.visibility === 'visible') {
          $('.back-tdiy-patches-btn').removeClass('tdiy-patches-btn-active')
        $('.front-tdiy-patches-btn').addClass('tdiy-patches-btn-active')
        $('.select-patches-for-back').removeClass('select-patches-active')
        $('.select-patches-for-front').addClass('select-patches-active')
          $('.patches-container .patch-').each(function() {
        var patchId = $(this).attr('id');
        
        // Check if the patch with the same ID already exists in .select-patches
        if (!$('.select-patches-for-front').find('[data-patch-id="' + patchId + '"]').length) {
            // Get image source
            var imageSrc = $(this).find('.patch-image').attr('src');

            // Create a new div with class .selected-patch-for-customization
            var selectedPatchDiv = $(`<div class="selected-patch-for-customization selected-patch-for-customization-for-front" id="${patchId}"></div>`);

            // Create an img element with the same src as the original image
            var imageElement = $('<img>').attr('src', imageSrc);

            // Append the image to the new div
            selectedPatchDiv.append(imageElement);

            // Append the patchId as a data attribute
            selectedPatchDiv.attr('data-patch-id', patchId);

            // Append the new div to .select-patches
            $('.select-patches-for-front').append(selectedPatchDiv);
        }
    });
    } 
      else if (document.getElementById('Back-area').style.visibility === 'visible') {
        $('.front-tdiy-patches-btn').removeClass('tdiy-patches-btn-active')
        $('.back-tdiy-patches-btn').addClass('tdiy-patches-btn-active')
        $('.select-patches-for-front').removeClass('select-patches-active')
        $('.select-patches-for-back').addClass('select-patches-active')
        $('.patches-containerr .patch-').each(function() {
        var patchId = $(this).attr('id');
        
        // Check if the patch with the same ID already exists in .select-patches
        if (!$('.select-patches-for-back').find('[data-patch-id="' + patchId + '"]').length) {
            // Get image source
            var imageSrc = $(this).find('.patch-image').attr('src');

            // Create a new div with class .selected-patch-for-customization
            var selectedPatchDiv = $(`<div class="selected-patch-for-customization selected-patch-for-customization-for-back" id="${patchId}"></div>`);

            // Create an img element with the same src as the original image
            var imageElement = $('<img>').attr('src', imageSrc);

            // Append the image to the new div
            selectedPatchDiv.append(imageElement);

            // Append the patchId as a data attribute
            selectedPatchDiv.attr('data-patch-id', patchId);

            // Append the new div to .select-patches
            $('.select-patches-for-back').append(selectedPatchDiv);
        }
    });
     
     }

    setTimeout(function() {
        $('.patches-customization-editor').css('right', '0');
    }, 100);
});
</script>
<!--
  <script>
    $(document).ready(function() {
      $('.edit-delete-btn').click(function() {
        // Remove the class from all elements with the class edit-delete-btn
        $('.edit-delete-btn').removeClass('patches-customization-tidy-delete-btn-active');

        // Add the class to the clicked element
        $(this).addClass('patches-customization-tidy-delete-btn-active');
      });
    });
  </script>
-->
<script>
  window.addEventListener('load', () => {
      const headingDiv = document.querySelector('.product-tile-for-selected');
     console.log('headingDiv',headingDiv)
      if (headingDiv) {
        console.log('product-tile-januuu')
          headingDiv.textContent = headingDiv.textContent.charAt(0).toUpperCase() + headingDiv.textContent.slice(1).toLowerCase();
      }
  });
</script>
<script>
     console.log('no new button exist')


      var slider = document.getElementById("myRange");
      var output = document.getElementById("demo");
      const decrementButton = document.getElementById('decrementButton');
      const incrementButton = document.getElementById('incrementButton');
      // Display the default slider value
      output.innerHTML = slider.value;

     function updateSliderValue() {
      let patchesContainer;
      let patchActions;

      if (document.getElementById('Front-Area').style.visibility === 'visible') {
          patchesContainer = document.querySelector('.patches-container');
          if (patchesContainer) {
              patchActions = patchesContainer.querySelectorAll('.patch-action');
          }
      } else if (document.getElementById('Back-area').style.visibility === 'visible') {
          patchesContainer = document.querySelector('.patches-containerr');
          if (patchesContainer) {
              patchActions = patchesContainer.querySelectorAll('.patch-action');
          }
      }
   console.log('patchActions ',patchActions )
      // Ensure patchActions is defined before using it
      if (patchActions) {
          output.innerHTML = slider.value;
          var rotationValue = slider.value; // Use the slider value directly
          patchActions.forEach(function(patchAction) {
              patchAction.style.transform = 'rotate(' + rotationValue + 'deg)';
          });
      } else {
          console.error('patchActions not found or patchesContainer is not defined.');
      }
  }
      decrementButton.addEventListener('click', function() {
          slider.value = Math.max(parseInt(slider.value) - 1, slider.min);
          updateSliderValue();
      });

      incrementButton.addEventListener('click', function() {
          slider.value = Math.min(parseInt(slider.value) + 1, slider.max);
          updateSliderValue();
      });
  // Event listener for the slider input
  slider.addEventListener('input', updateSliderValue);

  // Call updateSliderValue initially
  updateSliderValue();
</script>
<!--
  <script>
    // Select the button with the class 'customize-button'
    var customizeButton = document.querySelector('.customize-button');

    // Select the div with the id 'shopify-block-yotpo_product_reviews_ugc_reviews_MbrNNx'
    var bannerLow = document.querySelector('#shopify-block-yotpo_product_reviews_ugc_reviews_MbrNNx');

    // Check if both the button and the div exist
    if (customizeButton && bannerLow) {
        // Add a click event listener to the button
        customizeButton.addEventListener('click', function() {
            console.log(bannerLow);
            // Add the class 'hidedisplay' to the div
            bannerLow.classList.add('hidedisplay');
        });
    }
  </script>
-->

<script>
  $(document).ready(function() {
    // Select the button using its class
    var customizeButton = $('.customize-button');
    var cartButton = $('.customize-cart-button');
    var neverMindBtn = $('.all-sidebar-cross-neverMind-button');
    var clearneverMindBtn = $('.patches-customizations-nevr-btn');

    // Flag to indicate whether customization mode is active
    var isCustomizationActive = false;

    // Callback function to execute when mutations are observed
    var callback = function(mutationsList, observer) {
        for (var mutation of mutationsList) {
            if (mutation.type === 'childList' && mutation.addedNodes.length > 0) {
                mutation.addedNodes.forEach(function(node) {
                    if (node.classList && node.classList.contains('yotpo-banner-low')) {
                        if (isCustomizationActive) {
                            // Hide the element if customization is active
                            node.style.display = 'none';
                            console.log('.yotpo-banner-low is now hidden.');
                        }
                    }
                });
            } else if (mutation.type === 'attributes' && mutation.target.classList.contains('yotpo-banner-low')) {
                if (isCustomizationActive) {
                    // Hide the element if customization is active
                    mutation.target.style.display = 'none';
                    console.log('.yotpo-banner-low is now hidden (attribute change).');
                }
            }
        }
    };

    // Create an observer instance linked to the callback function
    var observer = new MutationObserver(callback);

    // Configuration of the observer:
    // We want to observe additions of nodes (childList) and attribute changes
    var config = { attributes: true, childList: true, subtree: true };

    // Start observing the document's body for configured mutations
    observer.observe(document.body, config);

    // Add a click event listener to the button
    customizeButton.click(function() {
        isCustomizationActive = true;
        console.log('customize button clicked');
         $('body').addClass('patch_customizer_main_page');
        // Hide the bannerLow if it already exists
        var bannerLow = document.querySelector('.yotpo-banner-low');
        if (bannerLow) {
            bannerLow.style.display = 'none';
        }

        // Select all elements with the hide-for-customization class and hide them
        $('.hide-for-customization').hide();
        $('#shopify-block-yotpo_product_reviews_ugc_reviews_MbrNNx').hide();

        $('.footer').hide();
        $('.annoucment-bar-top').hide();
        $('#header').hide();
        $('#some-id').hide();
        // $('.yotpo-banner-low').hide();

        // Show the product customization div
        $('.product-customization').show();

        // Add classes to make other elements visible
        $('.announce-bar-slide-wrapper, .header-background--solid, .content').hide();
        $('.customize-cart-button').hide();

        // Add a class to cartButton to make it visible
        cartButton.addClass('customize-cart-button-visible');
    });

    // Add click event listener to the neverMindBtn button
    neverMindBtn.click(function() {
        isCustomizationActive = false;
        console.log('never mind button clicked');

        // Show the bannerLow if it exists
        var bannerLow = document.querySelector('.yotpo-banner-low');
        if (bannerLow) {
            bannerLow.style.display = '';
        }

        // Show all elements that were hidden for customization
        $('.hide-for-customization').show();

        $('.footer').show();
        $('.annoucment-bar-top').show();
        $('#header').show();
        $('#some-id').show();
        // $('.yotpo-banner-low').show();

        // Hide the product customization div
        $('.product-customization').hide();

        // Show the original elements
        $('.announce-bar-slide-wrapper, .header-background--solid, .content').show();
        $('.customize-cart-button').show();

        // Remove the class from cartButton
        cartButton.removeClass('customize-cart-button-visible');
    });

    // Clear neverMindBtn click event listener
    // clearneverMindBtn.click(function() {
    //     // Reload the page
    //     location.reload();
    // });
  });
</script>

<script>
 



    $('.patches-back-button').click(function() {
       // location.reload();
        $('.patches-tidy-editor-btn').css('display', 'none');
      // Remove the class from any element that has it
      $('.variants-selected-sidebar').removeClass('variants-continue-btn-invisible');
              if (window.matchMedia("(max-width: 768px)").matches){
          $('.only-mobile').css('display', 'block');
      }else{
      $('.only-mobile').css('display', 'none');
  }
      $('.only-mobile-colors-wrapper').css('display', 'none');

  });
   $('.close-variant-selector-editor').click(function() {
      // Remove the class from any element that has it
      $('.all-sidebar-cross-alert').addClass('all-sidebar-cross-alert-visble');

      $('.patches-customization-container-overly').css('display', 'block');
  });
   $('.patches-customization-remover').click(function() {
      // Remove the class from any element that has it
      $('.all-sidebar-cross-alert').addClass('all-sidebar-cross-alert-visble');
      $('.patches-customization-container-overly').css('display', 'block');
  });

    $('.crosssvg-wrapper').click(function() {
      // Remove the class from any element that has it
      $('.all-sidebar-cross-alert').removeClass('all-sidebar-cross-alert-visble');
       $('.patches-customization-container-overly').css('display', 'none');

  });
    $('.all-sidebar-cross-exit-button').click(function() {
      // Remove the class from any element that has it
      // $('.all-sidebar-cross-alert').removeClass('all-sidebar-cross-alert-visble');
      // $('.patches-customization-container-overly').css('display', 'none');
       location.reload();

  });
  $('#patches-back-button').click(function() {
   location.reload();

  });
</script>
<script>

 // Make a request to your Remix app's API endpoint with the Shopify.shop parameter
 fetch(`https://lolaandtheboys.com/apps/data-pickup`)
   .then(response => {
     // Check if the response is successful
     if (!response.ok) {
       throw new Error('Network response was not ok');
     }
 
     // Parse the response as JSON
     return response.json();
   })
   .then(data => {
     // Log the data received from the API
     console.log('DATA',data)
     const alphabets = data.alphabets;
     const patches = data.patches;
     const imagesData = data.frontImgData;
     const colorVariants = data.colorvariants;
       const sizeVariants = data.sizevariants;
     console.log('imagesData',imagesData);
     console.log(sizeVariants);
     
     showFrontImage();
     showBackImage();
      const productTags = {{ product.tags | json }};

     showcolorVariants();
       // showSizeVariants();
 




    $(document).ready(function(){
  let availableVariants = []; // Step 1: Declare a global variable

async function fetchAllProducts() {
  const products = [];
  let hasNextPage = true;
  let cursor = null;

  while (hasNextPage) {
    const response = await fetch('https://lolaandtheboys.com/api/2024-10/graphql.json?timestamp=${Date.now()}', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-Shopify-Storefront-Access-Token': '17418121749abfc8793ce070963ebf5d',
          'Cache-Control': 'no-cache',
       'Pragma': 'no-cache',  // Add this to force no-cache behavior
        'Expires': '0',        // Set this to ensure the response is always fresh
      },
      body: JSON.stringify({
        query: `
          {
            collection(handle: "Patches") {
              products(first: 250${cursor ? `, after: "${cursor}"` : ''}) {
                edges {
                  node {
                    id
                    title
                    variants(first: 50) {
                      edges {
                        node {
                          id
                          title
                          price {
                            amount
                            currencyCode
                          }
                          availableForSale
                        }
                      }
                    }
                  }
                }
                pageInfo {
                  hasNextPage
                  endCursor
                }
              }
            }
          }
        `,
      }),
    });

    const data = await response.json();

    // Check for errors in the response
    if (data.errors) {
      console.error('GraphQL Errors:', data.errors);
      throw new Error('Error fetching products');
    }

    // Check if collection is present
    if (!data.data || !data.data.collection) {
      console.error('Collection not found in the response');
      throw new Error('Collection not found');
    }

    const fetchedProducts = data.data.collection.products.edges;

    // Add fetched products to the array
    products.push(...fetchedProducts);
    console.log(products);
    // Check for more pages
    hasNextPage = data.data.collection.products.pageInfo.hasNextPage;
    cursor = data.data.collection.products.pageInfo.endCursor;
  }

  // Step 2: Extract available variants into the global variable
availableVariants = products.map(product => {
  return {
    productId: product.node.id.split('/').pop(), // Extracts only the numeric part
    productTitle: product.node.title,
    variants: product.node.variants.edges.map(variant => ({
      id: variant.node.id.split('/').pop(), // Extracts only the numeric part
      title: variant.node.title,
      price: variant.node.price,
      available: variant.node.availableForSale,
    })),
  };
});



}

// Use the function to fetch products
fetchAllProducts().catch((error) => {
  console.error('Error fetching products:', error);
});
           // Update DOM elements with fetched data
     const patchesContainer = document.querySelector('.patches');
     const alphabetsContainer = document.querySelector('.alphabets-patches');

document.querySelector('.customization-search-bar').addEventListener('input', function() {
    if (document.querySelector('.alphabets-button').classList.contains('custom-patch-active')) {
       filteralphabets();
    } else {
        filterPatches();
    }
});


    

 function filterPatches() {
   console.log('fileterrrrrr');
    // Get the input value from the search bar
    const inputValue = document.querySelector('.customization-search-bar').value;
    console.log(inputValue);

        $('.patches-toggle').show();
    $('.alphabets-toggle').hide();
    // Determine which data to filter based on the active toggle button
 const dataToFilter = patches;
console.log(dataToFilter);

// Filter the data based on the search value
const filteredData = dataToFilter.filter(item => {
    return item.patchname && item.patchname.toLowerCase().includes(inputValue.toLowerCase());
});

console.log('filterdata',filteredData);

if (filteredData.length > 0) {
    // Clear the patches container only if there is data
    $('#patches-wrapper').empty();

    // Loop through the filtered data and display patches
    filteredData.forEach(item => {
        const availableVariant = availableVariants.find(variant =>
            variant.productId === item.product_id && variant.variants.some(v => v.available)
        );

        // Only create the patch if an available variant is found
        if (availableVariant) {
            const div = document.createElement('div');
            div.setAttribute('draggable', 'true');
            const title = document.createElement('p');
            title.setAttribute('draggable', 'false');
            div.setAttribute('v-id', item.id);
            div.classList.add('patch');
            title.classList.add('patch-title');
            title.textContent = item.patchname || item.alphabetname;

            const img = document.createElement('img');
            img.setAttribute('draggable', 'false');
            img.src = `${item.image}&width=100`;
            img.alt = item.name;
            img.classList.add('patch-image');
            img.setAttribute('crossorigin', 'anonymous');

            // Get the height and width as integers
            let imgHeight = parseInt(item.height, 10);
            let imgWidth = parseInt(item.width, 10);

            const product = {{ product | json }};
            const variantname = document.querySelector('input[name="selective_variant_name"]').value.trim();
            console.log('this is variantname', variantname);

            // Adjust imgHeight and imgWidth based on variantname and productTags
            if (variantname === '1' || variantname === '2' || variantname === '2/3' || variantname === '3/4' || variantname === '4/5' || variantname === '5/6' || 
                variantname === '4' || variantname === '5' || variantname === '6') {
                if (!productTags.includes("happ-velour-set")) {
                    console.log('condition true');
                    imgHeight += 20;
                    imgWidth += 20;
                } else {
                    console.log('condition false');
                    imgHeight -= 10;
                    imgWidth -= 10;
                   // Ensure imgWidth does not go below 20
                    if (imgWidth < 20) {
                        imgWidth = 20;
                    }
                }
            } else if (variantname === '6/7' || variantname === '8' || variantname === '7/8' || variantname === '8/9' ||  
                       variantname === '10' || variantname === '9/10' || variantname === '10/11' || variantname === '11/12' || variantname === '12' || 
                       variantname === '14') {
                if (!productTags.includes("happ-velour-set")) {
                    console.log('condition true');
                    imgHeight += 10;
                    imgWidth += 10;
                } else {
                    console.log('condition false');
                    imgHeight -= 15;
                    imgWidth -= 15;
                   // Ensure imgWidth does not go below 20
                    if (imgWidth < 20) {
                        imgWidth = 20;
                    }
                }
            } else if (variantname === 'Small') {
                console.log('condition true');
                imgHeight += 30;
                imgWidth += 30;
            } else if (variantname === 'Medium') {
                console.log('condition true');
                imgHeight += 20;
                imgWidth += 20;
            } else if (variantname === 'Large') {
                console.log('condition true');
                imgHeight += 10;
                imgWidth += 10;
            }

            if (Array.isArray(product.tags)) {
                if (product.tags.includes('back-pack')) {
                    imgHeight += 35;
                    imgWidth += 35;
                }
                if (product.tags.includes('patch-it-bag')) {
                    if (imgHeight < 30 && imgWidth < 30) {
                        imgHeight += 45;
                        imgWidth += 45;
                    } else if (imgHeight > 30 && imgWidth < 30) {
                        imgHeight += 75;
                        imgWidth += 30;
                    } else {
                        imgHeight += 75;
                        imgWidth += 75;
                    }
                }
            }

            img.height = imgHeight;
            img.width = imgWidth;

            const svgDiv = document.createElement('div');
            svgDiv.classList.add('zoom');
            const svgIcon = document.createElementNS("http://www.w3.org/2000/svg", "svg");
            svgIcon.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
            svgIcon.setAttribute('class', 'h-6 w-6');
            svgIcon.setAttribute('fill', 'none');
            svgIcon.setAttribute('viewBox', '0 0 24 24');
            svgIcon.setAttribute('stroke', 'currentColor');
            svgIcon.innerHTML = '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0zM10 7v3m0 0v3m0-3h3m-3 0H7"></path>';
            svgDiv.appendChild(svgIcon);

            div.appendChild(img);
            div.appendChild(title);
            div.appendChild(svgDiv);

            // Add event listener to the SVG icon to open the pop-up
            svgDiv.addEventListener('click', function() {
                openPopup(item, imgHeight, imgWidth);
            });

            $('#patches-wrapper').append(div);
        }
    });
} 
else {
    // Show a "No matching data found" message
    if (!document.querySelector('#patches-wrapper .no-data-message')) {
       $('#patches-wrapper').empty();
        const noDataMessage = document.createElement('p');
        noDataMessage.textContent = 'No matching data found.';
        noDataMessage.classList.add('no-data-message');
        $('#patches-wrapper').append(noDataMessage);
    }
}


}
 function filteralphabets() {
   console.log('fileterrrrrr');
    // Get the input value from the search bar
    const inputValue = document.querySelector('.customization-search-bar').value;
    console.log(inputValue);

     $('.patches-toggle').hide();
    $('.alphabets-toggle').show();
    // Determine which data to filter based on the active toggle button
 const dataToFilter = alphabets;
console.log('dataToFilter',dataToFilter);

// Filter the data based on the search value
const filteredData = dataToFilter.filter(item => {
    return item.alphabetname && item.alphabetname.toLowerCase().includes(inputValue.toLowerCase());
});

console.log('filterdata',filteredData);

if (filteredData.length > 0) {
  console.log('true');
    // Clear the patches container only if there is data
    $('#alphabets-wrapper').empty();

    // Loop through the filtered data and display patches
    filteredData.forEach(item => {
        const availableVariant = availableVariants.find(variant =>
            variant.productId === item.product_id && variant.variants.some(v => v.available)
        );

        // Only create the patch if an available variant is found
        if (availableVariant) {
            const div = document.createElement('div');
            div.setAttribute('draggable', 'true');
            const title = document.createElement('p');
            title.setAttribute('draggable', 'false');
            div.setAttribute('v-id', item.id);
            div.classList.add('patch');
            title.classList.add('patch-title');
            title.textContent = item.patchname || item.alphabetname;

            const img = document.createElement('img');
            img.setAttribute('draggable', 'false');
            img.src = `${item.image}&width=100`;
            img.alt = item.name;
            img.classList.add('patch-image');
            img.setAttribute('crossorigin', 'anonymous');

            // Get the height and width as integers
            let imgHeight = parseInt(item.height, 10);
            let imgWidth = parseInt(item.width, 10);

            const product = {{ product | json }};
            const variantname = document.querySelector('input[name="selective_variant_name"]').value.trim();
            console.log('this is variantname', variantname);

            // Adjust imgHeight and imgWidth based on variantname and productTags
            if (variantname === '1' || variantname === '2' || variantname === '2/3' || variantname === '3/4' || variantname === '4/5' || variantname === '5/6' || 
                variantname === '4' || variantname === '5' || variantname === '6') {
                if (!productTags.includes("happ-velour-set")) {
                    console.log('condition true');
                    imgHeight += 20;
                    imgWidth += 20;
                } else {
                    console.log('condition false');
                    imgHeight -= 10;
                    imgWidth -= 10;
                   // Ensure imgWidth does not go below 20
                    if (imgWidth < 20) {
                        imgWidth = 20;
                    }
                }
            } else if (variantname === '6/7' || variantname === '8' || variantname === '7/8' || variantname === '8/9' ||  
                       variantname === '10' || variantname === '9/10' || variantname === '10/11' || variantname === '11/12' || variantname === '12' || 
                       variantname === '14') {
                if (!productTags.includes("happ-velour-set")) {
                    console.log('condition true');
                    imgHeight += 10;
                    imgWidth += 10;
                } else {
                    console.log('condition false');
                    imgHeight -= 15;
                    imgWidth -= 15;
                   // Ensure imgWidth does not go below 20
                    if (imgWidth < 20) {
                        imgWidth = 20;
                    }
                }
            } else if (variantname === 'Small') {
                console.log('condition true');
                imgHeight += 30;
                imgWidth += 30;
            } else if (variantname === 'Medium') {
                console.log('condition true');
                imgHeight += 20;
                imgWidth += 20;
            } else if (variantname === 'Large') {
                console.log('condition true');
                imgHeight += 10;
                imgWidth += 10;
            }

            if (Array.isArray(product.tags)) {
                if (product.tags.includes('back-pack')) {
                    imgHeight += 35;
                    imgWidth += 35;
                }
                if (product.tags.includes('patch-it-bag')) {
                    if (imgHeight < 30 && imgWidth < 30) {
                        imgHeight += 45;
                        imgWidth += 45;
                    } else if (imgHeight > 30 && imgWidth < 30) {
                        imgHeight += 75;
                        imgWidth += 30;
                    } else {
                        imgHeight += 75;
                        imgWidth += 75;
                    }
                }
            }

            img.height = imgHeight;
            img.width = imgWidth;

            const svgDiv = document.createElement('div');
            svgDiv.classList.add('zoom');
            const svgIcon = document.createElementNS("http://www.w3.org/2000/svg", "svg");
            svgIcon.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
            svgIcon.setAttribute('class', 'h-6 w-6');
            svgIcon.setAttribute('fill', 'none');
            svgIcon.setAttribute('viewBox', '0 0 24 24');
            svgIcon.setAttribute('stroke', 'currentColor');
            svgIcon.innerHTML = '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0zM10 7v3m0 0v3m0-3h3m-3 0H7"></path>';
            svgDiv.appendChild(svgIcon);

            div.appendChild(img);
            div.appendChild(title);
            div.appendChild(svgDiv);

            // Add event listener to the SVG icon to open the pop-up
            svgDiv.addEventListener('click', function() {
                openPopup(item, imgHeight, imgWidth);
            });

            $('#alphabets-wrapper').append(div);
        }
    });
} 
else {
    // Show a "No matching data found" message
    if (!document.querySelector('.alphabets-patches .no-data-message')) {
       $('#alphabets-wrapper').empty();
        const noDataMessage = document.createElement('p');
        noDataMessage.textContent = 'No matching data found.';
        noDataMessage.classList.add('no-data-message');
        $('#alphabets-wrapper').append(noDataMessage);
    }
}


}
// function filterPatches(){
//   console.log('j');
// }

      
       // showPatches();

 $('#patches-button').click(function(){
     $(this).addClass('custom-patch-active'); 
     $('#alphabets-button').removeClass('custom-patch-active');
    $('.customization-search-bar').attr('placeholder', 'Search Patches');
     showPatches();
   filterPatches();
 });
 
 // Event listener for the "Alphabets" button
 $('#alphabets-button').click(function(){
     $(this).addClass('custom-patch-active');
     $('#patches-button').removeClass('custom-patch-active');
    $('.customization-search-bar').attr('placeholder', 'Search Alphabets');

     showAlphabets();
   filteralphabets();
 });
 
   // Function to show patches
      // old showpatches
//   function showPatches() {
//     // Clear existing content in the patches container
//     $('.patches').empty();

//     // Loop through the patches data and display patches
//     patches.forEach(item => {
//         const patchDiv = document.createElement('div');
//         patchDiv.setAttribute('draggable', 'true');
//         patchDiv.setAttribute('v-id', item.id);
//         patchDiv.classList.add('patch');

//         const title = document.createElement('p');
//         title.setAttribute('draggable', 'false');
//         title.classList.add('patch-title');
//         title.textContent = item.patchname;

//         const img = document.createElement('img');
//         img.setAttribute('draggable', 'false');
//         img.src = item.image;
//         img.alt = item.name;
//         img.classList.add('patch-image');
//         img.setAttribute('crossorigin', 'anonymous');
//         img.height = item.height;
//         img.width = item.width;

//         const svgDiv = document.createElement('div');
//         svgDiv.classList.add('zoom');
//         const svgIcon = document.createElementNS("http://www.w3.org/2000/svg", "svg");
//         svgIcon.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
//         svgIcon.setAttribute('class', 'h-6 w-6');
//         svgIcon.setAttribute('fill', 'none');
//         svgIcon.setAttribute('viewBox', '0 0 24 24');
//         svgIcon.setAttribute('stroke', 'currentColor');
//         svgIcon.innerHTML = '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0zM10 7v3m0 0v3m0-3h3m-3 0H7"></path>';
//         svgDiv.appendChild(svgIcon);

//         patchDiv.appendChild(img);
//         patchDiv.appendChild(title);
//         patchDiv.appendChild(svgDiv);

//         // Add event listener to the SVG icon to open the pop-up
//         svgDiv.addEventListener('click', function() {
//             openPopup(item);
//         });

//         $('.patches').append(patchDiv);
//     });
// }
        // Get the value of Shopify.shop


// Step 3: Use availableVariants directly in showPatches
function showPatches() {
  console.log('showPatches',availableVariants);
  // // Clear existing content in the patches container

       $('.patches-toggle').show();
    $('.alphabets-toggle').hide();
  // Loop through the patches data and display patches
  patches.forEach(item => {
    // Check if the item has a matching available variant
    const availableVariant = availableVariants.find(variant =>
      variant.productId === item.product_id && variant.variants.some(v => v.available)
    );

    // Only proceed if the variant is available
    if (availableVariant) {
      const patchDiv = document.createElement('div');
      patchDiv.setAttribute('draggable', 'true');
      patchDiv.setAttribute('v-id', item.id);
      patchDiv.classList.add('patch');

      const title = document.createElement('p');
      title.setAttribute('draggable', 'false');
      title.classList.add('patch-title');
      title.textContent = item.patchname;

      const img = document.createElement('img');
      img.setAttribute('draggable', 'false');
      img.src = `${item.image}&width=100`;
      img.alt = item.name;
      img.classList.add('patch-image');
      img.setAttribute('crossorigin', 'anonymous');

     // Get the height and width as integers
            let imgHeight = parseInt(item.height, 10);
            let imgWidth = parseInt(item.width, 10);

            const product = {{ product | json }};
            const variantname = document.querySelector('input[name="selective_variant_name"]').value.trim();
            console.log('this is variantname', variantname);

            // Adjust imgHeight and imgWidth based on variantname and productTags
            if (variantname === '1' || variantname === '2' || variantname === '2/3' || variantname === '3/4' || variantname === '4/5' || variantname === '5/6' || 
                variantname === '4' || variantname === '5' || variantname === '6') {
                if (!productTags.includes("happ-velour-set")) {
                    console.log('condition true');
                    imgHeight += 20;
                    imgWidth += 20;
                } else {
                    console.log('condition false');
                    imgHeight -= 10;
                    imgWidth -= 10;
                   // Ensure imgWidth does not go below 20
                    if (imgWidth < 20) {
                        imgWidth = 20;
                    }
                }
            } else if (variantname === '6/7' || variantname === '8' || variantname === '7/8' || variantname === '8/9' ||  
                       variantname === '10' || variantname === '9/10' || variantname === '10/11' || variantname === '11/12' || variantname === '12' || 
                       variantname === '14') {
                if (!productTags.includes("happ-velour-set")) {
                    console.log('condition true');
                    imgHeight += 10;
                    imgWidth += 10;
                } else {
                    console.log('condition false');
                    imgHeight -= 15;
                    imgWidth -= 15;
                   // Ensure imgWidth does not go below 20
                    if (imgWidth < 20) {
                        imgWidth = 20;
                    }
                }
            } else if (variantname === 'Small') {
                console.log('condition true');
                imgHeight += 30;
                imgWidth += 30;
            } else if (variantname === 'Medium') {
                console.log('condition true');
                imgHeight += 20;
                imgWidth += 20;
            } else if (variantname === 'Large') {
                console.log('condition true');
                imgHeight += 10;
                imgWidth += 10;
            }

            if (Array.isArray(product.tags)) {
                if (product.tags.includes('back-pack')) {
                    imgHeight += 35;
                    imgWidth += 35;
                }
                if (product.tags.includes('patch-it-bag')) {
                    if (imgHeight < 30 && imgWidth < 30) {
                        imgHeight += 45;
                        imgWidth += 45;
                    } else if (imgHeight > 30 && imgWidth < 30) {
                        imgHeight += 75;
                        imgWidth += 30;
                    } else {
                        imgHeight += 75;
                        imgWidth += 75;
                    }
                }
            }

            img.height = imgHeight;
            img.width = imgWidth;
      const svgDiv = document.createElement('div');
      svgDiv.classList.add('zoom');
      const svgIcon = document.createElementNS("http://www.w3.org/2000/svg", "svg");
      svgIcon.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
      svgIcon.setAttribute('class', 'h-6 w-6');
      svgIcon.setAttribute('fill', 'none');
      svgIcon.setAttribute('viewBox', '0 0 24 24');
      svgIcon.setAttribute('stroke', 'currentColor');
      svgIcon.innerHTML = '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0zM10 7v3m0 0v3m0-3h3m-3 0H7"></path>';
      svgDiv.appendChild(svgIcon);

      patchDiv.appendChild(img);
      patchDiv.appendChild(title);
      patchDiv.appendChild(svgDiv);

      // Add event listener to the SVG icon to open the pop-up
      svgDiv.addEventListener('click', function() {
          openPopup(item, imgHeight, imgWidth);
      });

      $('#patches-wrapper').append(patchDiv);
    }
    else{
      console.log('no this is not available');
    }
  });
}


$('.variants-continue-btn').click(function() {
    // Check if the product has 'none-size-products' tag
    if (Array.isArray(product.tags) && product.tags.includes('none-size-products')) {
        // Skip size variant checks and directly show the loader
        showPatches();
        console.log('continue to next moment');

        // Show the loader
        $('.loader-cart-contiune').css('display', 'block');

        // Hide the continue button and change the background color of the wrapper
        $('.variants-continue-btn').css('display', 'none');
        $('.variants-continue-btn-wrapper').css('background-color', 'rgb(223, 223, 223)');

        // Set a timeout for 1 second for the loader to be visible
        setTimeout(function() {
            // Hide the loader after 1 second
            $('.loader-cart-contiune').css('display', 'none');

            // Change background color back to #ffe2e8
            $('.variants-continue-btn-wrapper').css('background-color', '#ffe2e8');

            // Show the continue button again
            $('.variants-continue-btn').css('display', 'block');

            // Additional logic can continue here if needed...
            $('.patches-tidy-editor-btn').css('display', 'block');

            // Add the class to the sidebar
            $('.variants-selected-sidebar').addClass('variants-continue-btn-invisible');

            // Handle responsive display changes
            if (window.matchMedia("(max-width: 769px)").matches) {
                $('.patches-editor-wrapper').css('display', 'flex');
            } else {
                $('.patches-tidy-editor-btn').css('visibility', 'hidden');
                $('.patches-editor-wrapper').css('display', 'block');
            }

            $('.size_variants_errors').css('display', 'none');

            if (window.matchMedia("(max-width: 768px)").matches) {
                $('.only-mobile').css('display', 'none');
            }

            if (window.matchMedia("(max-width: 768px)").matches) {
                $('.only-mobile-colors-wrapper').css('display', 'block');
            } else {
                $('.only-mobile-colors-wrapper').css('display', 'none');
            }

        }, 1000); // 1 second delay for loader

    } else {
        // Check if size variants are active only if product doesn't have 'none-size-products' tag
        if ($('.size_variants_circle').hasClass('size_variants_active')) {
            showPatches();
            console.log('continue to next moment');

            // Show the loader
            $('.loader-cart-contiune').css('display', 'block');

            // Hide the continue button and change the background color of the wrapper
            $('.variants-continue-btn').css('display', 'none');
            $('.variants-continue-btn-wrapper').css('background-color', 'rgb(223, 223, 223)');

            // Set a timeout for 1 second for the loader to be visible
            setTimeout(function() {
                // Hide the loader after 1 second
                $('.loader-cart-contiune').css('display', 'none');

                // Change background color back to #ffe2e8
                $('.variants-continue-btn-wrapper').css('background-color', '#ffe2e8');

                // Show the continue button again
                $('.variants-continue-btn').css('display', 'block');

                // Additional logic can continue here if needed...
                $('.patches-tidy-editor-btn').css('display', 'block');

                // Add the class to the sidebar
                $('.variants-selected-sidebar').addClass('variants-continue-btn-invisible');

                // Handle responsive display changes
                if (window.matchMedia("(max-width: 769px)").matches) {
                    $('.patches-editor-wrapper').css('display', 'flex');
                } else {
                    $('.patches-tidy-editor-btn').css('visibility', 'hidden');
                    $('.patches-editor-wrapper').css('display', 'block');
                }

                $('.size_variants_errors').css('display', 'none');

                if (window.matchMedia("(max-width: 768px)").matches) {
                    $('.only-mobile').css('display', 'none');
                }

                if (window.matchMedia("(max-width: 768px)").matches) {
                    $('.only-mobile-colors-wrapper').css('display', 'block');
                } else {
                    $('.only-mobile-colors-wrapper').css('display', 'none');
                }

            }, 1000); // 1 second delay for loader
        } else {
            // Show the error div if no active size variant is selected
            $('.size_variants_errors').css('display', 'block');
        }
    }
});




// function openPopup(item) {
//     console.log("Opening popup for item:", item);
//      const popup = document.querySelector('.popup');
//     if (popup) {
//         popup.classList.add('active');
//         return; // Popup is already open, no need to create a new one
//     }

//     // Create the pop-up content
//     const popupContent = `
//         <div class="popup active">
//            <div class="popup-close"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" width="30" height="30"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg></div>
//             <div class="patch-pop_up-image-wrapper">
//             <img src="${item.image}" alt="${item.name}"  class="popup-image" />
//             </div>
//             <p class="popup-name">${item.patchname || item.alphabetname}</p>
//            <div class="add-patch-pop-up-btn" data-patch-src-popup="${item.image}" data-patch-id-popup="${item.id}" data-patch-height-popup="${item.height}" data-patch-width-popup="${item.width}">Add Patch</div>

//         </div>
//     `;

//     // Append the pop-up content to the body
//     document.body.insertAdjacentHTML('beforeend', popupContent);

//     // Add event listener to close the pop-up when clicking on the close button
//     document.querySelector('.popup-close').addEventListener('click', function() {
//         console.log("Close button clicked");
//         closePopup();
//     });




// }

function openPopup(item,imgHeight,imgWidth) {
    console.log("Opening popup for item:", item,imgHeight,imgWidth);


    // Adjust dimensions based on product tags
    const product = {{ product | json }}; // Ensure this variable is set correctly

    // Check if the popup is already open
    const existingPopup = document.querySelector('.popup');
    if (existingPopup) {
        existingPopup.classList.add('active');
        return; // Popup is already open, no need to create a new one
    }

    // Create the pop-up content with adjusted dimensions
    const popupContent = `
        <div class="popup active">
           <div class="popup-close">
               <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" width="30" height="30">
                   <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
               </svg>
           </div>
            <div class="patch-pop_up-image-wrapper">
                <img src="${item.image}" alt="${item.name}" class="popup-image" />
            </div>
            <p class="popup-name">${item.patchname || item.alphabetname}</p>
            <div class="add-patch-pop-up-btn" 
                 data-patch-src-popup="${item.image}" 
                 data-patch-id-popup="${item.id}" 
                 data-patch-height-popup="${imgHeight}" 
                 data-patch-width-popup="${imgWidth}">
                Add Patch
            </div>
        </div>
    `;

    // Append the pop-up content to the body
    document.body.insertAdjacentHTML('beforeend', popupContent);

    // Add event listener to close the pop-up when clicking on the close button
    document.querySelector('.popup-close').addEventListener('click', function() {
        console.log("Close button clicked");
        closePopup();
    });
}

function closePopup() {
  console.log('close the pop up');
    const popup = document.querySelector('.popup');
    if (popup) {
        popup.classList.add('fade-out');
        popup.classList.remove('active');
        setTimeout(() => {
            popup.remove();
        }, 300); // Wait for the transition to finish before removing the pop-up
    }
}

 
 
   // Function to show alphabets
      // old alphabets
 function showAlphabets() {
console.log('showAlphabets',availableVariants);
    // // Clear existing content in the patches container
    // $('.patches').empty();
  //   $('#patches-wrapper').css('visibility', 'hidden');
  // $('.alphabets-patches').css('visibility', 'visible');
        $('.patches-toggle').hide();
    $('.alphabets-toggle').show();
    // Loop through the patches data and display patches
    alphabets.forEach(item => {
      // Check if the item has a matching available variant
      const availableVariant = availableVariants.find(variant =>
        variant.productId === item.product_id && variant.variants.some(v => v.available)
      );
  
      // Only proceed if the variant is available
      if (availableVariant) {
        const patchDiv = document.createElement('div');
        patchDiv.setAttribute('draggable', 'true');
        patchDiv.setAttribute('v-id', item.id);
        patchDiv.classList.add('patch');
  
        const title = document.createElement('p');
        title.setAttribute('draggable', 'false');
        title.classList.add('patch-title');
        title.textContent = item.patchname;
  
        const img = document.createElement('img');
        img.setAttribute('draggable', 'false');
        img.src = `${item.image}&width=100`;
        img.alt = item.name;
        img.classList.add('patch-image');
        img.setAttribute('crossorigin', 'anonymous');
  
       // Get the height and width as integers
              let imgHeight = parseInt(item.height, 10);
              let imgWidth = parseInt(item.width, 10);
  
              const product = {{ product | json }};
              const variantname = document.querySelector('input[name="selective_variant_name"]').value.trim();
              console.log('this is variantname', variantname);
  
              // Adjust imgHeight and imgWidth based on variantname and productTags
              if (variantname === '1' || variantname === '2' || variantname === '2/3' || variantname === '3/4' || variantname === '4/5' || variantname === '5/6' || 
                  variantname === '4' || variantname === '5' || variantname === '6') {
                  if (!productTags.includes("happ-velour-set")) {
                      console.log('condition true');
                      imgHeight += 20;
                      imgWidth += 20;
                  } else {
                      console.log('condition false');
                      imgHeight -= 10;
                      imgWidth -= 10;
                     // Ensure imgWidth does not go below 20
                      if (imgWidth < 20) {
                          imgWidth = 20;
                      }
                  }
              } else if (variantname === '6/7' || variantname === '8' || variantname === '7/8' || variantname === '8/9' ||  
                         variantname === '10' || variantname === '9/10' || variantname === '10/11' || variantname === '11/12' || variantname === '12' || 
                         variantname === '14') {
                  if (!productTags.includes("happ-velour-set")) {
                      console.log('condition true');
                      imgHeight += 10;
                      imgWidth += 10;
                  } else {
                      console.log('condition false');
                      imgHeight -= 15;
                      imgWidth -= 15;
                     // Ensure imgWidth does not go below 20
                      if (imgWidth < 20) {
                          imgWidth = 20;
                      }
                  }
              } else if (variantname === 'Small') {
                  console.log('condition true');
                  imgHeight += 30;
                  imgWidth += 30;
              } else if (variantname === 'Medium') {
                  console.log('condition true');
                  imgHeight += 20;
                  imgWidth += 20;
              } else if (variantname === 'Large') {
                  console.log('condition true');
                  imgHeight += 10;
                  imgWidth += 10;
              }
  
              if (Array.isArray(product.tags)) {
                  if (product.tags.includes('back-pack')) {
                      imgHeight += 35;
                      imgWidth += 35;
                  }
                  if (product.tags.includes('patch-it-bag')) {
                      if (imgHeight < 30 && imgWidth < 30) {
                          imgHeight += 45;
                          imgWidth += 45;
                      } else if (imgHeight > 30 && imgWidth < 30) {
                          imgHeight += 75;
                          imgWidth += 30;
                      } else {
                          imgHeight += 75;
                          imgWidth += 75;
                      }
                  }
              }
  
              img.height = imgHeight;
              img.width = imgWidth;
        const svgDiv = document.createElement('div');
        svgDiv.classList.add('zoom');
        const svgIcon = document.createElementNS("http://www.w3.org/2000/svg", "svg");
        svgIcon.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
        svgIcon.setAttribute('class', 'h-6 w-6');
        svgIcon.setAttribute('fill', 'none');
        svgIcon.setAttribute('viewBox', '0 0 24 24');
        svgIcon.setAttribute('stroke', 'currentColor');
        svgIcon.innerHTML = '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0zM10 7v3m0 0v3m0-3h3m-3 0H7"></path>';
        svgDiv.appendChild(svgIcon);
  
        patchDiv.appendChild(img);
        patchDiv.appendChild(title);
        patchDiv.appendChild(svgDiv);
  
        // Add event listener to the SVG icon to open the pop-up
        svgDiv.addEventListener('click', function() {
            openPopup(item, imgHeight, imgWidth);
        });
  
        $('#alphabets-wrapper').append(patchDiv);
      }
      else{
        console.log('no this is not available');
      }
    });
}

 });
 
 
    
    
function showcolorVariants() {
    console.log('This is color variants', colorVariants);

    const product = {{ product | json }};

    // Clear any existing color variants
    const sidebarBtn = document.querySelector('.variant-selector-sidebar-btn');
    sidebarBtn.innerHTML = '';

    let firstColorVariant; // Variable to store the first color variant div

    // Iterate over the product variants
    product.variants.forEach(variant => {
        // Check if the current variant matches any color variant
        colorVariants.forEach(colorVariant => {
            // Check if the product contains the tag "back-pack"
            const productTags = {{ product.tags | json }};
            if (productTags.includes("none-size-products")) {
              console.log('non size'); 
              if (colorVariant.id.toString() === variant.id.toString()){
                     const matchingVariants = product.variants.filter(variant => {
    return variant.title.toLowerCase().includes(colorVariant.colorname.toLowerCase());
});

console.log('matchingVariantsBack Pack',matchingVariants);
          let isAvailable = matchingVariants.length > 0 && matchingVariants[0].available;

if (isAvailable) {
    console.log("The variant is available.");
    console.log('back-pack');
   // Create a new div for each color variant
   const parentDiv = document.createElement('div');
   parentDiv.classList.add('parent-variant-wrapper');
   const newDiv = document.createElement('div');
   newDiv.style.backgroundColor = colorVariant.Variants;
   newDiv.classList.add('color-variant');
   newDiv.setAttribute('color-title', colorVariant.colorname);
   console.log(document.getElementById('Front-image'));
   console.log(colorVariant.productImg);
   // Set the images for the front and back
 

   // Add click event listener to each div
   newDiv.addEventListener('click', () => {
   // Remove the class from all color-variant divs
   document.querySelectorAll('.color-variant').forEach((div) => {
       div.classList.remove('selected-variant');
   });

   // Add the class to the clicked div
   newDiv.classList.add('selected-variant');
   const colorTitle = newDiv.getAttribute('color-title');
   console.log('colorTitle', colorTitle);

   // Update the content of the .color_selector_heading div
   const colorSelectorHeading = document.querySelector('.color_selector_heading');
     console.log(colorSelectorHeading)
   if (colorSelectorHeading) {
     console.log('yes its existes colorSelectorHeading')
       colorSelectorHeading.textContent = colorTitle;
   }

   // Find the matching variant
   const matchingVariant = product.variants.find(variant =>
       variant.title.toLowerCase().includes(colorTitle.toLowerCase())
   );

   if (matchingVariant) {
       // Update the input value with the matching variant ID
       const hiddenInput = document.querySelector('input[name="selective_variant_ID"]');
       if (hiddenInput) {
           hiddenInput.value = matchingVariant.id;
       }
   }

   // Set the src attribute of the image with id "Front-image" and "Back-image"
   document.getElementById('Front-image').src = colorVariant.productImg;
   document.getElementById('Back-image').src = colorVariant.backImg;
});


   // Append the new div to the div with class "variant-selector-sidebar-btn"
   parentDiv.appendChild(newDiv);
   sidebarBtn.appendChild(parentDiv);

   // Store the first color variant div
   if (!firstColorVariant) {
       firstColorVariant = newDiv;
   }
} else {
    console.log("The variant is not available.");
    // Perform actions if the condition is false
}
              }
            } 
            
            else {
              console.log('size product'); 
                                      // Assuming variants is an array of variant objects

 if (colorVariant.id.toString() === variant.id.toString()) {
                   const matchingVariants = product.variants.filter(variant => {
    return variant.title.toLowerCase().includes(colorVariant.colorname.toLowerCase());
});

console.log('matchingVariants',matchingVariants);
// Check if any of the matching variants are available
const isAnyVariantAvailable = matchingVariants.some(variant => variant.available);

if (isAnyVariantAvailable) {
    console.log('At least one variant is available.');
   
                          // Create a new div for each color variant
                    const parentDiv = document.createElement('div');
                    parentDiv.classList.add('parent-variant-wrapper');
                    const newDiv = document.createElement('div');
                    if (productTags.includes("gardient-patch-background")) {
                      console.log(newDiv,'gardient-patch-background');
    newDiv.style.backgroundImage = 'radial-gradient(circle, rgba(223, 221, 157, 1) 0%, rgba(238, 96, 183, 1) 35%, rgba(165, 134, 222, 1) 100%)';
} else {
    newDiv.style.backgroundColor = colorVariant.Variants;
}
                    newDiv.classList.add('color-variant');
                    newDiv.setAttribute('color-title', colorVariant.colorname);

                    // Set the images for the front and back
                    document.getElementById('Front-image').src = colorVariant.productImg;
                    document.getElementById('Back-image').src = colorVariant.backImg;

                    // Add click event listener to each div
                    newDiv.addEventListener('click', () => {
                        // Remove the class from all color-variant divs
                        document.querySelectorAll('.color-variant').forEach((div) => {
                            div.classList.remove('selected-variant');
                        });
                        
                        // Add the class to the clicked div
                        newDiv.classList.add('selected-variant');
                        const colorTitle = newDiv.getAttribute('color-title');
                        console.log('colorTitle', colorTitle);
                           const colorSelectorHeading = document.querySelector('.color_selector_heading');
     console.log(colorSelectorHeading)
   if (colorSelectorHeading) {
     console.log('yes its existes colorSelectorHeading')
       colorSelectorHeading.textContent = colorTitle;
   }
                               const sizeSelectorHeading = document.querySelector('.size_selector_heading');
     console.log(sizeSelectorHeading)
   if (sizeSelectorHeading) {
     console.log('yes its existes colorSelectorHeading')
       sizeSelectorHeading.textContent = '';
   }
                        // Call createVariantDivs if not a "back-pack"
                        createVariantDivs(colorTitle);

                        // Set the src attribute of the image with id "Front-image" and "Back-image"
                        document.getElementById('Front-image').src = colorVariant.productImg;
                        document.getElementById('Back-image').src = colorVariant.backImg;
                    });

                    // Append the new div to the div with class "variant-selector-sidebar-btn"
                    parentDiv.appendChild(newDiv);
                    sidebarBtn.appendChild(parentDiv);

                    // Store the first color variant div
                    if (!firstColorVariant) {
                        firstColorVariant = newDiv;
                    }

} else {
    console.log('All variants are unavailable.');
    // Condition becomes false
}
                      }
                  
            }
        });
    });


    // Automatically move the first color variant to createVariantDivs
    if (firstColorVariant) {
        console.log('firstColorVariant');
        firstColorVariant.classList.add('selected-variant');
        // document.getElementById('Front-image').src = colorVariant.productImg;
        // document.getElementById('Back-image').src = colorVariant.backImg;
        const colorTitle = firstColorVariant.getAttribute('color-title');
        console.log('First color variant', colorTitle);
    const colorSelectorHeading = document.querySelector('.color_selector_heading');
     console.log(colorSelectorHeading)
   if (colorSelectorHeading) {
     console.log('yes its existes colorSelectorHeading')
       colorSelectorHeading.textContent = colorTitle;
   }
        const productTags = {{ product.tags | json }};
        if (!productTags.includes("none-size-products")) {
            createVariantDivs(colorTitle);
        } 
        else {
          $('.size_variants_section').css('visibility', 'hidden');
            // If it's a back-pack, find the matching variant
            const matchingVariant = product.variants.find((variant) =>
                variant.title.toLowerCase().includes(colorTitle.toLowerCase())
            );

            if (matchingVariant) {
                // Update the input value with the matching variant ID
                const hiddenInput = document.querySelector('input[name="selective_variant_ID"]');
                if (hiddenInput) {
                    hiddenInput.value = matchingVariant.id;
                }
            }
        }
        console.log('colorVariants:', colorVariants);
        console.log('colorTitle',colorTitle)

// Step 1: Find all color variants that match the title
const matchingColorVariants = colorVariants.filter(colorVariant => 
    colorVariant.colorname &&
    colorTitle &&
    colorVariant.colorname.toLowerCase() === colorTitle.toLowerCase()
);

console.log('matchingColorVariants', matchingColorVariants);

// Step 2: From the matching color variants, find the one where the IDs match
const firstColorVariantData = matchingColorVariants.find(colorVariant => 
    product.variants.some(variant =>
        variant.id.toString() === colorVariant.id.toString()
    )
);

console.log('firstColorVariantData', firstColorVariantData);

if (firstColorVariantData) {
    console.log('yes i am under ', firstColorVariantData.productImg);
    
    // Set the src attribute of the images with the found color variant data
    document.getElementById('Front-image').src = firstColorVariantData.productImg;
    document.getElementById('Back-image').src = firstColorVariantData.backImg;
}

    }
} 


// Function to create variant divs based on the color-title
function createVariantDivs(colorTitle) {
  const product2 = {{ product | json }};
  const variantsContainer = document.getElementById('variants-containers');
  
  // Clear existing variant divs
  variantsContainer.innerHTML = '';

  // Filter and create divs for matching variants
  product2.variants.forEach(variant => {
    if (
      variant.title.toLowerCase().includes(colorTitle.toLowerCase()) &&
      variant.available
    ) {
      const variantDiv = document.createElement('div');
      variantDiv.textContent = variant.option1;
      variantDiv.setAttribute('data-v-id', variant.id);
      variantDiv.classList.add('select_size', 'size_variants_circle', 'size_variants');
      variantsContainer.appendChild(variantDiv);

      // Add click event listener to each dynamically created div
      variantDiv.addEventListener('click', () => {
    // Remove 'size_variants_active' class from all '.select_size' divs
    const allSelectSizeDivs = document.querySelectorAll('.select_size');
    allSelectSizeDivs.forEach(div => {
        div.classList.remove('size_variants_active');
    });

    // Hide any size variant errors
    $('.size_variants_errors').css('display', 'none');

    // Add 'size_variants_active' class to the clicked div
    variantDiv.classList.add('size_variants_active');

    // Update the colorSelectorHeading with the variant option1
    const colorSelectorHeading = document.querySelector('.size_selector_heading');
    if (colorSelectorHeading) {
        colorSelectorHeading.textContent = variant.option1;
    }

    // Get the value of the data-v-id attribute
    const vId = variantDiv.getAttribute('data-v-id');
    console.log('vId', vId);

    // Update the value of the hidden input with id 'selective_variant_ID'
    const hiddenInput = document.getElementById('selective_variant_ID');
    if (hiddenInput) {
        hiddenInput.value = vId;
    }

    // Get the text content of the clicked div and assign it to the hidden input 'selective_variant_name'
    const clickedDivText = variantDiv.textContent.trim(); // Get the text of the clicked div
    const hiddenNameInput = document.getElementById('selective_variant_name');
    if (hiddenNameInput) {
        hiddenNameInput.value = clickedDivText; // Set the text content as the value of the hidden input
    }
});

    }
  });
}


//        function showSizeVariants() {
//     console.log('This is size variants');

//     const product = {{ product | json }};

//     // Clear any existing hidden classes
//     document.getElementById('small_variant').classList.remove("hide_size_variants");
//     document.getElementById('medium_variant').classList.remove("hide_size_variants");
//     document.getElementById('large_variant').classList.remove("hide_size_variants");
//     document.getElementById('extra_large_variant').classList.remove("hide_size_variants");

//     // Iterate over the product variants
//     product.variants.forEach(variant => {
//         console.log('Variant ID:', variant.id);

//         // Check each sizeVariant against the current product variant
//         sizeVariants.forEach(sizeVariant => {
//             if (sizeVariant.id.toString() === variant.id.toString()) {
//                 if (sizeVariant.Smalll === "false") {
//                     const small = document.getElementById('small_variant');
//                     small.classList.add("hide_size_variants");
//                 }
//                 if (sizeVariant.Medium === "false") {
//                     const medium = document.getElementById('medium_variant');
//                     medium.classList.add("hide_size_variants");
//                 }
//                 if (sizeVariant.Large === "false") {
//                     const large = document.getElementById('large_variant');
//                     large.classList.add("hide_size_variants");
//                 }
//                 if (sizeVariant.Extra_Large === "false") {
//                     const extraLarge = document.getElementById('extra_large_variant');
//                     extraLarge.classList.add("hide_size_variants");
//                 }
//             }
//         });
//     });
// }
$('.size_variants').click(function() {
                // Remove 'size_variants_active' class from all elements with 'size_variants' class
                $('.size_variants').removeClass('size_variants_active');
                // Add 'size_variants_active' class to the clicked element
                $(this).addClass('size_variants_active');
                // Update hidden input value with the id of the clicked element
               $('#size_variants_data').val($(this).text());
            });
  
     //new front image

     function showFrontImage() {
    const product = {{ product | json }};
    
    // Iterate over the variants to find the relevant image data
    let currentImageData = null;

    product.variants.some(variant => {
    console.log('Variant ID:', variant.id);
    console.log('Images Data:', imagesData);

    currentImageData = imagesData.find(item => item.FproductId.toString() === variant.id.toString());
    console.log('Found Image Data:', currentImageData);

    // Return true to stop the loop after finding the first match
    return currentImageData !== undefined;
});


    console.log('Final currentImageData:', currentImageData);

    // Update the image source and CSS properties if data is found
    if (currentImageData) {
        const img = document.getElementById("Front-image");
       let originalUrl = currentImageData.FProductImg;
img.src = currentImageData.FProductImg.replace('/upload/', '/upload/w_100/');
        // Update CSS properties of #centerBox
        const centerBox = document.getElementById("centerBox");
        centerBox.style.height = currentImageData.FHeight + '%';
        centerBox.style.width = currentImageData.FWidth + '%';
        centerBox.style.top = currentImageData.FTop + '%';
        centerBox.style.left = currentImageData.FLeft + '%';
    }
}

  //old back image   
// function showBackImage() {
//    // Get the variant ID
//    const variantId = "{{variant.id}}"; // Replace "{{variant.id}}" with your actual variant ID

//    // Find the image data for the current variant
//    const currentImageData = imagesData.find(item => item.FproductId === variantId);

//    // Update the image source and CSS properties if data is found
//    if (currentImageData) {
//      const img = document.getElementById("Back-image");
//      img.src = currentImageData.Backimg;

//      // Check if Backimg is empty and hide the div if it is
//      const patchesWrapper = document.querySelector(".patches-customizations-btn-wrapper");
//      const sizevariantscontaier = document.querySelector(".size_variants_section");
//      if (!currentImageData.Backimg) {
//        patchesWrapper.style.visibility = "hidden";
//        sizevariantscontaier.style.visibility = "hidden";
//      } else {
//        patchesWrapper.style.visibility = "visible";
//        sizevariantscontaier.style.visibility = "visible";
//      }

//      // Update CSS properties of #centerBox
//      const centerBox = document.getElementById("BackcenterBox");
//      centerBox.style.height = currentImageData.BHeight + '%';
//      centerBox.style.width = currentImageData.BWidth + '%';
//      centerBox.style.top = currentImageData.BTop + '%';
//      centerBox.style.left = currentImageData.BLeft + '%';
//    }
// }
 //new back image
function showBackImage() {
   // Get the variant ID
   const variantId = "{{variant.id}}"; // Replace "{{variant.id}}" with your actual variant ID

    let currentImageData = null;

    product.variants.some(variant => {
    console.log('Variant ID:', variant.id);
    console.log('Images Data:', imagesData);

    currentImageData = imagesData.find(item => item.FproductId.toString() === variant.id.toString());
    console.log('Found Image Data:', currentImageData);

    // Return true to stop the loop after finding the first match
    return currentImageData !== undefined;
});

   // Update the image source and CSS properties if data is found
   if (currentImageData) {
     const img = document.getElementById("Back-image");
     img.src = currentImageData.Backimg;

     // Check if Backimg is empty and hide the div if it is
       const productTags = {{ product.tags | json }};
     const patchesWrapper = document.querySelector(".patches-customizations-btn-wrapper");
     const sizevariantscontaier = document.querySelector(".size_variants_section");
      if (productTags.includes("happ-velour-set")){
          patchesWrapper.style.visibility = "hidden"; 
          sizevariantscontaier.style.visibility = "visible";
      }
     else{
            if (!currentImageData.Backimg) {
    patchesWrapper.style.visibility = "hidden";
    sizevariantscontaier.style.visibility = "hidden";
} else {
    patchesWrapper.style.visibility = "visible";
    sizevariantscontaier.style.visibility = "visible";
}

     }


     // Update CSS properties of #centerBox
     const centerBox = document.getElementById("BackcenterBox");
     centerBox.style.height = currentImageData.BHeight + '%';
     centerBox.style.width = currentImageData.BWidth + '%';
     centerBox.style.top = currentImageData.BTop + '%';
     centerBox.style.left = currentImageData.BLeft + '%';
   }
}
   })
   .catch(error => {
     // Handle errors
     console.error('Error fetching data:', error);
   });
</script>

<!--
  <script>
    async function uploadBlob(pngImageURL, inputSelector) {
      // Fetch the image URL
      const response = await fetch(pngImageURL);

      // Convert the fetched response to a blob
      const blob = await response.blob();

      // Use FormData to prepare the data for sending
      const formData = new FormData();
      formData.append('image', blob, 'upload.png');

      // Send the FormData to the server
      const result = await fetch('http://localhost:3900/check', {
        method: 'POST',
        body: formData
      });

      // Assuming the server responds with JSON
      const jsonResponse = await result.json();
      console.log(jsonResponse);

      // Update the value of the input field with the file URL
      if (jsonResponse && jsonResponse.fileUrl) {
        document.querySelector(inputSelector).value = jsonResponse.fileUrl;
      } else {
        console.error('File URL not found in the response');
      }
    }
  </script>
-->
<!-- drag and drop code -->
<script>
const canvas = document.getElementById('imageDiv');
const centerBox = document.getElementById('centerBox');
const BackcenterBox = document.getElementById('BackcenterBox');
let patches = [];
let isDragging = false;
let isDraggingByPatch = false;

let dragPatch = null;
let dragPatch1 = null;
let offsetX = 0;
let offsetY = 0;


// function convertToPng() {
//     BackconvertToPng();
//     FrontconvertToPng();
//     // addTocartcustpatch(); // Call your function here
// }

// function BackconvertToPng() {
//     var imageDiv = document.getElementById('BackimageDiv');
//     var patches = imageDiv.querySelectorAll('.patch- img'); // Correct the query selector for patches
//     var canvas = document.createElement('canvas');
//     var ctx = canvas.getContext('2d');

//     // Set canvas size to match the containing div's size
//     var imageDivRect = imageDiv.getBoundingClientRect();
//     canvas.width = imageDivRect.width;
//     canvas.height = imageDivRect.height;

//     // Draw the main image on the canvas with object-fit: contain
//     var sourceImage = document.getElementById('Back-image');
//     if (!sourceImage) {
//         console.error('Source image not found');
//         return;
//     }

//     // Calculate dimensions and position based on object-fit: contain
//     var containerAspectRatio = canvas.width / canvas.height;
//     var imageAspectRatio = sourceImage.naturalWidth / sourceImage.naturalHeight;

//     var sourceWidth, sourceHeight, sourcePosX, sourcePosY;

//     if (containerAspectRatio > imageAspectRatio) {
//         // Container is wider than image
//         sourceWidth = canvas.height * imageAspectRatio;
//         sourceHeight = canvas.height;
//         sourcePosX = (canvas.width - sourceWidth) / 2;
//         sourcePosY = 0;
//     } else {
//         // Container is taller than image
//         sourceWidth = canvas.width;
//         sourceHeight = canvas.width / imageAspectRatio;
//         sourcePosX = 0;
//         sourcePosY = (canvas.height - sourceHeight) / 2;
//     }

//     ctx.drawImage(sourceImage, sourcePosX, sourcePosY, sourceWidth, sourceHeight);

//     // Draw patches on the canvas
//     patches.forEach(function (patch) {
//         var patchRect = patch.getBoundingClientRect();
//         var patchDivRect = patch.parentElement.getBoundingClientRect();

//         // Calculate the position of the patch relative to the image div
//         var patchPosX = patchDivRect.left - imageDivRect.left;
//         var patchPosY = patchDivRect.top - imageDivRect.top;

     

//     var patchWidth = patch.getAttribute('height');
//         var patchHeight = patch.getAttribute('width');

//         console.log('patchWidth', patchWidth);
//         console.log('patchHeight', patchHeight);
//         // Get the rotation angle from the patch element's style
//         var rotationDegrees = 0;
//         var transform = patch.parentElement.style.transform;
//         if (transform) {
//             var match = transform.match(/rotate\(([-\d.]+)deg\)/);
//             if (match) {
//                 rotationDegrees = parseFloat(match[1]);
//             }
//         }

//         // Calculate dimensions and position based on object-fit: contain
//         var patchAspectRatio = patch.naturalWidth / patch.naturalHeight;
//         var drawWidth, drawHeight, drawPosX, drawPosY;

//         if (patchWidth / patchHeight > patchAspectRatio) {
//             // Container is wider than patch
//             drawWidth = patchHeight * patchAspectRatio;
//             drawHeight = patchHeight;
//             drawPosX = (patchWidth - drawWidth) / 2;
//             drawPosY = 0;
//         } else {
//             // Container is taller than patch
//             drawWidth = patchWidth;
//             drawHeight = patchWidth / patchAspectRatio;
//             drawPosX = 0;
//             drawPosY = (patchHeight - drawHeight) / 2;
//         }

//         // Apply rotation in degrees and draw the patch
//         ctx.save();
//         ctx.translate(patchPosX + patchWidth / 2, patchPosY + patchHeight / 2); // Move to the center of the patch
//         ctx.rotate(rotationDegrees * Math.PI / 180); // Rotate the canvas in degrees
//         ctx.drawImage(patch, -drawWidth / 2, -drawHeight / 2, drawWidth, drawHeight);
//         ctx.restore();
//     });

//     // Convert canvas to Blob
//     canvas.toBlob(function (blob) {
//         // Here, you have the image as a blob
//         // For example, to display the new blob image, convert blob to ObjectURL
//         var pngImageURL = URL.createObjectURL(blob);

//         // Upload the blob URL
//         uploadBlob(pngImageURL, 'input[name="customized_image_url_back"]');

//         // Display the new image
//         var outputDiv = document.getElementById('BackoutputDiv');
//         var newImg = document.createElement('img');
//         newImg.src = pngImageURL;

//         outputDiv.innerHTML = ''; // Clear the output div before appending new image
//         outputDiv.appendChild(newImg);
//     }, 'image/png');
// }
// function FrontconvertToPng() {
//     var imageDiv = document.getElementById('imageDiv');
//     var patches = imageDiv.querySelectorAll('.patch- img');
//     var canvas = document.createElement('canvas');
//     var ctx = canvas.getContext('2d');

//     // Set canvas size to match the containing div's size
//     var imageDivRect = imageDiv.getBoundingClientRect();
//     canvas.width = imageDivRect.width;
//     canvas.height = imageDivRect.height;

//     // Draw the main image on the canvas with object-fit: contain
//     var sourceImage = document.getElementById('Front-image');
//     if (!sourceImage) {
//         console.error('Source image not found');
//         return;
//     }

//     // Calculate dimensions and position based on object-fit: contain
//     var containerAspectRatio = canvas.width / canvas.height;
//     var imageAspectRatio = sourceImage.naturalWidth / sourceImage.naturalHeight;

//     var sourceWidth, sourceHeight, sourcePosX, sourcePosY;

//     if (containerAspectRatio > imageAspectRatio) {
//         // Container is wider than image
//         sourceWidth = canvas.height * imageAspectRatio;
//         sourceHeight = canvas.height;
//         sourcePosX = (canvas.width - sourceWidth) / 2;
//         sourcePosY = 0;
//     } else {
//         // Container is taller than image
//         sourceWidth = canvas.width;
//         sourceHeight = canvas.width / imageAspectRatio;
//         sourcePosX = 0;
//         sourcePosY = (canvas.height - sourceHeight) / 2;
//     }

//     ctx.drawImage(sourceImage, sourcePosX, sourcePosY, sourceWidth, sourceHeight);

//     // Draw patches on the canvas
//     patches.forEach(function (patch) {
//         var patchRect = patch.getBoundingClientRect();
//         var patchDivRect = patch.parentElement.getBoundingClientRect();
//         var patchPosX = patchDivRect.left - imageDivRect.left;
//         var patchPosY = patchDivRect.top - imageDivRect.top;
//         var patchWidth = patch.getAttribute('height');
//         var patchHeight = patch.getAttribute('width');

//         // Calculate dimensions and position based on object-fit: contain
//         var patchAspectRatio = patch.naturalWidth / patch.naturalHeight;

//         var drawWidth, drawHeight, drawPosX, drawPosY;

//         if (patchWidth / patchHeight > patchAspectRatio) {
//             // Container is wider than patch
//             drawWidth = patchHeight * patchAspectRatio;
//             drawHeight = patchHeight;
//             drawPosX = patchPosX + (patchWidth - drawWidth) / 2;
//             drawPosY = patchPosY;
//         } else {
//             // Container is taller than patch
//             drawWidth = patchWidth;
//             drawHeight = patchWidth / patchAspectRatio;
//             drawPosX = patchPosX;
//             drawPosY = patchPosY + (patchHeight - drawHeight) / 2;
//         }

//         // Get the rotation angle from the patch element's style
//         var rotation = 0;
//         var transform = patch.parentElement.style.transform;
//         console.log('transform',transform)
//         if (transform) {
//             var match = transform.match(/rotate\(([-\d.]+)deg\)/);
//            console.log('match',match)
//             if (match) {
//               console.log('matched')
//                 rotation = parseFloat(match[1]) * (Math.PI / 180); // Convert degrees to radians
//             }
//         }

//         // Apply rotation and draw the patch
//         ctx.save();
//         ctx.translate(patchPosX + patchWidth / 2, patchPosY + patchHeight / 2); // Move to the center of the patch
//         ctx.rotate(rotation); // Rotate the canvas
//         ctx.drawImage(patch, -drawWidth / 2, -drawHeight / 2, drawWidth, drawHeight); // Draw the patch
//         ctx.restore();
//     });

//     // Convert canvas to Blob
//     canvas.toBlob(function (blob) {
//         // Here, you have the image as a blob
//         // For example, to display the new blob image, convert blob to ObjectURL
//         var pngImageURL = URL.createObjectURL(blob);

//         uploadBlob(pngImageURL, 'input[name="customized_image_url_front"]');

//         // Display the new image
//         var outputDiv = document.getElementById('outputDiv');
//         var newImg = document.createElement('img');
//         newImg.src = pngImageURL;

//         outputDiv.innerHTML = ''; // Clear the output div before appending new image
//         outputDiv.appendChild(newImg);
//     }, 'image/png');
// }

  function  selectpastchesodertidy(patchSrc,newPatchId){
    if (document.getElementById('Front-Area').style.visibility === 'visible') {
          $('.back-tdiy-patches-btn').removeClass('tdiy-patches-btn-active')
        $('.front-tdiy-patches-btn').addClass('tdiy-patches-btn-active')
        $('.select-patches-for-back').removeClass('select-patches-active')
        $('.select-patches-for-front').addClass('select-patches-active')
          $('.patches-container .patch-').each(function() {
        var patchId = newPatchId;
        
        // Check if the patch with the same ID already exists in .select-patches
        if (!$('.select-patches-for-front').find('[data-patch-id="' + patchId + '"]').length) {
            // Get image source
            var imageSrc = patchSrc;

            // Create a new div with class .selected-patch-for-customization
            var selectedPatchDiv = $(`<div class="selected-patch-for-customization selected-patch-for-customization-for-front" id="${patchId}"></div>`);

            // Create an img element with the same src as the original image
            var imageElement = $('<img>').attr('src', imageSrc);

            // Append the image to the new div
            selectedPatchDiv.append(imageElement);

            // Append the patchId as a data attribute
            selectedPatchDiv.attr('data-patch-id', patchId);

            // Append the new div to .select-patches
            $('.select-patches-for-front').append(selectedPatchDiv);
        }
    });
    } 
      else if (document.getElementById('Back-area').style.visibility === 'visible') {
        $('.front-tdiy-patches-btn').removeClass('tdiy-patches-btn-active')
        $('.back-tdiy-patches-btn').addClass('tdiy-patches-btn-active')
        $('.select-patches-for-front').removeClass('select-patches-active')
        $('.select-patches-for-back').addClass('select-patches-active')
        $('.patches-containerr .patch-').each(function() {
        var patchId = newPatchId;
        
        // Check if the patch with the same ID already exists in .select-patches
        if (!$('.select-patches-for-back').find('[data-patch-id="' + patchId + '"]').length) {
            // Get image source
            var imageSrc = patchSrc;

            // Create a new div with class .selected-patch-for-customization
            var selectedPatchDiv = $(`<div class="selected-patch-for-customization selected-patch-for-customization-for-back" id="${patchId}"></div>`);

            // Create an img element with the same src as the original image
            var imageElement = $('<img>').attr('src', imageSrc);

            // Append the image to the new div
            selectedPatchDiv.append(imageElement);

            // Append the patchId as a data attribute
            selectedPatchDiv.attr('data-patch-id', patchId);

            // Append the new div to .select-patches
            $('.select-patches-for-back').append(selectedPatchDiv);
        }
    });
     
     }
  }
let currentX = 0;
let currentY = 0;


function addPatchToCenterBox(patchSrc, patchId, height, width) {
 
  console.log('adding to front'); 
  console.log(height,width);
    var patchDiv = document.createElement('div');
    patchDiv.setAttribute('v-id', patchId);
    patchDiv.classList.add('patch-');
    patchDiv.style.position = 'absolute';
    patchDiv.style.top = currentY + 'px';
    patchDiv.style.left = currentX + 'px';
    var centerBox = document.querySelector('.centerBox');
    var patchesContainer = centerBox.querySelector('.patches-container');
    var existingPatch = patchesContainer.querySelector(`div[v-id="${patchId}"]`);
  
    if (existingPatch) {
        console.log('Matching v-id found:', patchId);
        width = parseInt(existingPatch.style.width);
        height = parseInt(existingPatch.style.height);
        patchDiv.style.width = width + 'px';
        patchDiv.style.height = height + 'px';
    }
    else {
       if (window.orientation === 90 || window.orientation === -90) {
        // Calculate half width and height
   var halfWidth = (width / 2) - 2;
var halfHeight = (height / 2) - 2;


        // Check if they are less than 20 and add 5px if true
        if (halfWidth < 13) {
            halfWidth += 8;
        }
        if (halfHeight < 13) {
            halfHeight += 8;
        }
        if (halfWidth < 14) {
            halfWidth += 7;
        }
        if (halfHeight < 14) {
            halfHeight += 7;
        }
        if (halfWidth < 15) {
            halfWidth += 6;
        }
        if (halfHeight < 15) {
            halfHeight += 6;
        }
        if (halfWidth < 16) {
            halfWidth += 5;
        }
        if (halfHeight < 16) {
            halfHeight += 5;
        }
        if (halfWidth < 17) {
            halfWidth += 4;
        }
        if (halfHeight < 17) {
            halfHeight += 4;
        }
        if (halfWidth < 18) {
            halfWidth += 8;
        }
        if (halfHeight < 18) {
            halfHeight += 3;
        }
        if (halfWidth < 19) {
            halfWidth += 3;
        }
        if (halfHeight < 19) {
            halfHeight += 2;
        }
        if (halfWidth < 20) {
            halfWidth += 1;
        }
        if (halfHeight < 20) {
            halfHeight += 1;
        }
const product = {{ product | json }};
   if (product.tags.includes('customize-long-bag')){
      halfHeight += 10;
     halfWidth += 10;
}
        // Set the patch dimensions
        patchDiv.style.width = halfWidth + 'px';
        patchDiv.style.height = halfHeight + 'px';
    } 
      else{
       if (window.matchMedia("(min-width: 1031px) and (max-width: 1600px)").matches) {
  console.log('yes this is 1031px'); 
 const normalizedWidth = window.innerWidth / window.devicePixelRatio;
console.log('Normalized Width is this:', normalizedWidth);
if (normalizedWidth >= 600 && normalizedWidth <= 1024) {
    console.log('This is iPad Pro');
       console.log('yes this is ipad view'); 
   console.log('Window Width: ', window.innerWidth);
  // Calculate half width and height
        var halfWidth = width / 2;
        var halfHeight = height / 2;

        // Check if they are less than 20 and add 5px if true
        if (halfWidth < 13) {
            halfWidth += 8;
        }
        if (halfHeight < 13) {
            halfHeight += 8;
        }
        if (halfWidth < 14) {
            halfWidth += 7;
        }
        if (halfHeight < 14) {
            halfHeight += 7;
        }
        if (halfWidth < 15) {
            halfWidth += 6;
        }
        if (halfHeight < 15) {
            halfHeight += 6;
        }
        if (halfWidth < 16) {
            halfWidth += 5;
        }
        if (halfHeight < 16) {
            halfHeight += 5;
        }
        if (halfWidth < 17) {
            halfWidth += 4;
        }
        if (halfHeight < 17) {
            halfHeight += 4;
        }
        if (halfWidth < 18) {
            halfWidth += 8;
        }
        if (halfHeight < 18) {
            halfHeight += 3;
        }
        if (halfWidth < 19) {
            halfWidth += 3;
        }
        if (halfHeight < 19) {
            halfHeight += 2;
        }
        if (halfWidth < 20) {
            halfWidth += 1;
        }
          else{
            if (product.tags.includes('patch-it-bag')){
            console.log('yes this patch-it-bag'); 
       halfHeight += 5;
       halfWidth += 5;
            }
              else if (product.tags.includes('customize-long-bag')){
                    halfHeight += 25;
       halfWidth += 25;
              }
              else {
       halfHeight += 15;
       halfWidth += 15;
       }
          }
      

        // Set the patch dimensions
        patchDiv.style.width = halfWidth + 'px';
        patchDiv.style.height = halfHeight + 'px';
}
else{
   var halfWidth =width - 20;
        var halfHeight = height - 20;

        // Check if they are less than 20 and add 5px if true
        if (halfWidth < 13) {
            halfWidth += 8;
        }
        if (halfHeight < 13) {
            halfHeight += 8;
        }
        if (halfWidth < 14) {
            halfWidth += 7;
        }
        if (halfHeight < 14) {
            halfHeight += 7;
        }
        if (halfWidth < 15) {
            halfWidth += 6;
        }
        if (halfHeight < 15) {
            halfHeight += 6;
        }
        if (halfWidth < 16) {
            halfWidth += 5;
        }
        if (halfHeight < 16) {
            halfHeight += 5;
        }
        if (halfWidth < 17) {
            halfWidth += 4;
        }
        if (halfHeight < 17) {
            halfHeight += 4;
        }
        if (halfWidth < 18) {
            halfWidth += 8;
        }
        if (halfHeight < 18) {
            halfHeight += 3;
        }
        if (halfWidth < 19) {
            halfWidth += 3;
        }
        if (halfHeight < 19) {
            halfHeight += 2;
        }
        if (halfWidth < 20) {
            halfWidth += 1;
        }
        else{
       if (product.tags.includes('patch-it-bag')){
       console.log('yes this patch-it-bag'); 
       halfHeight += 25;
       halfWidth += 25;
            }
              else {
       halfHeight += 0;
       halfWidth += 0;
       }
          }
      

        // Set the patch dimensions
        patchDiv.style.width = halfWidth + 'px';
        patchDiv.style.height = halfHeight + 'px';
}
       
    }
 else if (window.matchMedia("(min-width: 769px) and (max-width: 1024px)").matches) {
     console.log('yes this is ipad view'); 
   console.log('Window Width: ', window.innerWidth);
  // Calculate half width and height
        var halfWidth = width / 2;
        var halfHeight = height / 2;

        // Check if they are less than 20 and add 5px if true
        if (halfWidth < 13) {
            halfWidth += 8;
        }
        if (halfHeight < 13) {
            halfHeight += 8;
        }
        if (halfWidth < 14) {
            halfWidth += 7;
        }
        if (halfHeight < 14) {
            halfHeight += 7;
        }
        if (halfWidth < 15) {
            halfWidth += 6;
        }
        if (halfHeight < 15) {
            halfHeight += 6;
        }
        if (halfWidth < 16) {
            halfWidth += 5;
        }
        if (halfHeight < 16) {
            halfHeight += 5;
        }
        if (halfWidth < 17) {
            halfWidth += 4;
        }
        if (halfHeight < 17) {
            halfHeight += 4;
        }
        if (halfWidth < 18) {
            halfWidth += 8;
        }
        if (halfHeight < 18) {
            halfHeight += 3;
        }
        if (halfWidth < 19) {
            halfWidth += 3;
        }
        if (halfHeight < 19) {
            halfHeight += 2;
        }
        if (halfWidth < 20) {
            halfWidth += 1;
        }
          else{
            if (product.tags.includes('patch-it-bag')){
            console.log('yes this patch-it-bag'); 
       halfHeight += 5;
       halfWidth += 5;
            }
              else if (product.tags.includes('customize-long-bag')){
                    halfHeight += 25;
       halfWidth += 25;
              }
              else {
       halfHeight += 20;
       halfWidth += 20;
       }
          }
      

        // Set the patch dimensions
        patchDiv.style.width = halfWidth + 'px';
        patchDiv.style.height = halfHeight + 'px';
    }
 else if (window.matchMedia("(max-width: 768px)").matches) {
        // Calculate half width and height
   var halfWidth = (width / 2) - 2;
var halfHeight = (height / 2) - 2;


        // Check if they are less than 20 and add 5px if true
        if (halfWidth < 13) {
            halfWidth += 8;
        }
        if (halfHeight < 13) {
            halfHeight += 8;
        }
        if (halfWidth < 14) {
            halfWidth += 7;
        }
        if (halfHeight < 14) {
            halfHeight += 7;
        }
        if (halfWidth < 15) {
            halfWidth += 6;
        }
        if (halfHeight < 15) {
            halfHeight += 6;
        }
        if (halfWidth < 16) {
            halfWidth += 5;
        }
        if (halfHeight < 16) {
            halfHeight += 5;
        }
        if (halfWidth < 17) {
            halfWidth += 4;
        }
        if (halfHeight < 17) {
            halfHeight += 4;
        }
        if (halfWidth < 18) {
            halfWidth += 8;
        }
        if (halfHeight < 18) {
            halfHeight += 3;
        }
        if (halfWidth < 19) {
            halfWidth += 3;
        }
        if (halfHeight < 19) {
            halfHeight += 2;
        }
        if (halfWidth < 20) {
            halfWidth += 1;
        }
        if (halfHeight < 20) {
            halfHeight += 1;
        }
const product = {{ product | json }};
   if (product.tags.includes('customize-long-bag')){
      halfHeight += 10;
     halfWidth += 10;
}
        // Set the patch dimensions
        patchDiv.style.width = halfWidth + 'px';
        patchDiv.style.height = halfHeight + 'px';
    }  
 else {
        patchDiv.style.width = width + 'px';
        patchDiv.style.height = height + 'px';
    } 
      }
       
    }


    // Ensure the patch stays inside the parent container
    var centerBox = document.querySelector('.centerBox');
    var containerWidth = centerBox.offsetWidth;
    var containerHeight = centerBox.offsetHeight;

    // Check if the patch exceeds the container's width
    if (currentX + parseInt(patchDiv.style.width) > containerWidth) {
        currentX = containerWidth - parseInt(patchDiv.style.width);
    }

    // Check if the patch exceeds the container's height
    if (currentY + parseInt(patchDiv.style.height) > containerHeight) {
        currentY = containerHeight - parseInt(patchDiv.style.height);
    }

    // Apply the corrected position
    patchDiv.style.left = currentX + 'px';
    patchDiv.style.top = currentY + 'px';

    // Make the edit button visible
    var editTidyBtnwrapper = document.querySelector('.edit-tidy-btn-wrapp');
    editTidyBtnwrapper.style.visibility = 'visible';

    // Generate a unique ID for the patch
    var newPatchId = 'patch_' + Math.random().toString(36).substr(2, 9);

    patchDiv.setAttribute('id', newPatchId);
    patchDiv.innerHTML = `<img src="${patchSrc}" alt="" class="patch-image" width="${width}" height="${height}" crossorigin="anonymous">`;
    centerBox.querySelector('.patches-container').appendChild(patchDiv);

    // Add the patch to the patches array with its ID
    patches.push({ id: newPatchId, patchSrc, width, height });
        initializePatch(
        patchDiv,
        width,         // Reference width
        height,        // Reference height
        containerWidth,
        containerHeight
    );
  adjustPatches(true);
    // Update currentX and currentY for the next patch

  currentX += parseInt(patchDiv.style.width) || 0;

if (currentX + parseInt(patchDiv.style.width) > containerWidth) {
    currentX = 0;
    currentY += parseInt(patchDiv.style.height) || 0;
}

  // Add click event listener to the dynamically created patch
    patchDiv.addEventListener('dragstart', function(event) {
        ismainDragging = true;
        event.preventDefault();
        event.dataTransfer.setData('text/plain', patchDiv.querySelector('img').src);
        dragPatch1 = patchDiv;
        centerBox.addEventListener('mousemove', mousemoveHandler);
    });

    patchDiv.addEventListener('click', function() {
        dragPatch1 = patchDiv;
        var patchSrc = patchDiv.querySelector('img').src;
        updatePosition(patchDiv.id);
        centerBox.removeEventListener('mousemove', mousemoveHandler);
    });

    checkPatchallOverlapping();
    selectpastchesodertidy(patchSrc, newPatchId);
    tidyEditbtnfuncion();
}


// Store the current position for placing patches
let currentXBack = 0;
let currentYBack = 0;

function addPatchToBackcenterBox(patchSrc, patchId, height, width) {
    var patchDiv = document.createElement('div');
    patchDiv.setAttribute('v-id', patchId);
    patchDiv.classList.add('patch-');
    patchDiv.style.position = 'absolute';
    // Position the patch
    patchDiv.style.top = currentYBack + 'px';
    patchDiv.style.left = currentXBack + 'px';
      var backcenterBox = document.querySelector('.BackcenterBox');
    var patchesContainer = backcenterBox.querySelector('.patches-containerr');
    var existingPatch = patchesContainer.querySelector(`div[v-id="${patchId}"]`);
  
    if (existingPatch) {
        console.log('Matching v-id found:', patchId);
        width = parseInt(existingPatch.style.width);
        height = parseInt(existingPatch.style.height);
        patchDiv.style.width = width + 'px';
        patchDiv.style.height = height + 'px';
    }
    else {
       if (window.orientation === 90 || window.orientation === -90) {
        // Calculate half width and height
   var halfWidth = (width / 2) - 2;
var halfHeight = (height / 2) - 2;


        // Check if they are less than 20 and add 5px if true
        if (halfWidth < 13) {
            halfWidth += 8;
        }
        if (halfHeight < 13) {
            halfHeight += 8;
        }
        if (halfWidth < 14) {
            halfWidth += 7;
        }
        if (halfHeight < 14) {
            halfHeight += 7;
        }
        if (halfWidth < 15) {
            halfWidth += 6;
        }
        if (halfHeight < 15) {
            halfHeight += 6;
        }
        if (halfWidth < 16) {
            halfWidth += 5;
        }
        if (halfHeight < 16) {
            halfHeight += 5;
        }
        if (halfWidth < 17) {
            halfWidth += 4;
        }
        if (halfHeight < 17) {
            halfHeight += 4;
        }
        if (halfWidth < 18) {
            halfWidth += 8;
        }
        if (halfHeight < 18) {
            halfHeight += 3;
        }
        if (halfWidth < 19) {
            halfWidth += 3;
        }
        if (halfHeight < 19) {
            halfHeight += 2;
        }
        if (halfWidth < 20) {
            halfWidth += 1;
        }
        if (halfHeight < 20) {
            halfHeight += 1;
        }
const product = {{ product | json }};
   if (product.tags.includes('customize-long-bag')){
      halfHeight += 10;
     halfWidth += 10;
}
        // Set the patch dimensions
        patchDiv.style.width = halfWidth + 'px';
        patchDiv.style.height = halfHeight + 'px';
    } 
      else{
       if (window.matchMedia("(min-width: 1031px) and (max-width: 1600px)").matches) {
  console.log('yes this is 1031px'); 
 const normalizedWidth = window.innerWidth / window.devicePixelRatio;
console.log('Normalized Width is this:', normalizedWidth);
if (normalizedWidth >= 600 && normalizedWidth <= 1024) {
    console.log('This is iPad Pro');
       console.log('yes this is ipad view'); 
   console.log('Window Width: ', window.innerWidth);
  // Calculate half width and height
        var halfWidth = width / 2;
        var halfHeight = height / 2;

        // Check if they are less than 20 and add 5px if true
        if (halfWidth < 13) {
            halfWidth += 8;
        }
        if (halfHeight < 13) {
            halfHeight += 8;
        }
        if (halfWidth < 14) {
            halfWidth += 7;
        }
        if (halfHeight < 14) {
            halfHeight += 7;
        }
        if (halfWidth < 15) {
            halfWidth += 6;
        }
        if (halfHeight < 15) {
            halfHeight += 6;
        }
        if (halfWidth < 16) {
            halfWidth += 5;
        }
        if (halfHeight < 16) {
            halfHeight += 5;
        }
        if (halfWidth < 17) {
            halfWidth += 4;
        }
        if (halfHeight < 17) {
            halfHeight += 4;
        }
        if (halfWidth < 18) {
            halfWidth += 8;
        }
        if (halfHeight < 18) {
            halfHeight += 3;
        }
        if (halfWidth < 19) {
            halfWidth += 3;
        }
        if (halfHeight < 19) {
            halfHeight += 2;
        }
        if (halfWidth < 20) {
            halfWidth += 1;
        }
          else{
            if (product.tags.includes('patch-it-bag')){
            console.log('yes this patch-it-bag'); 
       halfHeight += 5;
       halfWidth += 5;
            }
              else if (product.tags.includes('customize-long-bag')){
                    halfHeight += 25;
       halfWidth += 25;
              }
              else {
       halfHeight += 15;
       halfWidth += 15;
       }
          }
      

        // Set the patch dimensions
        patchDiv.style.width = halfWidth + 'px';
        patchDiv.style.height = halfHeight + 'px';
}
else{
   var halfWidth =width - 20;
        var halfHeight = height - 20;

        // Check if they are less than 20 and add 5px if true
        if (halfWidth < 13) {
            halfWidth += 8;
        }
        if (halfHeight < 13) {
            halfHeight += 8;
        }
        if (halfWidth < 14) {
            halfWidth += 7;
        }
        if (halfHeight < 14) {
            halfHeight += 7;
        }
        if (halfWidth < 15) {
            halfWidth += 6;
        }
        if (halfHeight < 15) {
            halfHeight += 6;
        }
        if (halfWidth < 16) {
            halfWidth += 5;
        }
        if (halfHeight < 16) {
            halfHeight += 5;
        }
        if (halfWidth < 17) {
            halfWidth += 4;
        }
        if (halfHeight < 17) {
            halfHeight += 4;
        }
        if (halfWidth < 18) {
            halfWidth += 8;
        }
        if (halfHeight < 18) {
            halfHeight += 3;
        }
        if (halfWidth < 19) {
            halfWidth += 3;
        }
        if (halfHeight < 19) {
            halfHeight += 2;
        }
        if (halfWidth < 20) {
            halfWidth += 1;
        }
        else{
       if (product.tags.includes('patch-it-bag')){
       console.log('yes this patch-it-bag'); 
       halfHeight += 25;
       halfWidth += 25;
            }
              else {
       halfHeight += 15;
       halfWidth += 15;
       }
          }
      

        // Set the patch dimensions
        patchDiv.style.width = halfWidth + 'px';
        patchDiv.style.height = halfHeight + 'px';
}
       
    }
 else if (window.matchMedia("(min-width: 769px) and (max-width: 1024px)").matches) {
     console.log('yes this is ipad view'); 
   console.log('Window Width: ', window.innerWidth);
  // Calculate half width and height
        var halfWidth = width / 2;
        var halfHeight = height / 2;

        // Check if they are less than 20 and add 5px if true
        if (halfWidth < 13) {
            halfWidth += 8;
        }
        if (halfHeight < 13) {
            halfHeight += 8;
        }
        if (halfWidth < 14) {
            halfWidth += 7;
        }
        if (halfHeight < 14) {
            halfHeight += 7;
        }
        if (halfWidth < 15) {
            halfWidth += 6;
        }
        if (halfHeight < 15) {
            halfHeight += 6;
        }
        if (halfWidth < 16) {
            halfWidth += 5;
        }
        if (halfHeight < 16) {
            halfHeight += 5;
        }
        if (halfWidth < 17) {
            halfWidth += 4;
        }
        if (halfHeight < 17) {
            halfHeight += 4;
        }
        if (halfWidth < 18) {
            halfWidth += 8;
        }
        if (halfHeight < 18) {
            halfHeight += 3;
        }
        if (halfWidth < 19) {
            halfWidth += 3;
        }
        if (halfHeight < 19) {
            halfHeight += 2;
        }
        if (halfWidth < 20) {
            halfWidth += 1;
        }
          else{
            if (product.tags.includes('patch-it-bag')){
            console.log('yes this patch-it-bag'); 
       halfHeight += 5;
       halfWidth += 5;
            }
              else if (product.tags.includes('customize-long-bag')){
                    halfHeight += 25;
       halfWidth += 25;
              }
              else {
       halfHeight += 20;
       halfWidth += 20;
       }
          }
      

        // Set the patch dimensions
        patchDiv.style.width = halfWidth + 'px';
        patchDiv.style.height = halfHeight + 'px';
    }
 else if (window.matchMedia("(max-width: 768px)").matches) {
        // Calculate half width and height
   var halfWidth = (width / 2) - 2;
var halfHeight = (height / 2) - 2;


        // Check if they are less than 20 and add 5px if true
        if (halfWidth < 13) {
            halfWidth += 8;
        }
        if (halfHeight < 13) {
            halfHeight += 8;
        }
        if (halfWidth < 14) {
            halfWidth += 7;
        }
        if (halfHeight < 14) {
            halfHeight += 7;
        }
        if (halfWidth < 15) {
            halfWidth += 6;
        }
        if (halfHeight < 15) {
            halfHeight += 6;
        }
        if (halfWidth < 16) {
            halfWidth += 5;
        }
        if (halfHeight < 16) {
            halfHeight += 5;
        }
        if (halfWidth < 17) {
            halfWidth += 4;
        }
        if (halfHeight < 17) {
            halfHeight += 4;
        }
        if (halfWidth < 18) {
            halfWidth += 8;
        }
        if (halfHeight < 18) {
            halfHeight += 3;
        }
        if (halfWidth < 19) {
            halfWidth += 3;
        }
        if (halfHeight < 19) {
            halfHeight += 2;
        }
        if (halfWidth < 20) {
            halfWidth += 1;
        }
        if (halfHeight < 20) {
            halfHeight += 1;
        }
const product = {{ product | json }};
   if (product.tags.includes('customize-long-bag')){
      halfHeight += 10;
     halfWidth += 10;
}
        // Set the patch dimensions
        patchDiv.style.width = halfWidth + 'px';
        patchDiv.style.height = halfHeight + 'px';
    }  
 else {
        patchDiv.style.width = width + 'px';
        patchDiv.style.height = height + 'px';
    } 
      }
       
    }

    // Ensure the patch stays inside the parent container
    var BackcenterBox = document.querySelector('.BackcenterBox');
    var containerWidth = BackcenterBox.offsetWidth;
    var containerHeight = BackcenterBox.offsetHeight;

    // Check if the patch exceeds the container's width
    if (currentXBack + parseInt(patchDiv.style.width) > containerWidth) {
        currentXBack = containerWidth - parseInt(patchDiv.style.width);
    }

    // Check if the patch exceeds the container's height
    if (currentYBack + parseInt(patchDiv.style.height) > containerHeight) {
        currentYBack = containerHeight - parseInt(patchDiv.style.height);
    }

    // Apply the corrected position
    patchDiv.style.left = currentXBack + 'px';
    patchDiv.style.top = currentYBack + 'px';

    // Make the edit button visible
    var editTidyBtnwrapper = document.querySelector('.edit-tidy-btn-wrapp');
    editTidyBtnwrapper.style.visibility = 'visible';

    // Generate a unique ID for the patch
    var newPatchId = 'patch_' + Math.random().toString(36).substr(2, 9);

    patchDiv.setAttribute('id', newPatchId);
    patchDiv.innerHTML = `<img src="${patchSrc}" alt="" class="patch-image" width="${width}" height="${height}" crossorigin="anonymous">`;
    BackcenterBox.querySelector('.patches-containerr').appendChild(patchDiv);

    // Add the patch to the patches array with its ID
    patches.push({ id: newPatchId, patchSrc, width, height });
    initializePatch(
        patchDiv,
        width,         // Reference width
        height,        // Reference height
        containerWidth,
        containerHeight
    );
  adjustPatches(true);
    // Update currentXBack and currentYBack for the next patch
    currentXBack += parseInt(patchDiv.style.width); // Add 10px gap between patches
    if (currentXBack + parseInt(patchDiv.style.width) > containerWidth) {
        // Move to the next row if there's no space left in the current row
        currentXBack = 0;
        currentYBack += parseInt(patchDiv.style.height); // Add 10px gap between rows
    }

    // Add click event listener to the dynamically created patch
    patchDiv.addEventListener('dragstart', function(event) {
        ismainDragging = true;
        event.preventDefault();
        event.dataTransfer.setData('text/plain', patchDiv.querySelector('img').src);
        dragPatch1 = patchDiv;
        BackcenterBox.addEventListener('mousemove', mousemoveHandlerBack);
    });

    patchDiv.addEventListener('click', function() {
        dragPatch1 = patchDiv;
        var patchSrc = patchDiv.querySelector('img').src;
        updatePosition(patchDiv.id);
        BackcenterBox.removeEventListener('mousemove', mousemoveHandlerBack);
    });

    checkPatchallOverlapping();
  selectpastchesodertidy(patchSrc,newPatchId);
   tidyEditbtnfuncion();
}


function dropPatchbydraggingFront(patchElement, x, y, height, width) {
    var imageElement = patchElement.querySelector('img').src;

    var vId = patchElement.getAttribute('v-id');
    var patchDiv = document.createElement('div');
    patchDiv.setAttribute('v-id', vId);
    patchDiv.classList.add('patch-');
    patchDiv.style.position = 'absolute';
    patchDiv.style.top = y + 'px';
    patchDiv.style.left = x + 'px';

    // Setting width and height
    patchDiv.style.width = width + 'px';
    patchDiv.style.height = height + 'px';

    // Generate a unique ID for the patch
    var patchId = 'patch_' + Math.random().toString(36).substr(2, 9);
    patchDiv.setAttribute('id', patchId);

    // Add the image to the patch
    patchDiv.innerHTML = `<img src="${imageElement}" alt="" class="patch-image" height="${height}" width="${width}" crossorigin="anonymous">`;

    var centerBox = document.querySelector('.centerBox');
    centerBox.querySelector('.patches-container').appendChild(patchDiv);

    // Add the patch to the patches array with its ID
    patches.push({ id: patchId, imageElement, x, y, width, height });

    // Show the edit/tidy button wrapper
    var editTidyBtnwrapper = document.querySelector('.edit-tidy-btn-wrapp');
    editTidyBtnwrapper.style.visibility = 'visible';

    // Add event listeners to all dynamically created patches
    document.querySelectorAll('.patch-').forEach(patch1 => {
        patch1.addEventListener('dragstart', function (event) {
            event.preventDefault();
            event.dataTransfer.setData('text/plain', patch1.querySelector('img').src);
            dragPatch1 = patch1;

            centerBox.addEventListener('mousemove', mousemoveHandler);
        });

        patch1.addEventListener('click', function () {
            dragPatch1 = patch1;
            var patchSrc = patch1.querySelector('img').src;
            updatePosition(patch1.id);
            centerBox.removeEventListener('mousemove', mousemoveHandler);
        });
    });
}

function dropPatchbydraggingBack(patchElement, x, y, height,width) {

    var imageElement = patchElement.querySelector('img').src;

    var vId = patchElement.getAttribute('v-id');
    var patchDiv = document.createElement('div');
    patchDiv.setAttribute('v-id', vId);
    patchDiv.classList.add('patch-');
    patchDiv.style.position = 'absolute';
    patchDiv.style.top = y + 'px';
    patchDiv.style.left = x + 'px';
    // patchDiv.style.transform = 'translate(-50%, -50%)';
  //   if (window.matchMedia("(min-width:  1024px) and (max-width: 1600px)").matches){
  //    patchDiv.style.width = (width - 20 ) + 'px';
  //       patchDiv.style.height = (height - 20  ) + 'px';
  // }
  // else {
     patchDiv.style.width = width + 'px';
     patchDiv.style.height = height + 'px';
  // }
   

    // Generate a unique ID for the patch
    var patchId = 'patch_' + Math.random().toString(36).substr(2, 9);

    patchDiv.setAttribute('id', patchId);
    patchDiv.innerHTML = `<img src="${imageElement}" alt="" class="patch-image " height="${height}" width="${width}" crossorigin="anonymous" >`;
    var BackcenterBox = document.querySelector('.BackcenterBox');
    BackcenterBox.querySelector('.patches-containerr').appendChild(patchDiv);

    // Add the patch to the patches array with its ID
    patches.push({ id: patchId, imageElement, x, y, width, height });

   var editTidyBtnwrapper = document.querySelector('.edit-tidy-btn-wrapp');
editTidyBtnwrapper.style.visibility = 'visible';
  
    // Add click event listener to the dynamically created patch
    document.querySelectorAll('.patch-').forEach(patch1 => {

        patch1.addEventListener('dragstart', function (event) {

            event.preventDefault();
            event.dataTransfer.setData('text/plain', patch1.querySelector('img').src);
            dragPatch1 = patch1;

            BackcenterBox.addEventListener('mousemove', mousemoveHandlerBack);
        });

        patch1.addEventListener('click', function () {
            dragPatch1 = patch1;
            var patchSrc = patch1.querySelector('img').src;
            updatePosition(patch1.id);
            BackcenterBox.removeEventListener('mousemove', mousemoveHandlerBack);

        });
    });



}
// Add event listener to the container of patch elements
document.querySelector('.patches').addEventListener('dragstart', function (event) {
  console.log('drags Started');
  const patch = event.target.closest('.patch');
  if (!patch) return; // If the event target isn't a patch, ignore it

  // Get the original width and height of the image
  const image = patch.querySelector('img');
  const originalWidth = image.getAttribute('width');
  const originalHeight = image.getAttribute('height');
  const dragpatchDiv = document.querySelector('.dragpatchDiv');
  // Store the patch being dragged
  dragPatch = patch;


  // Create a new Image element to be used as the custom dragging image
  const newImage = new Image();
  newImage.onload = function() {
    // Once the image is loaded, set the drag image
    event.dataTransfer.setDragImage(newImage, 20, 20);
  };
  newImage.crossOrigin = 'anonymous'; // Add crossorigin attribute
  newImage.src = image.src;
  newImage.width = originalWidth;
  newImage.height = originalHeight;
  newImage.style.position = 'absolute';
  newImage.style.zIndex = '9999';
  newImage.style.objectFit = 'contain';
  newImage.style.opacity = '0.7'; // Optional transparency
  
  // document.body.appendChild(newImage); // Ensure the image is in the DOM to trigger the 'onload' event
   dragpatchDiv.appendChild(newImage); // Ensure the image is in the DOM to trigger the 'onload' event

  // Ensure the drag image is set even if the 'onload' event has already fired
  if (newImage.complete) {
    event.dataTransfer.setDragImage(newImage, 20, 20);
  }
});
document.querySelector('#alphabets-wrapper').addEventListener('dragstart', function (event) {
  console.log('drags Started dragging');
  const patch = event.target.closest('.patch');
  if (!patch) return; // If the event target isn't a patch, ignore it

  // Get the original width and height of the image
  const image = patch.querySelector('img');
  const originalWidth = image.getAttribute('width');
  const originalHeight = image.getAttribute('height');
  const dragpatchDiv = document.querySelector('.dragpatchDiv');
  // Store the patch being dragged
  dragPatch = patch;

  // Create a new Image element to be used as the custom dragging image
  const newImage = new Image();
  newImage.onload = function() {
    // Once the image is loaded, set the drag image
    event.dataTransfer.setDragImage(newImage, 20, 20);
  };
  newImage.crossOrigin = 'anonymous'; // Add crossorigin attribute
  newImage.src = image.src;
  newImage.width = originalWidth;
  newImage.height = originalHeight;
  newImage.style.position = 'absolute';
  newImage.style.zIndex = '9999';
  newImage.style.objectFit = 'contain';
  newImage.style.opacity = '0.7'; // Optional transparency
  
  // document.body.appendChild(newImage); // Ensure the image is in the DOM to trigger the 'onload' event
   dragpatchDiv.appendChild(newImage); // Ensure the image is in the DOM to trigger the 'onload' event

  // Ensure the drag image is set even if the 'onload' event has already fired
  if (newImage.complete) {
    event.dataTransfer.setDragImage(newImage, 20, 20);
  }
});

  
document.querySelectorAll('.patches').forEach(patchesDiv => {
    patchesDiv.addEventListener('click', function (event) {
        const patchTitle = event.target.closest('.patch-title');

        if (!patchTitle) return; // If the event target isn't a patch title, ignore it

        const patch = patchTitle.closest('.patch');
        const patchId = patch.getAttribute('v-id');
        const patchImg = patch.querySelector('img');
        const patchSrc = patchImg.src;
        const height = patchImg.getAttribute('height'); // Get the height attribute
        const width = patchImg.getAttribute('width');

        if (document.getElementById('Front-Area').style.visibility === 'visible') {
            addPatchToCenterBox(patchSrc, patchId, height, width);
            dragPatch = patch;
        } 
        else if (document.getElementById('Back-area').style.visibility === 'visible') {
            addPatchToBackcenterBox(patchSrc, patchId, height, width);
            dragPatch = patch;
        }
    });
});




centerBox.addEventListener('dragover', function (event) {
    event.preventDefault();
});
BackcenterBox.addEventListener('dragover', function (event) {
    event.preventDefault();
});
centerBox.addEventListener('drop', function (event) {
    event.preventDefault();

    const patchesContainer = centerBox.querySelector('.patches-container'); // Get patches container

    if (dragPatch) {
        const patchId = dragPatch.getAttribute('v-id'); // Get v-id of the dragged patch
        const existingPatch = patchesContainer.querySelector(`div[v-id="${patchId}"]`); // Check if patch already exists

        let height, width;

        if (existingPatch) {
          console.log('existing');
            // Use the dimensions of the existing patch
        width = parseInt(existingPatch.style.width);
        height = parseInt(existingPatch.style.height);
          console.log(width,height);

        } 
        else {
            // Use the dimensions of the dragged patch
            const patchImg = dragPatch.querySelector('img');
            height = patchImg.getAttribute('height');
            width = patchImg.getAttribute('width');
        }

        const rect = centerBox.getBoundingClientRect();
        const mouseX = event.clientX - rect.left;
        const mouseY = event.clientY - rect.top;

        // Calculate position considering the center of the patch
        const offsetX = width / 2;
        const offsetY = height / 2;

        const patchX = mouseX - offsetX;
        const patchY = mouseY - offsetY;

        if (document.getElementById('Front-Area').style.visibility === 'visible') {
            console.log('drop at front');
            dropPatchbydraggingFront(dragPatch, patchX, patchY, height, width);
        } else if (document.getElementById('Back-area').style.visibility === 'visible') {
            console.log('drop at back');
            dropPatchbydraggingBack(dragPatch, mouseX, mouseY, height, width);
        }
    } else {
        const rect = centerBox.getBoundingClientRect();
        const mouseX = event.clientX - rect.left;
        const mouseY = event.clientY - rect.top;

        if (document.getElementById('Front-Area').style.visibility === 'visible') {
            updatePosition(dragPatch1.id, mouseX, mouseY, height, width);
        } else if (document.getElementById('Back-area').style.visibility === 'visible') {
            updatePosition(dragPatch1.id, mouseX, mouseY, height, width);
        }

        centerBox.removeEventListener('mousemove', mousemoveHandler);
        centerBox.removeEventListener('touchmove', mousemoveHandler); // Add this line
    }
});

BackcenterBox.addEventListener('drop', function (event) {
  
    event.preventDefault();
  const patchesContainer = BackcenterBox.querySelector('.patches-containerr'); // Get patches container
    if (dragPatch) {
        const patchImg = dragPatch.querySelector('img');

        const vId = dragPatch.getAttribute('v-id');
        const existingPatch = patchesContainer.querySelector(`div[v-id="${vId}"]`);
       let height, width;
         if (existingPatch){
         height = parseInt(existingPatch.style.height); // Get the height attribute
         width =  parseInt(existingPatch.style.width);
        console.log('existingPatch',height,width);
         }
         else{
         height = patchImg.getAttribute('height'); // Get the height attribute
         width = patchImg.getAttribute('width');
         }
       
        console.log( 'drag patch height',height,width)
        const rect = BackcenterBox.getBoundingClientRect();
        const mouseX = event.clientX - rect.left;
        const mouseY = event.clientY - rect.top;
        const offsetX = width / 2;
        const offsetY = height / 2;
        const patchX = mouseX - offsetX;
        const patchY = mouseY - offsetY;
        dropPatchbydraggingBack(dragPatch, patchX,patchY,height,width);
    } else {
        const rect = BackcenterBox.getBoundingClientRect();
        const mouseX = event.clientX - rect.left;
        const mouseY = event.clientY - rect.top;

        updatePosition(dragPatch1.id, mouseX, mouseY, height, width);
        BackcenterBox.removeEventListener('mousemove', mousemoveHandlerBack);
        BackcenterBox.removeEventListener('touchmove', mousemoveHandlerBack); // Add this line
    }
});


function updatePosition(patchId, x, y, width, height) {
    console.log('updating');
  adjustPatches(true);
    const frontArea = document.getElementById('Front-Area');
    const backArea = document.getElementById('Back-area');
    let patchDiv = document.getElementById(patchId);

    patchDiv.classList.remove('patch-'); // Temporarily remove class for manipulation

    let isFrontAreaVisible = frontArea.style.visibility === 'visible';
    let isBackAreaVisible = backArea.style.visibility === 'visible';

    if (isFrontAreaVisible || isBackAreaVisible) {
        // Handle touch events if applicable
        if (event.type && event.type.startsWith('touch')) {
            let touch = event.touches[0];
            x = touch.clientX;
            y = touch.clientY;
        }

        // Update the position of the patch
        patchDiv.style.top = (y - height / 2) + 'px';
        patchDiv.style.left = (x - width / 2) + 'px';


        // Update the patch position in the patches array
        let patchIndex = patches.findIndex(patch => patch.id === patchId);
        if (patchIndex !== -1) {
            patches[patchIndex].x = x;
            patches[patchIndex].y = y;

            // Get the container and patch bounding rectangles
            let containerRect = isFrontAreaVisible ?
                document.querySelector('.patches-container').getBoundingClientRect() :
                document.querySelector('.patches-containerr').getBoundingClientRect();
        }

        patchDiv.classList.add('patch-'); // Re-add class after manipulation
    }

    checkPatchesPosition();
    checkPatchDRAGGINGOverlapping();
}


function checkOverlapWithPatches(patchRect, patchClass) {
  console.log('enter function');

  if (document.getElementById('Front-Area').style.visibility === 'visible') {
      console.log('front area overlapping');
//         backPatches = document.querySelectorAll('.BackcenterBox > .patches-containerr > .patch-action');
//       backPatches.forEach(patch => {
//   patch.style.display = 'none';
// });
        patchDivs = document.querySelectorAll('.centerBox > .patches-container > .patch-action');
    } else {
       console.log('back area overlapping');
      
        patchDivs = document.querySelectorAll('.BackcenterBox > .patches-containerr > .patch-action');
    }
  
    let patches = document.querySelectorAll(patchClass);
    for (let i = 0; i < patches.length; i++) {
        let otherPatchRect = patches[i].getBoundingClientRect();
        if (patchRect.left < otherPatchRect.right &&
            patchRect.right > otherPatchRect.left &&
            patchRect.top < otherPatchRect.bottom &&
            patchRect.bottom > otherPatchRect.top) {
            return true;
        }
    }
    return false;
}




// centerBox.addEventListener('mousedown', function (event) {

//     const rect = centerBox.getBoundingClientRect();
//     const mouseX = event.clientX - rect.left;
//     const mouseY = event.clientY - rect.top;

//     // Check if there's an existing patch at the clicked position
//     let existingPatchIndex = patches.findIndex(patch => {

//         return mouseX >= patch.x - patch.width / 2 &&
//             mouseX <= patch.x + patch.width / 2 &&
//             mouseY >= patch.y - patch.height / 2 &&
//             mouseY <= patch.y + patch.height / 2;
//     });

//     // console.log("Existing patch index:", existingPatchIndex);

//     if (existingPatchIndex !== -1) {
//         // Existing patch found, set it as the dragPatch
//         dragPatch = patches[existingPatchIndex].patchDiv;

//         // Calculate offset for smoother dragging
//         offsetX = mouseX - patches[existingPatchIndex].x;
//         offsetY = mouseY - patches[existingPatchIndex].y;

//         // Prevent further propagation of the event
//         event.stopPropagation();
//         //   console.log('found');
//     } else {
//         //  console.log('not found');
//     }
// });

 centerBox.addEventListener('mousedown', function (event) {
            const rect = centerBox.getBoundingClientRect();
            const mouseX = event.clientX - rect.left;
            const mouseY = event.clientY - rect.top;
        
            // Check if there's an existing patch at the clicked position
            let existingPatchIndex = patches.findIndex(patch => {
                return mouseX >= patch.x &&
                    mouseX <= patch.x + patch.width &&
                    mouseY >= patch.y &&
                    mouseY <= patch.y + patch.height;
            });
        
            if (existingPatchIndex !== -1) {
                // Existing patch found, set it as the dragPatch
                dragPatch = patches[existingPatchIndex];
        
                // Calculate offset for smoother dragging
                offsetX = mouseX - patches[existingPatchIndex].x;
                offsetY = mouseY - patches[existingPatchIndex].y;
        
                // Prevent further propagation of the event
                event.stopPropagation();
            }
        });
  

centerBox.addEventListener('touchstart', function (event) {
  ismainDragging = false;
    console.log('touch StartTT')

});
centerBox.addEventListener('touchmove', function (event) {
  adjustPatches(true); // Deletes dataset values only

    let touchedElement = event.target;
 
     // Traverse up the DOM tree to find the div element with the specific class or attribute
     while (touchedElement && !touchedElement.classList.contains('patch-')) {
         touchedElement = touchedElement.parentElement;
     }
 
     if (touchedElement && touchedElement.classList.contains('patch-')) {
         var dragPatch1 = touchedElement;
         console.log('Touched element saved in dragpatch1:', dragPatch1);
     }
    console.log('nunder');
console.log(dragPatch1);
    if (event.touches.length === 1 && dragPatch1) {
         // Check for overlap with other patches
  console.log('dragPatch1',dragPatch1)
       checkPatchDRAGGINGOverlapping();
        const touch = event.touches[0];
        const rect = centerBox.getBoundingClientRect();
        const mouseX = touch.clientX - rect.left;
        const mouseY = touch.clientY - rect.top;

        // Calculate new position considering offset
        const newLeft = mouseX - offsetX;
        const newTop = mouseY - offsetY;

        // Update the position of the dragged patch
        dragPatch1.style.left = newLeft + 'px';
        dragPatch1.style.top = newTop + 'px';

        // Update the position in the patches array
        const patchIndex = patches.findIndex(patch => patch.id === dragPatch1.id);
        if (patchIndex !== -1) {
            patches[patchIndex].x = newLeft;
            patches[patchIndex].y = newTop;
        }

        // Prevent the browser from doing its default thing (scroll, zoom)
        event.preventDefault();
    }
  checkPatchesPosition();
});

centerBox.addEventListener('touchend', function (event) {
    // Reset dragPatch1
    dragPatch1 = null;
  
});

// BackcenterBox.addEventListener('mousedown', function (event) {
//     const rect = BackcenterBox.getBoundingClientRect();
//     const mouseX = event.clientX - rect.left;
//     const mouseY = event.clientY - rect.top;

//     // console.log("Mouse X:", mouseX, "Mouse Y:", mouseY);

//     // Check if there's an existing patch at the clicked position
//     let existingPatchIndex = patches.findIndex(patch => {

//         return mouseX >= patch.x - patch.width / 2 &&
//             mouseX <= patch.x + patch.width / 2 &&
//             mouseY >= patch.y - patch.height / 2 &&
//             mouseY <= patch.y + patch.height / 2;
//     });

//     // console.log("Existing patch index:", existingPatchIndex);

//     if (existingPatchIndex !== -1) {
//         // Existing patch found, set it as the dragPatch
//         dragPatch = patches[existingPatchIndex].patchDiv;

//         // Calculate offset for smoother dragging
//         offsetX = mouseX - patches[existingPatchIndex].x;
//         offsetY = mouseY - patches[existingPatchIndex].y;

//         // Prevent further propagation of the event
//         event.stopPropagation();
//         //   console.log('found');
//     } else {
//         //  console.log('not found');
//     }
// });

    BackcenterBox.addEventListener('mousedown', function (event) {
            const rect = centerBox.getBoundingClientRect();
            const mouseX = event.clientX - rect.left;
            const mouseY = event.clientY - rect.top;
        
            // Check if there's an existing patch at the clicked position
            let existingPatchIndex = patches.findIndex(patch => {
                return mouseX >= patch.x &&
                    mouseX <= patch.x + patch.width &&
                    mouseY >= patch.y &&
                    mouseY <= patch.y + patch.height;
            });
        
            if (existingPatchIndex !== -1) {
                // Existing patch found, set it as the dragPatch
                dragPatch = patches[existingPatchIndex];
        
                // Calculate offset for smoother dragging
                offsetX = mouseX - patches[existingPatchIndex].x;
                offsetY = mouseY - patches[existingPatchIndex].y;
        
                // Prevent further propagation of the event
                event.stopPropagation();
            }
        });

BackcenterBox.addEventListener('touchstart', function (event) {
    console.log('touch Start')
    // if (event.touches.length === 1) {
    //     const touch = event.touches[0];
    //     const rect = BackcenterBox.getBoundingClientRect();
    //     const mouseX = touch.clientX - rect.left;
    //     const mouseY = touch.clientY - rect.top;

    //     // Check if there's an existing patch at the touched position
    //     let existingPatchIndex = patches.findIndex(patch => {
    //         return mouseX >= patch.x - patch.width / 2 &&
    //             mouseX <= patch.x + patch.width / 2 &&
    //             mouseY >= patch.y - patch.height / 2 &&
    //             mouseY <= patch.y + patch.height / 2;
    //     });

    //     if (existingPatchIndex !== -1) {
    //         // Existing patch found, set it as the dragPatch
    //         dragPatch1 = document.getElementById(patches[existingPatchIndex].id);

    //         // Calculate offset for smoother dragging
    //         offsetX = mouseX - patches[existingPatchIndex].x;
    //         offsetY = mouseY - patches[existingPatchIndex].y;

    //         // Prevent further propagation of the event
    //         event.preventDefault();
    //         event.stopPropagation();
    //     }
    // }
});

BackcenterBox.addEventListener('touchmove', function (event) {
 let touchedElement = event.target;

    // Traverse up the DOM tree to find the div element with the specific class or attribute
    while (touchedElement && !touchedElement.classList.contains('patch-')) {
        touchedElement = touchedElement.parentElement;
    }

    if (touchedElement && touchedElement.classList.contains('patch-')) {
        var dragPatch1 = touchedElement;
        console.log('Touched element saved in dragpatch1:', dragPatch1);
    }
   console.log('nunder');
    if (event.touches.length === 1 && dragPatch1) {
      console.log('under');
       checkPatchDRAGGINGOverlapping();
        const touch = event.touches[0];
        const rect = BackcenterBox.getBoundingClientRect();
        const mouseX = touch.clientX - rect.left;
        const mouseY = touch.clientY - rect.top;

        // Calculate new position considering offset
        const newLeft = mouseX - offsetX;
        const newTop = mouseY - offsetY;

        // Update the position of the dragged patch
        dragPatch1.style.left = newLeft + 'px';
        dragPatch1.style.top = newTop + 'px';

        // Update the position in the patches array
        const patchIndex = patches.findIndex(patch => patch.id === dragPatch1.id);
        if (patchIndex !== -1) {
            patches[patchIndex].x = newLeft;
            patches[patchIndex].y = newTop;
        }

        // Prevent the browser from doing its default thing (scroll, zoom)
        event.preventDefault();
    }
  checkPatchesPosition();
});

BackcenterBox.addEventListener('touchend', function (event) {
    // Reset dragPatch1
    dragPatch1 = null;
});

// mousemoveHandler function remains unchanged
// function mousemoveHandler(event) {
//     if (dragPatch1) {
        
//         const rect = centerBox.getBoundingClientRect();
//         let mouseX, mouseY;

//         if (event.type.startsWith('touch')) {
//             const touch = event.touches[0];
//             mouseX = touch.clientX - rect.left;
//             mouseY = touch.clientY - rect.top;
//         } else {
//             mouseX = event.clientX - rect.left;
//             mouseY = event.clientY - rect.top;
//         }

//         // Calculate new position considering offset
//         const newLeft = mouseX - offsetX;
//         const newTop = mouseY - offsetY;

//         // Update the position of the dragged patch
//         dragPatch1.style.left = newLeft + 'px';
//         dragPatch1.style.top = newTop + 'px';

//         // Update the position in the patches array
//         const patchIndex = patches.findIndex(patch => patch.id === dragPatch1.id);
//         if (patchIndex !== -1) {
//             patches[patchIndex].x = newLeft;
//             patches[patchIndex].y = newTop;
//         }
//     }
// }

  function mousemoveHandler(event) {
            if (dragPatch1) {
                const rect = centerBox.getBoundingClientRect();
                const mouseX = event.clientX - rect.left;
                const mouseY = event.clientY - rect.top;
        
                // Update the position of the dragged patch
                dragPatch1.x = mouseX - offsetX;
                dragPatch1.y = mouseY - offsetY;
        
                // Update the position of the patch element
                const patchDiv = document.getElementById(dragPatch1.id);
                patchDiv.style.left = (mouseX - offsetX - patchDiv.offsetWidth / 2) + 'px';
                patchDiv.style.top = (mouseY - offsetY - patchDiv.offsetHeight / 2) + 'px';
            }
        }


// Event listener for mouse up event on canvas
centerBox.addEventListener('mouseup', function (event) {
    isDragging = false;
});

// function mousemoveHandlerBack(event) {
//     if (dragPatch1) {
//         const rect = BackcenterBox.getBoundingClientRect();
//         let mouseX, mouseY;

//         if (event.type.startsWith('touch')) {
//             const touch = event.touches[0];
//             mouseX = touch.clientX - rect.left;
//             mouseY = touch.clientY - rect.top;
//         } else {
//             mouseX = event.clientX - rect.left;
//             mouseY = event.clientY - rect.top;
//         }

//         // Calculate new position considering offset
//         const newLeft = mouseX - offsetX;
//         const newTop = mouseY - offsetY;

//         // Update the position of the dragged patch
//         dragPatch1.style.left = newLeft + 'px';
//         dragPatch1.style.top = newTop + 'px';

//         // Update the position in the patches array
//         const patchIndex = patches.findIndex(patch => patch.id === dragPatch1.id);
//         if (patchIndex !== -1) {
//             patches[patchIndex].x = newLeft;
//             patches[patchIndex].y = newTop;
//         }
//     }
// }

        function  mousemoveHandlerBack(event) {
            if (dragPatch1) {
                const rect = BackcenterBox.getBoundingClientRect();
                const mouseX = event.clientX - rect.left;
                const mouseY = event.clientY - rect.top;
        
                // Update the position of the dragged patch
                dragPatch1.x = mouseX - offsetX;
                dragPatch1.y = mouseY - offsetY;
        
                // Update the position of the patch element
                const patchDiv = document.getElementById(dragPatch1.id);
                patchDiv.style.left = (mouseX - offsetX - patchDiv.offsetWidth / 2) + 'px';
                patchDiv.style.top = (mouseY - offsetY - patchDiv.offsetHeight / 2) + 'px';
            }
        }

// Event listener for mouse up event on canvas
BackcenterBox.addEventListener('mouseup', function (event) {
    isDragging = false;
});
</script>
<!-- pop up open,close and patch-delete code -->
<script>
    $(document).ready(function() {
      $(document).on('click', function(event) {
        const patchElement = $(event.target).closest('.patch-');

        // if ($(event.target).hasClass('tidy-patches-delete-btn') && $('.patch-action').length) {
        //   const elementsToDelete = $('.patch-action, .patch-selected');
        //   elementsToDelete.each(function() {
        //     $(this).remove();
        //   });
        //     order = 1;
        // }
  //     if ($(event.target).hasClass('patches-customizations-clear-btn')) {
  //     const elementsToDelete = $('.patch-, .selected-patch-for-customization');
  //     elementsToDelete.each(function() {
  //         $(this).remove();
  //         $('.patches-customization-clear-alert-pop-up').css('display', 'none');
  //         checkPatchesPosition();
  //     });
  // }
  // order = 1;
      });
    });
</script>
<!-- back and front button code -->
<script>
    $(document).ready(function() {
       function showBackOrFront(event) {
        if (event.target.id === 'showFrontBtn') {
          $('#Front-Area').removeClass('image-hidden').css('visibility', 'visible');
          $('#showBackBtnn').removeClass('patches-customization-btn-active');
          $('#showFrontBtn').addClass('patches-customization-btn-active');
         $('#Back-area').css('visibility', 'hidden');
        } else if (event.target.id === 'showBackBtnn') {
            var backArea = document.getElementById('Back-area');
             backArea.style.top = '0px';
          // Hide front image and show back image
          $('#showFrontBtn').removeClass('patches-customization-btn-active');
          $('#showBackBtnn').addClass('patches-customization-btn-active');
          $('#Front-Area').addClass('image-hidden').css('visibility', 'hidden');
          $('#Back-area').removeClass('image-hidden').css('visibility', 'visible');
          const backPatches = document.querySelectorAll('.BackcenterBox > .patches-containerr > .patch-action');

  backPatches.forEach(patch => {
    patch.style.display = 'block';
  });

        }
      }
      $('#showFrontBtn').click(showBackOrFront);
      $('#showBackBtnn').click(showBackOrFront);
      $('#Front-Area').removeClass('image-hidden').css('visibility', 'visible');
    });
</script>
<!-- clear-button-code -->
<script>
     $(document).ready(function() {
      $('.patches-clear-btn').click(function() {
        console.log('clicked')
          $('.patches-customization-clear-alert-pop-up').addClass('patches-customization-active');
          // If you want to show the alert popup, you can toggle its display property
          $('.patches-customization-clear-alert-pop-up').css('display', 'block');

          setTimeout(function() {
      $('.patches-customization-container-overly').css('display', 'block');
       $('.patches-customization-editor-active').css('display', 'none');
      $('.delete-patches-wrapper-sidebar').css('display', 'none');

  }, 500); // 1000 milliseconds = 1 second

         setTimeout(function() {
              $('.patches-customization-clear-alert-pop-up').css('right', '0');
          }, 100);
      });
      $('.close-customization-clear-alert').click(function() {
          $('.patches-customization-clear-alert-pop-up').removeClass('patches-customization-active');
          $('.patches-customization-container-overly').css('display', 'none');
             $('.patches-customization-editor').css('display', 'block');
        $('.delete-patches-wrapper-sidebar').css('display', 'none');

      setTimeout(function() {
      $('.patches-customization-clear-alert-pop-up').css({
          'right': '-2400px'
      });

      setTimeout(function() {
          $('.patches-customization-clear-alert-pop-up').css({
              'display': 'none'
          });
      }, 900); // Adjust the timeout duration as needed
  }, 100);


      });
        $('.patches-customizations-clear-footer-btns').click(function() {
          $('.patches-customization-clear-alert-pop-up').removeClass('patches-customization-active');
          $('.patches-customization-container-overly').css('display', 'none');
             $('.patches-customization-editor').css('display', 'block');
        $('.delete-patches-wrapper-sidebar').css('display', 'none');

      setTimeout(function() {
      $('.patches-customization-clear-alert-pop-up').css({
          'right': '-2400px'
      });

      setTimeout(function() {
          $('.patches-customization-clear-alert-pop-up').css({
              'display': 'none'
          });
      }, 900); // Adjust the timeout duration as needed
  }, 100);


      });
  });
</script>
<!-- offcanvasopen-function -->
<script>
    $(document).ready(function(){
    $('#offcanvas-menu').addClass('show');

  });
</script>
<!-- Editor-bar-code -->
<script>
  $(document).on('click', '.edit-btn-patch-selected', function(event) {
     $('.selected-patch-for-customization').removeClass('patch-selected').find('.selected-patch-order').remove();
     $('.selected-patch-for-customization').removeClass('patch-selected-by-both');
     $('.patch-').removeClass('patch-action').removeAttr('order-data');
     order =1;
     var $clickedPatch = $(this);
     var patchId = $clickedPatch.attr('id');
       $('#' + patchId).addClass('patch-action');
     var $targetPatch = $('[data-patch-id="' + patchId + '"]');
     $targetPatch.addClass('patch-selected-by-both')
          if ($('.edit-btn-patch-selected').hasClass('patch-selected-by-both')) {
              $('.delete-patches-wrapper-sidebar > .tidy-patches-delete-btn-wrraper').show();
          } else {
              $('.delete-patches-wrapper-sidebar > .tidy-patches-delete-btn-wrraper').hide();
          }
         });
</script>
<script>
 $(document).ready(function() {
    // Event delegation for dynamically created .patch- elements
  
 $(document).on('click', '.patch-', function(event) {
   if (!ismainDragging) {
        console.log('Element clicked');
  
        // Your click functionality here
    const patchElement = $(event.target).closest('.patch-');
 // patchElement.toggleClass('patch-open-editor');
          var $clickedPatch = $(this);
       if ($clickedPatch.hasClass('patch-action')) {
         console.log('patch-action exists')
         $('.selected-patch-for-customization').removeClass('patch-selected').find('.selected-patch-order').remove();
         $('.selected-patch-for-customization').removeClass('patch-selected-by-btn');
         $('.edit-btn-patch-selected').removeClass('patch-selected-by-both');
         $clickedPatch.removeClass('patch-action').removeAttr('order-data'); 
             var patchId = $clickedPatch.attr('id'); // Get the id attribute
        console.log("Clicked patch id: " + patchId); // Log the id attribute value

        // Use the attribute selector to find the element with the matching data-patch-id
        var $targetPatch = $('[data-patch-id="' + patchId + '"]');
        console.log("Target patch element:", $targetPatch); // Log the selected element
          if (document.getElementById('Front-Area').style.visibility === 'visible') {
            order=1;
            // Set the order for the clicked patch
            $targetPatch.addClass('patch-selected').append('<span class="selected-patch-order">' + order + '</span>');
            $clickedPatch.addClass('patch-action').attr('order-data', order);
            order++;
             }
      else if (document.getElementById('Back-area').style.visibility === 'visible') {
             orderBack = 1;
            // Set the order for the clicked patch
            $targetPatch.addClass('patch-selected').append('<span class="selected-patch-order">' + orderBack + '</span>');
            $clickedPatch.addClass('patch-action').attr('order-data', orderBack);
            orderBack++;
     }
       }
       else{
          var patchId = $clickedPatch.attr('id'); // Get the id attribute
        console.log("Clicked patch id: " + patchId); // Log the id attribute value

        // Use the attribute selector to find the element with the matching data-patch-id
        var $targetPatch = $('[data-patch-id="' + patchId + '"]');
        console.log("Target patch element:", $targetPatch); // Log the selected element

        // Check if the target element is found
        if ($targetPatch.length) {
          
                   $('.selected-patch-for-customization').removeClass('patch-selected').find('.selected-patch-order').remove();
            $('.patch-').removeClass('patch-action').removeAttr('order-data');

            
         

  if (document.getElementById('Front-Area').style.visibility === 'visible') {
            order=1;
            // Set the order for the clicked patch
            $targetPatch.addClass('patch-selected').append('<span class="selected-patch-order">' + order + '</span>');
            $clickedPatch.addClass('patch-action').attr('order-data', order);
            order++;
     changefillColors()
             }
      else if (document.getElementById('Back-area').style.visibility === 'visible') {
             orderBack = 1;
            // Set the order for the clicked patch
            $targetPatch.addClass('patch-selected').append('<span class="selected-patch-order">' + orderBack + '</span>');
            $clickedPatch.addClass('patch-action').attr('order-data', orderBack);
            orderBack++;
        console.log('click on back image');
         changefillColors()
     }
          
          // Check if the class was added
          if ($targetPatch.hasClass('patch-selected')) {
            console.log('Class patch-selected added to element with data-patch-id ' + patchId);
          } else {
            console.log('Class patch-selected not added to element with data-patch-id ' + patchId);
          }
        } else {
          console.log('No element found with data-patch-id ' + patchId);
        }
           $('.patch-').removeClass('patch-action'); // Remove the class from all elements
     $(this).addClass('patch-action');
       }
       
   
    // $targetPatch.removeClass('patch-selected-by-btn');
    
    $('.patches-customization-editor').addClass('patches-customization-editor-active');
    $('.patches-customization-editor').css('display', 'block');
    $('.patches-editor-wrapper').css('display', 'none');
    $('.only-mobile-colors-wrapper').css('display', 'none');
    
    if (window.matchMedia("(max-width: 768px)").matches){
       $('.only-mobile-tdy-header').css('display', 'block');
    }else{
       $('.only-mobile-tdy-header').css('display', 'none');  
}

      if (document.getElementById('Front-Area').style.visibility === 'visible') {
          $('.back-tdiy-patches-btn').removeClass('tdiy-patches-btn-active')
        $('.front-tdiy-patches-btn').addClass('tdiy-patches-btn-active')
        $('.select-patches-for-back').removeClass('select-patches-active')
        $('.select-patches-for-front').addClass('select-patches-active')
          $('.patches-container .patch-').each(function() {
        var patchId = $(this).attr('id');
       var actionPatch = $(this); // Assuming 'this' is a jQuery object
var patchActionElement = actionPatch.find('.patch-action');
  console.log('patchActionElement',patchActionElement);
        
        // Check if the patch with the same ID already exists in .select-patches
        if (!$('.select-patches-for-front').find('[data-patch-id="' + patchId + '"]').length) {
            // Get image source
            var imageSrc = $(this).find('.patch-image').attr('src');

            // Create a new div with class .selected-patch-for-customization
            var selectedPatchDiv = $(`<div class="selected-patch-for-customization selected-patch-for-customization-for-front" id="${patchId}"></div>`);

            // Create an img element with the same src as the original image
            var imageElement = $('<img>').attr('src', imageSrc);

            // Append the image to the new div
            selectedPatchDiv.append(imageElement);

            // Append the patchId as a data attribute
            selectedPatchDiv.attr('data-patch-id', patchId);

            // Append the new div to .select-patches
            $('.select-patches-for-front').append(selectedPatchDiv);
        }
    });
    }
      else if (document.getElementById('Back-area').style.visibility === 'visible') {
        $('.front-tdiy-patches-btn').removeClass('tdiy-patches-btn-active')
        $('.back-tdiy-patches-btn').addClass('tdiy-patches-btn-active')
        $('.select-patches-for-front').removeClass('select-patches-active')
        $('.select-patches-for-back').addClass('select-patches-active')
        $('.patches-containerr .patch-').each(function() {
        var patchId = $(this).attr('id');
        
        // Check if the patch with the same ID already exists in .select-patches
        if (!$('.select-patches-for-back').find('[data-patch-id="' + patchId + '"]').length) {
            // Get image source
            var imageSrc = $(this).find('.patch-image').attr('src');

            // Create a new div with class .selected-patch-for-customization
            var selectedPatchDiv = $(`<div class="selected-patch-for-customization selected-patch-for-customization-for-back" id="${patchId}"></div>`);

            // Create an img element with the same src as the original image
            var imageElement = $('<img>').attr('src', imageSrc);

            // Append the image to the new div
            selectedPatchDiv.append(imageElement);

            // Append the patchId as a data attribute
            selectedPatchDiv.attr('data-patch-id', patchId);

            // Append the new div to .select-patches
            $('.select-patches-for-back').append(selectedPatchDiv);
        }
    });
     
     }

    setTimeout(function() {
        $('.patches-customization-editor').css('right', '0');
    }, 100);
        }
    ismainDragging = false; // Reset the flag
   changefillColors();
});
$(document).on('click', '.patches-tidy-editor-btn', function(event) {
   if (document.getElementById('Front-Area').style.visibility === 'visible') {
          $('.back-tdiy-patches-btn').removeClass('tdiy-patches-btn-active')
        $('.front-tdiy-patches-btn').addClass('tdiy-patches-btn-active')
        $('.select-patches-for-back').removeClass('select-patches-active')
        $('.select-patches-for-front').addClass('select-patches-active')
          $('.patches-container .patch-').each(function() {
        var patchId = $(this).attr('id');
       var actionPatch = $(this); // Assuming 'this' is a jQuery object
var patchActionElement = actionPatch.find('.patch-action');
  console.log('patchActionElement',patchActionElement);
        
        // Check if the patch with the same ID already exists in .select-patches
        if (!$('.select-patches-for-front').find('[data-patch-id="' + patchId + '"]').length) {
            // Get image source
            var imageSrc = $(this).find('.patch-image').attr('src');

            // Create a new div with class .selected-patch-for-customization
            var selectedPatchDiv = $(`<div class="selected-patch-for-customization selected-patch-for-customization-for-front" id="${patchId}"></div>`);

            // Create an img element with the same src as the original image
            var imageElement = $('<img>').attr('src', imageSrc);

            // Append the image to the new div
            selectedPatchDiv.append(imageElement);

            // Append the patchId as a data attribute
            selectedPatchDiv.attr('data-patch-id', patchId);

            // Append the new div to .select-patches
            $('.select-patches-for-front').append(selectedPatchDiv);
        }
    });
    }
      else if (document.getElementById('Back-area').style.visibility === 'visible') {
        $('.front-tdiy-patches-btn').removeClass('tdiy-patches-btn-active')
        $('.back-tdiy-patches-btn').addClass('tdiy-patches-btn-active')
        $('.select-patches-for-front').removeClass('select-patches-active')
        $('.select-patches-for-back').addClass('select-patches-active')
        $('.patches-containerr .patch-').each(function() {
        var patchId = $(this).attr('id');
        
        // Check if the patch with the same ID already exists in .select-patches
        if (!$('.select-patches-for-back').find('[data-patch-id="' + patchId + '"]').length) {
            // Get image source
            var imageSrc = $(this).find('.patch-image').attr('src');

            // Create a new div with class .selected-patch-for-customization
            var selectedPatchDiv = $(`<div class="selected-patch-for-customization selected-patch-for-customization-for-back" id="${patchId}"></div>`);

            // Create an img element with the same src as the original image
            var imageElement = $('<img>').attr('src', imageSrc);

            // Append the image to the new div
            selectedPatchDiv.append(imageElement);

            // Append the patchId as a data attribute
            selectedPatchDiv.attr('data-patch-id', patchId);

            // Append the new div to .select-patches
            $('.select-patches-for-back').append(selectedPatchDiv);
        }
    });
     
     }


    const patchElement = $(event.target).closest('.patch-');
  patchElement.toggleClass('patch-open-editor');
    
    $('.patches-customization-editor').addClass('patches-customization-editor-active');
    $('.patches-customization-editor').css('display', 'block');
    $('.patches-editor-wrapper').css('display', 'none');
    $('.only-mobile-colors-wrapper').css('display', 'none');
    $('.only-mobile-tdy-header').css('display', 'block');

      if (document.getElementById('Front-Area').style.visibility === 'visible') {
          $('.back-tdiy-patches-btn').removeClass('tdiy-patches-btn-active')
        $('.front-tdiy-patches-btn').addClass('tdiy-patches-btn-active')
        $('.select-patches-for-back').removeClass('select-patches-active')
        $('.select-patches-for-front').addClass('select-patches-active')
       
    } else if (document.getElementById('Back-area').style.visibility === 'visible') {
        $('.front-tdiy-patches-btn').removeClass('tdiy-patches-btn-active')
        $('.back-tdiy-patches-btn').addClass('tdiy-patches-btn-active')
        $('.select-patches-for-front').removeClass('select-patches-active')
        $('.select-patches-for-back').addClass('select-patches-active')
     
     }

    setTimeout(function() {
        $('.patches-customization-editor').css('right', '0');
    }, 100);
});

    // Click event listener for closing the editor
    $('.close-patches-customization-editor').click(function() {
        $('.patches-customization-editor').removeClass('patches-customization-editor-active');
        $('.edit-left-btn').removeClass('patches-customization-tidy-delete-btn-active');
        $('.tidy-right-btn').removeClass('patches-customization-tidy-delete-btn-active');
      $('.patches-editor-wrapper').css('display', 'block');
      $('.only-mobile-tdy-header').css('display', 'none');
      $('.delete-patches-wrapper-sidebar').css('display', 'none');
       if (window.matchMedia("(max-width: 768px)").matches){
        $('.only-mobile-colors-wrapper').css('display', 'block');  
    }else{
       $('.only-mobile-colors-wrapper').css('display', 'none');  
}
        setTimeout(function() {
            $('.patches-customization-editor').css({
                'right': '-2400px'
            });
            setTimeout(function() {
                $('.patches-customization-editor').css({
                    'display': 'none'
                });
            }, 900);
        }, 100);
    });

     $('.tidy-patches-apply-changes-btn').click(function() {
        $('.patches-customization-editor').removeClass('patches-customization-editor-active');
          $('.edit-left-btn').removeClass('patches-customization-tidy-delete-btn-active');
       $('.tidy-right-btn').removeClass('patches-customization-tidy-delete-btn-active');
      $('.patches-editor-wrapper').css('display', 'block');
      $('.only-mobile-tdy-header').css('display', 'none');
       $('.delete-patches-wrapper-sidebar').css('display', 'none');
       if (window.matchMedia("(max-width: 768px)").matches){
        $('.only-mobile-colors-wrapper').css('display', 'block');  
    }else{
       $('.only-mobile-colors-wrapper').css('display', 'none');  
}
        setTimeout(function() {
            $('.patches-customization-editor').css({
                'right': '-2400px'
            });
            setTimeout(function() {
                $('.patches-customization-editor').css({
                    'display': 'none'
                });
            }, 900);
        }, 100);
    });
});
</script>
<script>
    $(document).ready(function() {
      $('.edit-left-btn').on('click', function() {
          if ($(this).hasClass('patches-customization-tidy-delete-btn-active')) {
              console.log('yes');
          }

          if ($('.edit-btn-patch-selected').hasClass('patch-selected-by-both')) {
              $('.delete-patches-wrapper-sidebar > .tidy-patches-delete-btn-wrraper').show();
          } else {
              $('.delete-patches-wrapper-sidebar > .tidy-patches-delete-btn-wrraper').hide();
          }

          console.log('edit-btn-patch-selected');
          $('.delete-patches-wrapper-sidebar > .tidy-patches-wrraper > .select-patches > .selected-patch-for-customization').addClass('edit-btn-patch-selected');
      });
  });
</script>
<script>
    $(document).ready(function() {
     // var order = 1; // Initialize order counter
     // var orderBack = 1;

        $(document).on('click', '.selected-patch-for-customization-for-front', function(event) {
            var $clickedPatch = $(this);
            var patchId = $clickedPatch.data('patch-id');

           console.log('order',order)
            if (!$clickedPatch.hasClass('patch-selected')) {
              if (!$clickedPatch.hasClass('edit-btn-patch-selected')){
                     // If not selected, add order and class

                $clickedPatch.addClass('patch-selected').append('<span class="selected-patch-order">' + order + '</span>');
                var $targetPatch = $('[data-patch-id="' + patchId + '"]');
                 $targetPatch.addClass('patch-selected-by-both')
                 // $targetPatch.removeClass('patch-transparent-border')
                 // $('#' + patchId).removeClass('patch-transparent-border');
                $('#' + patchId).addClass('patch-action').attr('order-data', order);

                order++;
                changefillColors();
              }

            } else {
                // If already selected, remove from selection and order

                $clickedPatch.removeClass('patch-selected').find('.selected-patch-order').remove();
              console.log('removing patch action and patch selection');
              console.log(patchId);


               $('#' + patchId).removeClass('patch-action').removeAttr('order-data');
                    // Update orders of other selected patches
                var currentOrder = 1;

                  var $targetPatch = $('[data-patch-id="' + patchId + '"]');
                 $targetPatch.removeClass('patch-selected-by-both')

                $('.selected-patch-for-customization-for-front.patch-selected').each(function() {
                    var $patch = $(this);
                     var patchId = $patch.data('patch-id');
                    $patch.find('.selected-patch-order').text(currentOrder);
                       $('#' + patchId).addClass('patch-action').attr('order-data', currentOrder);
                    currentOrder++;
                });

                order--; // Decrement the order counter
               changefillColors();
            }

            // Log the target .patch- element to the console


            event.stopPropagation(); // Prevent click event from bubbling up
            if ($('.edit-btn-patch-selected').hasClass('patch-selected-by-both')) {
                $('.delete-patches-wrapper-sidebar > .tidy-patches-delete-btn-wrraper').show();
            } else {
                $('.delete-patches-wrapper-sidebar > .tidy-patches-delete-btn-wrraper').hide();
            }
        });
        $(document).on('click', '.selected-patch-for-customization-for-back', function(event) {
          console.log('kr diya ,mgy click')
                 
            var $clickedPatch = $(this);
            var patchId = $clickedPatch.data('patch-id');
            if (!$clickedPatch.hasClass('patch-selected')) {
                // // If not selected, add order and class
                // $clickedPatch.addClass('patch-selected').append('<span class="selected-patch-order">' + orderBack + '</span>');
                // $('#' + patchId).addClass('patch-action').attr('order-data', orderBack);
                // orderBack++;

                if (!$clickedPatch.hasClass('edit-btn-patch-selected')){
                     // If not selected, add order and class

                $clickedPatch.addClass('patch-selected').append('<span class="selected-patch-order">' + orderBack + '</span>');
                var $targetPatch = $('[data-patch-id="' + patchId + '"]');
                 $targetPatch.addClass('patch-selected-by-both')
                $('#' + patchId).addClass('patch-action').attr('order-data', orderBack);
                orderBack++;
                    changefillColors();
              }

            } else {
                // If already selected, remove from selection and order
                $clickedPatch.removeClass('patch-selected').find('.selected-patch-order').remove();
               $('#' + patchId).removeClass('patch-action').removeAttr('order-data');
                    // Update orders of other selected patches
                var currentOrder = 1;
                  var $targetPatch = $('[data-patch-id="' + patchId + '"]');
                 $targetPatch.removeClass('patch-selected-by-both')
                $('.selected-patch-for-customization-for-back.patch-selected').each(function() {
                    var $patch = $(this);
                     var patchId = $patch.data('patch-id');
                    $patch.find('.selected-patch-order').text(currentOrder);
                      $('#' + patchId).addClass('patch-action').attr('order-data', currentOrder);
                    currentOrder++;
                });

                orderBack--; // Decrement the order counter
               changefillColors();
            }

            // Log the target .patch- element to the console


            event.stopPropagation(); // Prevent click event from bubbling up
        });

          $(document).on('click', '.patches-customizations-clear-btn', function(event) {
            const elementsToDelete = $('.patch-, .selected-patch-for-customization');
            elementsToDelete.each(function() {
                $(this).remove();
                $('.patches-customization-clear-alert-pop-up').css('display', 'none');
                 $('.patches-customization-container-overly').css('display', 'none');
                $('.patches-editor-wrapper').css('display', 'block');
              $('.delete-patches-wrapper-sidebar').css('display', 'none');
              $('.patches-customization-editor').css('display', 'none');
                checkPatchesPosition();
            });

            // Reset the order counter to 1
            order = 1;
            orderBack = 1;
              if ($('.edit-btn-patch-selected').hasClass('patch-selected-by-both')) {
                $('.delete-patches-wrapper-sidebar > .tidy-patches-delete-btn-wrraper').show();
            } else {
                $('.delete-patches-wrapper-sidebar > .tidy-patches-delete-btn-wrraper').hide();
            }
        });
      $(document).on('click', function(event) {
        // Check if the clicked target has the class 'tidy-patches-delete-btn'
        if ($(event.target).hasClass('tidy-patches-delete-btn') && $('.patch-action').length) {
            // Select elements with classes 'patch-action' and 'patch-selected'
            const elementsToDelete = $('.patch-action, .patch-selected, .patch-selected-by-btn, .patch-selected-by-both');

            // Remove each of the selected elements
            elementsToDelete.each(function() {
                $(this).remove();
            });

            // Reset the order variable
            order = 1;
            orderBack = 1;
        }
    });

    });
</script>
{% comment %} <!-- code of alignments patches--> {% endcomment %}
<script>
// Get references to the buttons and the patches container
const alignVerticalBtn = document.getElementById('align-vertical');
const alignHorizontalBtn = document.getElementById('align-horizontal');
const alignDiagonalLeftBtn = document.getElementById('align-diagonal-left');
const alignDiagonalRightBtn = document.getElementById('align-diagonal-right');
const patchesContainer = document.querySelector('.patches-container');
const patchesBackContainer = document.querySelector('.patches-containerr');





// Get references to the gap buttons
const gap10Btn = document.getElementById('gap10');
const gap15Btn = document.getElementById('gap15');
const gap20Btn = document.getElementById('gap20');
const gap25Btn = document.getElementById('gap25');

// Set default gap value
let gapValue = 0; // Default gap value is 15px

// Add event listeners to the gap buttons
gap10Btn.addEventListener('click', () => setGapValue(2));
gap15Btn.addEventListener('click', () => setGapValue(4));
gap20Btn.addEventListener('click', () => setGapValue(6));
gap25Btn.addEventListener('click', () => setGapValue(8));

// Function to set the gap value
function setGapValue(value) {
    gapValue = value;
    // Call the appropriate alignment function based on the current state of the application
    const alignmentFunction = getAlignmentFunction();
    alignmentFunction();
}


function getAlignmentFunction() {
   
    const patchesContainer = document.querySelector('.patches-container');
    const currentFunctionId = patchesContainer.getAttribute('data-function-id');
    const currentalignmentnId = patchesContainer.getAttribute('data-alignment-id');
    console.log(currentFunctionId); // Log the current function ID
    console.log('this is alignment id',currentalignmentnId); 
    
    switch (currentalignmentnId) {
        case 'align-horizontal':
        return alignHorizontal;
        case 'align-vertical':
            return alignVertical;
        case 'align-diagonal-left':
           return alignDiagonalLeft;
        case 'align-diagonal-right':
          return alignDiagonalRight;
        default:
            return givingGap;
    }

}

function givingGap() {
    const sortedPatches = sortPatchesByOrder();
    sortedPatches.forEach((patch, index) => {
        const computedStyle = window.getComputedStyle(patch);
        const prevPatch = index > 0 ? sortedPatches[index - 1] : null;
        let leftPosition;
        if (index === 0) {
            // For the first patch, use its current left value
            leftPosition = parseFloat(computedStyle.getPropertyValue('left'));
        } else if (prevPatch) {
            // For subsequent patches, use the sum of left value, width, and gap value of the previous patch
            const prevLeftValue = parseFloat(window.getComputedStyle(prevPatch).getPropertyValue('left'));
            const prevWidth = parseFloat(window.getComputedStyle(prevPatch).getPropertyValue('width'));
            leftPosition = prevLeftValue + prevWidth + gapValue;
        }
        patch.style.left = `${leftPosition}px`;
        console.log(`Patch at index ${index} - left position: ${leftPosition}px`);
    });

    checkPatchesPosition();
}



function alignHorizontal() {
    const patchesContainer = document.querySelector('.patches-container');
    const patchesBackContainer = document.querySelector('.patches-containerr');
    let patches;
    
    if (document.getElementById('Front-Area').style.visibility === 'visible') {
        patches = Array.from(patchesContainer.querySelectorAll('.patch-action'));
    } else {
        patches = Array.from(patchesBackContainer.querySelectorAll('.patch-action'));
    }

    const patchActionCount = patches.length;
    console.log('Number of patches:', patchActionCount);

    if (patchActionCount < 2) {
        return; // Exit the function if less than 2 patches have .patch-action
    }

    // Sort patches based on the order-data attribute
    patches.sort((a, b) => {
        const orderA = parseInt(a.getAttribute('order-data'), 10);
        const orderB = parseInt(b.getAttribute('order-data'), 10);
        return orderA - orderB;
    });

    // Calculate the average top position
    const topPositions = patches.map(patch => patch.offsetTop);
    const averageTop = topPositions.reduce((sum, top) => sum + top, 0) / topPositions.length;
    console.log('Average top position:', averageTop);

    // Calculate the most common left position
    const leftPositions = patches.map(patch => patch.offsetLeft);
    const mostCommonLeft = calculateMostCommonLeft(leftPositions);
    console.log('Most common left position:', mostCommonLeft);

    // Initialize the left position for alignment
    let leftPosition = parseFloat(mostCommonLeft); // Ensure leftPosition is a number

    // Array to store calculated positions for debugging
    let patchPositions = [];

    patches.forEach((patch, index) => {
        // Set the top position of all patches to the average top position
        patch.style.top = `${averageTop}px`;

        if (index === 0) {
            // For the first patch, adjust left to the most common left position
            patch.style.left = `${leftPosition}px`;
        } else {
            // For subsequent patches, position them relative to the previous patch
            const previousPatch = patches[index - 1];
            const previousPatchWidth = parseFloat(previousPatch.getBoundingClientRect().width); // Ensure width is a number
            leftPosition += previousPatchWidth  + gapValue; // Move to the position to the right of the previous patch
            patch.style.left = `${leftPosition}px`;
        }

        // Store the new position for debugging
        patchPositions.push({
            id: patch.getAttribute('order-data'),
            top: patch.style.top,
            left: patch.style.left
        });

        console.log(`Patch ${patch.getAttribute('order-data')} new top position: ${patch.style.top}`);
        console.log(`Patch ${patch.getAttribute('order-data')} new left position: ${patch.style.left}`);
    });

    console.log('Final positions:', patchPositions);

    checkPatchesPosition();
    checkPatchOverlapping();
}

function calculateMostCommonLeft(leftPositions) {
    const frequencyMap = {};
    leftPositions.forEach(position => {
        if (!frequencyMap[position]) {
            frequencyMap[position] = 0;
        }
        frequencyMap[position]++;
    });

    let mostCommonLeft = leftPositions[0];
    let maxCount = 0;
    for (const position in frequencyMap) {
        if (frequencyMap[position] > maxCount) {
            maxCount = frequencyMap[position];
            mostCommonLeft = position;
        }
    }

    return mostCommonLeft;
}
function alignVertical() {
    const patchesContainer = document.querySelector('.patches-container');
    const patchesBackContainer = document.querySelector('.patches-containerr');
    let patches;
    
    if (document.getElementById('Front-Area').style.visibility === 'visible') {
        patches = Array.from(patchesContainer.querySelectorAll('.patch-action'));
    } else {
        patches = Array.from(patchesBackContainer.querySelectorAll('.patch-action'));
    }

    const patchActionCount = patches.length;
    console.log('Number of patches:', patchActionCount);

    if (patchActionCount < 2) {
        return; // Exit the function if less than 2 patches have .patch-action
    }

    // Sort patches based on the order-data attribute
    patches.sort((a, b) => {
        const orderA = parseInt(a.getAttribute('order-data'), 10);
        const orderB = parseInt(b.getAttribute('order-data'), 10);
        return orderA - orderB;
    });

    // Calculate the most common top position
    const topPositions = patches.map(patch => patch.offsetTop);
    const mostCommonTop = calculateMostCommonTop(topPositions);
    console.log('Most common top position:', mostCommonTop);

    // Calculate the average left position
    const leftPositions = patches.map(patch => patch.offsetLeft);
    const averageLeft = leftPositions.reduce((sum, left) => sum + left, 0) / leftPositions.length;
    console.log('Average left position:', averageLeft);
    
    // Initialize the top position for alignment
    let topPosition = parseFloat(mostCommonTop); // Ensure topPosition is a number

    // Array to store calculated positions for debugging
    let patchPositions = [];

    patches.forEach((patch, index) => {
        // Set the left position of all patches to the average left position
        patch.style.left = `${averageLeft}px`;

        if (index === 0) {
            // For the first patch, adjust top to the most common top position
            patch.style.top = `${topPosition}px`;
        } else {
            // For subsequent patches, position them relative to the previous patch
            const previousPatch = patches[index - 1];
            const previousPatchHeight = parseFloat(previousPatch.offsetHeight); // Ensure height is a number
            topPosition += previousPatchHeight + gapValue; // Move to the position below the previous patch
            patch.style.top = `${topPosition}px`;
        }

        // Store the new position for debugging
        patchPositions.push({
            id: patch.getAttribute('order-data'),
            top: patch.style.top,
            left: patch.style.left
        });

        console.log(`Patch ${patch.getAttribute('order-data')} new top position: ${patch.style.top}`);
        console.log(`Patch ${patch.getAttribute('order-data')} new left position: ${patch.style.left}`);
    });

    console.log('Final positions:', patchPositions);

    checkPatchesPosition();
    checkPatchOverlapping();
}

function calculateMostCommonTop(topPositions) {
    const frequencyMap = {};
    topPositions.forEach(position => {
        if (!frequencyMap[position]) {
            frequencyMap[position] = 0;
        }
        frequencyMap[position]++;
    });

    let mostCommonTop = topPositions[0];
    let maxCount = 0;
    for (const position in frequencyMap) {
        if (frequencyMap[position] > maxCount) {
            maxCount = frequencyMap[position];
            mostCommonTop = position;
        }
    }

    return mostCommonTop;
}

function alignDiagonalLeft() {
    const patchesContainer = document.querySelector('.patches-container');
    const patchesBackContainer = document.querySelector('.patches-containerr');
    let patchActionCount;

    let patches;
    if (document.getElementById('Front-Area').style.visibility === 'visible') {
        patches = patchesContainer.querySelectorAll('.patch-action');
    } else {
        patches = patchesBackContainer.querySelectorAll('.patch-action');
    }

    patchActionCount = patches.length;
    console.log(patchActionCount);

    if (patchActionCount < 2) {
        return; // Exit the function if less than 2 patches have .patch-action
    }
    
    const sortedPatches = sortPatchesByOrder();

    // Get the initial position of the first patch using offsetLeft and offsetTop
    const firstPatch = sortedPatches[0];
    const initialLeft = firstPatch.offsetLeft;
    const initialTop = firstPatch.offsetTop;

    // Keep the first patch in its original position
    firstPatch.style.position = 'absolute';
    firstPatch.style.left = `${initialLeft}px`;
    firstPatch.style.top = `${initialTop}px`;

    let leftPosition = initialLeft;
    let topPosition = initialTop;

    // Adjust positions for other patches
    sortedPatches.forEach((patch, index) => {
        if (index > 0) {
            const previousPatch = sortedPatches[index - 1];
            const previousPatchWidth = previousPatch.getBoundingClientRect().width;
            const previousPatchHeight = previousPatch.getBoundingClientRect().height;

            // Update position based on the previous patch
            leftPosition += previousPatchWidth + gapValue;
            topPosition += previousPatchHeight + gapValue;

            patch.style.position = 'absolute';
            patch.style.left = `${leftPosition}px`;
            patch.style.top = `${topPosition}px`;
        }
    });

    checkPatchesPosition();
    checkPatchOverlapping();
}

function alignDiagonalRight() {
    const patchesContainer = document.querySelector('.patches-container');
    const patchesBackContainer = document.querySelector('.patches-containerr');
    let patches;

    if (document.getElementById('Front-Area').style.visibility === 'visible') {
        patches = patchesContainer.querySelectorAll('.patch-action');
    } else {
        patches = patchesBackContainer.querySelectorAll('.patch-action');
    }

    const patchActionCount = patches.length;
    console.log(patchActionCount);

    if (patchActionCount < 2) {
        return; // Exit the function if less than 2 patches have .patch-action
    }

    const sortedPatches = sortPatchesByOrder();
    console.log('this is sorted', sortedPatches);

    // Get the initial position of the first patch
    const firstPatch = sortedPatches[0];
    const initialRight = parseFloat(window.getComputedStyle(firstPatch).right) || 0;
    const initialTop = parseFloat(window.getComputedStyle(firstPatch).top) || 0;

    // Keep the first patch in its original position
    firstPatch.style.position = 'absolute';
    firstPatch.style.right = `${initialRight}px`;
    firstPatch.style.top = `${initialTop}px`;
    firstPatch.style.left = 'auto'; // Reset left property

    let rightPosition = initialRight;
    let topPosition = initialTop;

    // Adjust positions for other patches
    sortedPatches.forEach((patch, index) => {
        if (index > 0) {
            const previousPatch = sortedPatches[index - 1];
            const previousPatchWidth = previousPatch.getBoundingClientRect().width;
            const previousPatchHeight = previousPatch.getBoundingClientRect().height;

            // Update position based on the previous patch
            rightPosition += previousPatchWidth + gapValue;
            topPosition += previousPatchHeight + gapValue;

            patch.style.position = 'absolute';
            patch.style.right = `${rightPosition}px`;
            patch.style.top = `${topPosition}px`;
            patch.style.left = 'auto'; // Reset left property
        }
    });

    checkPatchesPosition();
    checkPatchOverlapping();
}

function sortPatchesByOrder() {
    let sortedPatches; // Declare sortedPatches variable here

   
        let patchActions; // Declare patchActions variable here

        if (document.getElementById('Front-Area').style.visibility === 'visible') {
            patchActions = patchesContainer.querySelectorAll('.patch-action');
        } else {
            patchActions = patchesBackContainer.querySelectorAll('.patch-action');
        }

        // Continue with the rest of your function
       sortedPatches = Array.from(patchActions)
            .filter(patch => patch.classList.contains('patch-action')) // Filter out patches without the patch-action class
            .sort((a, b) => {
                const orderA = parseInt(a.getAttribute('order-data'));
                const orderB = parseInt(b.getAttribute('order-data'));
                return orderA - orderB;
            });

        console.log(sortedPatches); // Log sortedPatches here


    return sortedPatches; // Return sortedPatches here (outside of $(document).ready())
}

function checkPatchesPosition() {
  const product = {{ product | json }};
      if (Array.isArray(product.tags) && product.tags.includes('bag-bound-area')) 
 {
    console.log('checkPatchesPosition Now', checkPatchesPosition);
   const containerRect = patchesContainer.getBoundingClientRect();
   const patchActions = patchesContainer.querySelectorAll('.patch-');
   let patchesOutside = false;

   patchActions.forEach(patch => {
       const patchRect = patch.getBoundingClientRect();
       
       let moved = false;

       const patchStyle = window.getComputedStyle(patch);
       const patchLeft = parseFloat(patchStyle.left);
       const patchTop = parseFloat(patchStyle.top);

       if (patchRect.left < containerRect.left) {
           patch.style.left = `${patchLeft + (containerRect.left - patchRect.left)}px`;
           moved = true;
       } else if (patchRect.right > containerRect.right) {
           patch.style.left = `${patchLeft - (patchRect.right - containerRect.right)}px`;
           moved = true;
       }

       if (patchRect.top < containerRect.top) {
           patch.style.top = `${patchTop + (containerRect.top - patchRect.top)}px`;
           moved = true;
       } else if (patchRect.bottom > containerRect.bottom) {
           patch.style.top = `${patchTop - (patchRect.bottom - containerRect.bottom)}px`;
           moved = true;
       }

       if (moved) {
           patchesOutside = true;
           // Disable further movement by adding a class
           patch.classList.add('out-of-bounds');
       } else {
           // Re-enable movement if the patch is inside
           patch.classList.remove('out-of-bounds');
       }
   });

   if (patchesOutside) {
       console.log('Yes, at least one patch is partially outside Now');
       patchesContainer.style.border = '2px solid red'; // Change border color to red
   } else {
       console.log('All patches are inside');
       patchesContainer.style.border = ''; // Reset border color
   }
 }
 else {
  const patchesContainerShirt = document.querySelectorAll('.imageDiv');

  patchesContainerShirt.forEach(container => {
      console.log('checkPatchesPosition Now', checkPatchesPosition);
      const containerRect = container.getBoundingClientRect();
      const patchActions = container.querySelectorAll('.patch-');
      let patchesOutside = false;

      patchActions.forEach(patch => {
          const patchRect = patch.getBoundingClientRect();
          let moved = false;

          const patchStyle = window.getComputedStyle(patch);
          const patchLeft = parseFloat(patchStyle.left);
          const patchTop = parseFloat(patchStyle.top);

          if (patchRect.left < containerRect.left) {
              patch.style.left = `${patchLeft + (containerRect.left - patchRect.left)}px`;
              moved = true;
          } else if (patchRect.right > containerRect.right) {
              patch.style.left = `${patchLeft - (patchRect.right - containerRect.right)}px`;
              moved = true;
          }

          if (patchRect.top < containerRect.top) {
              patch.style.top = `${patchTop + (containerRect.top - patchRect.top)}px`;
              moved = true;
          } else if (patchRect.bottom > containerRect.bottom) {
              patch.style.top = `${patchTop - (patchRect.bottom - containerRect.bottom)}px`;
              moved = true;
          }

          if (moved) {
              patchesOutside = true;
              // Disable further movement by adding a class
              patch.classList.add('out-of-bounds');
          } else {
              // Re-enable movement if the patch is inside
              patch.classList.remove('out-of-bounds');
          }
      });

      if (patchesOutside) {
          console.log('Yes, at least one patch is partially outside Now');
          container.style.border = '2px solid red'; // Change border color to red
      } else {
          console.log('All patches are inside');
          container.style.border = ''; // Reset border color
      }
  });
}

}

alignVerticalBtn.addEventListener('click', () => {
    updateAlignment(alignVerticalBtn.id);
    alignVertical();
    updateFunctionId(alignVerticalBtn.id);
});

alignHorizontalBtn.addEventListener('click', () => {
    updateAlignment(alignHorizontalBtn.id);
    alignHorizontal();
    updateFunctionId(alignHorizontalBtn.id);
});

alignDiagonalLeftBtn.addEventListener('click', () => {
    updateAlignment(alignDiagonalLeftBtn.id);
    alignDiagonalLeft();
    updateFunctionId(alignDiagonalLeftBtn.id);
});

alignDiagonalRightBtn.addEventListener('click', () => {
    updateAlignment(alignDiagonalRightBtn.id);
    alignDiagonalRight();
    updateFunctionId(alignDiagonalRightBtn.id);
});

// Function to update data-function-id attribute
function updateFunctionId(buttonId) {
    const patchesContainer = document.querySelector('.patches-container');
    const patchesBackContainer = document.querySelector('.patches-containerr');
    patchesContainer.setAttribute('data-function-id', buttonId);
    patchesBackContainer.setAttribute('data-function-id', buttonId);
    getAlignmentFunction();
}
function updateAlignment(buttonId) {
    const patchesContainer = document.querySelector('.patches-container');
    const patchesBackContainer = document.querySelector('.patches-containerr');
    patchesContainer.setAttribute('data-alignment-id', buttonId);
     patchesBackContainer.setAttribute('data-alignment-id', buttonId);
     getAlignmentFunction();
}
</script>

<!-- code for patches positioning -->
<script>
    
   function movePatch(direction) {
    deleteAlignment();
    let patchesContainer;
    let patches;

    if (document.getElementById('Front-Area').style.visibility === 'visible') {
        patchesContainer = document.querySelector('.patches-container');
        patches = patchesContainer.querySelectorAll('.patch-action');
    } else if (document.getElementById('Back-area').style.visibility === 'visible') {
        patchesContainer = document.querySelector('.patches-containerr');
        patches = patchesContainer.querySelectorAll('.patch-action');
    } else {
        console.log('Neither Front-Area nor Back-area is visible.');
        return; // Exit the function if neither Front-Area nor Back-area is visible
    }

    const currentFunctionId = patchesContainer.getAttribute('data-function-id');
let increment;
if (window.matchMedia("(max-width: 700px)").matches) {
    increment = 2;
} else {
    increment = 10;
}


function getBorderColor(element) {
    const style = window.getComputedStyle(element);
    return style.borderColor;
}

patches.forEach(patch => {
    // Get the border color of the container
    const container = document.querySelector('.patches-container');
    const borderColor = getBorderColor(container);

    let top = parseInt(patch.style.top) || 0;
    let left = parseInt(patch.style.left) || 0;
    let right = parseInt(patch.style.right) || 0;

    // Determine whether to apply changes based on border color
    const canUpdate = borderColor !== 'rgb(255, 0, 0)'; // 'rgb(255, 0, 0)' is the RGB value for red

    if (currentFunctionId === 'align-diagonal-right') {
        switch (direction) {
            case 'top':
                if (canUpdate) {
                    top -= increment;
                }
                break;
            case 'left':
                if (canUpdate) {
                    right += increment;
                }
                break;
            case 'right':
                if (canUpdate) {
                    right -= increment;
                }
                break;
            case 'bottom':
                if (canUpdate) {
                    top += increment;
                }
                break;
        }
    } else {
        switch (direction) {
            case 'top':
                if (canUpdate) {
                    top -= increment;
                }
                break;
            case 'left':
                if (canUpdate) {
                    left -= increment;
                }
                break;
            case 'right':
                if (canUpdate) {
                    left += increment;
                }
                break;
            case 'bottom':
                if (canUpdate) {
                    top += increment;
                }
                break;
        }
    }

    // Apply the new styles
    if (currentFunctionId === 'align-diagonal-right') {
        patch.style.top = `${top}px`;
        patch.style.left = 'auto';
        patch.style.right = `${right}px`;
    } else {
        patch.style.top = `${top}px`;
        patch.style.left = `${left}px`;
    }

    // Check for overlapping and positions
    checkPatchOverlapping();
    checkPatchesPosition();
});


}

function checkPatchDRAGGINGOverlapping() {
    console.log('checking overlapping');
    let errorMessage = document.querySelector('.overlapping-error');
    let patchDivs;

    if (document.getElementById('Front-Area').style.visibility === 'visible') {
        console.log('front area overlapping');
        patchDivs = document.querySelectorAll('.centerBox > .patches-container > .patch-');
        let isOverlapping = false; // Track if any overlap is detected

        // Loop through each patch
        patchDivs.forEach(patchDiv => {
            patchDiv.classList.remove('patch-'); // Temporarily remove class to avoid self-overlap
            let patchRect = patchDiv.getBoundingClientRect();
            let patches = document.querySelectorAll('.centerBox > .patches-container > .patch-');

            // Check if this patch overlaps with any other patches
            for (let i = 0; i < patches.length; i++) {
                let otherPatchRect = patches[i].getBoundingClientRect();

                // Calculate the overlapping area
                let overlapLeft = Math.max(patchRect.left, otherPatchRect.left);
                let overlapRight = Math.min(patchRect.right, otherPatchRect.right);
                let overlapTop = Math.max(patchRect.top, otherPatchRect.top);
                let overlapBottom = Math.min(patchRect.bottom, otherPatchRect.bottom);

                // Calculate dimensions of the overlapping area
                let overlapWidth = overlapRight - overlapLeft;
                let overlapHeight = overlapBottom - overlapTop;

                if (overlapWidth > 0 && overlapHeight > 0) {
                    // Calculate the area of the overlap and the area of the patch
                    let overlapArea = overlapWidth * overlapHeight;
                    let patchArea = patchRect.width * patchRect.height;

                    // Check if the overlap area is at least 50% of the patch area
                    if (overlapArea >= 0.5 * patchArea) {
                        console.log('overlappingggg by 50% or more');
                        isOverlapping = true; // Set the overlap flag to true
                        break; // Stop checking once overlap is detected
                    }
                }
            }

            patchDiv.classList.add('patch-'); // Re-add class after checking

            if (isOverlapping) {
                // If any overlap is detected, show the error message and stop further checks
                errorMessage.style.visibility = 'visible';
                return; // Stop further execution as overlap is detected
            }
        });

        // If no overlap was detected after checking all patches, hide the error message
        if (!isOverlapping) {
            console.log('hidden it');
            errorMessage.style.visibility = 'hidden';
            $('.overlapping-correction-error').css('display', 'none');
        }

        return false;
    } else {
        console.log('back area overlapping');
        patchDivs = document.querySelectorAll('.BackcenterBox > .patches-containerr > .patch-');
        let isOverlapping = false; // Track if any overlap is detected

        // Loop through each patch
        patchDivs.forEach(patchDiv => {
            patchDiv.classList.remove('patch-'); // Temporarily remove class to avoid self-overlap
            let patchRect = patchDiv.getBoundingClientRect();
            let patches = document.querySelectorAll('.BackcenterBox > .patches-containerr > .patch-');

            // Check if this patch overlaps with any other patches
            for (let i = 0; i < patches.length; i++) {
                let otherPatchRect = patches[i].getBoundingClientRect();

                // Calculate the overlapping area
                let overlapLeft = Math.max(patchRect.left, otherPatchRect.left);
                let overlapRight = Math.min(patchRect.right, otherPatchRect.right);
                let overlapTop = Math.max(patchRect.top, otherPatchRect.top);
                let overlapBottom = Math.min(patchRect.bottom, otherPatchRect.bottom);

                // Calculate dimensions of the overlapping area
                let overlapWidth = overlapRight - overlapLeft;
                let overlapHeight = overlapBottom - overlapTop;

                if (overlapWidth > 0 && overlapHeight > 0) {
                    // Calculate the area of the overlap and the area of the patch
                    let overlapArea = overlapWidth * overlapHeight;
                    let patchArea = patchRect.width * patchRect.height;

                    // Check if the overlap area is at least 50% of the patch area
                    if (overlapArea >= 0.5 * patchArea) {
                        console.log('overlappingggg by 50% or more');
                        isOverlapping = true; // Set the overlap flag to true
                        break; // Stop checking once overlap is detected
                    }
                }
            }

            patchDiv.classList.add('patch-'); // Re-add class after checking

            if (isOverlapping) {
                // If any overlap is detected, show the error message and stop further checks
                errorMessage.style.visibility = 'visible';
                return; // Stop further execution as overlap is detected
            }
        });

        // If no overlap was detected after checking all patches, hide the error message
        if (!isOverlapping) {
            console.log('hidden it');
            errorMessage.style.visibility = 'hidden';
            $('.overlapping-correction-error').css('display', 'none');
        }

        return false;
    }
}

function checkPatchOverlapping() {
    console.log('checking overlapping');
    let errorMessage = document.querySelector('.overlapping-error'); 
    let patchDivs;

    if (document.getElementById('Front-Area').style.visibility === 'visible') {
      console.log('front area overlapping');
//         backPatches = document.querySelectorAll('.BackcenterBox > .patches-containerr > .patch-action');
//       backPatches.forEach(patch => {
//   patch.style.display = 'none';
// });
        patchDivs = document.querySelectorAll('.centerBox > .patches-container > .patch-action');
    } else {
       console.log('back area overlapping');
      
        patchDivs = document.querySelectorAll('.BackcenterBox > .patches-containerr > .patch-action');
    } 
    console.log(patchDivs)
    patchDivs.forEach(patchDiv => {
        patchDiv.classList.remove('patch-');
        let patchRect = patchDiv.getBoundingClientRect();
        let patches = document.querySelectorAll('.patch-');
        console.log('patchRect.left', patchRect.left);
        
        let isOverlapping = false;
        
        for (let i = 0; i < patches.length; i++) {
            let otherPatchRect = patches[i].getBoundingClientRect();
            if (patchRect.left < otherPatchRect.right &&
                patchRect.right > otherPatchRect.left &&
                patchRect.top < otherPatchRect.bottom &&
                patchRect.bottom > otherPatchRect.top) {
                console.log('overlappingggg');
                isOverlapping = true;
                break;
            }
        }

        if (isOverlapping) {
            errorMessage.style.visibility = 'visible';
        } else {
            console.log('hidden it');
            errorMessage.style.visibility = 'hidden';
            $('.overlapping-correction-error').css('display', 'none');
        }

        patchDiv.classList.add('patch-');
    });

    return false;
}

function checkPatchallOverlapping() {
    console.log('checkPatchallOverlapping()');
    let errorMessage = document.querySelector('.overlapping-error'); 
    let patchDivs;
  
    let patches = document.querySelectorAll('.patch-');
    let isOverlapping = false;

    for (let i = 0; i < patches.length; i++) {
        let patchRect = patches[i].getBoundingClientRect();

        for (let j = i + 1; j < patches.length; j++) {
            let otherPatchRect = patches[j].getBoundingClientRect();

            if (patchRect.left < otherPatchRect.right &&
                patchRect.right > otherPatchRect.left &&
                patchRect.top < otherPatchRect.bottom &&
                patchRect.bottom > otherPatchRect.top) {
                console.log('overlappingggg');
                isOverlapping = true;
                break;
            }
        }

        if (isOverlapping) {
            break;
        }
    }

    if (isOverlapping) {
        errorMessage.style.visibility = 'visible';
    } else {
        console.log('hidden it');
        errorMessage.style.visibility = 'hidden';
        $('.overlapping-correction-error').css('display', 'none');
    }

    return false;
}

  function deleteAlignment() {
    console.log('delete')
    const patchesContainer = document.querySelector('.patches-container');
    const patchesBackContainer = document.querySelector('.patches-containerr');
    patchesContainer.removeAttribute('data-alignment-id');
    patchesBackContainer.removeAttribute('data-alignment-id');
    
}
// before
// function centerPatches() {
//      deleteAlignment();
//     const container = document.querySelector('.patches-container');
//     const patches = container.querySelectorAll('.patch-action');

//     // Get the bounding box of the container
//     const containerRect = container.getBoundingClientRect();
//     const containerCenterX = containerRect.left + containerRect.width / 2;
//     const containerCenterY = containerRect.top + containerRect.height / 2;

//     // Find the bounding box that surrounds all patches
//     let minX = Infinity;
//     let maxX = -Infinity;
//     let minY = Infinity;
//     let maxY = -Infinity;
//     patches.forEach(patch => {
//         const rect = patch.getBoundingClientRect();
//         minX = Math.min(minX, rect.left);
//         maxX = Math.max(maxX, rect.right);
//         minY = Math.min(minY, rect.top);
//         maxY = Math.max(maxY, rect.bottom);
//     });

//     // Calculate the offset to center the patches within the container
//     const offsetX = containerCenterX - ((minX + maxX) / 2);
//     const offsetY = containerCenterY - ((minY + maxY) / 2);

//     patches.forEach(patch => {
//         const prevLeft = parseFloat(window.getComputedStyle(patch).getPropertyValue('left'));
//         const prevTop = parseFloat(window.getComputedStyle(patch).getPropertyValue('top'));

//         // Calculate the new left and top positions for each patch
//         const newLeft = prevLeft + offsetX;
//         const newTop = prevTop + offsetY;

//         // Apply the new positions
//         patch.style.left = `${newLeft}px`;
//         patch.style.top = `${newTop}px`;
//     });
// }
  function centerPatches() {
    deleteAlignment();
     
    let container;
    let patches;

    if (document.getElementById('Front-Area').style.visibility === 'visible') {
        container = document.querySelector('.patches-container');
        patches = container.querySelectorAll('.patch-action');
    } else if (document.getElementById('Back-area').style.visibility === 'visible') {
        container = document.querySelector('.patches-containerr');
        patches = container.querySelectorAll('.patch-action');
    }

    // Check if container and patches are defined
    if (container && patches) {
        // Get the bounding box of the container
        const containerRect = container.getBoundingClientRect();
        const containerCenterX = containerRect.left + containerRect.width / 2;
        const containerCenterY = containerRect.top + containerRect.height / 2;

        // Find the bounding box that surrounds all patches
        let minX = Infinity;
        let maxX = -Infinity;
        let minY = Infinity;
        let maxY = -Infinity;
        patches.forEach(patch => {
            const rect = patch.getBoundingClientRect();
            minX = Math.min(minX, rect.left);
            maxX = Math.max(maxX, rect.right);
            minY = Math.min(minY, rect.top);
            maxY = Math.max(maxY, rect.bottom);
        });

        // Calculate the offset to center the patches within the container
        const offsetX = containerCenterX - ((minX + maxX) / 2);
        const offsetY = containerCenterY - ((minY + maxY) / 2);

        patches.forEach(patch => {
            const prevLeft = parseFloat(window.getComputedStyle(patch).getPropertyValue('left'));
            const prevTop = parseFloat(window.getComputedStyle(patch).getPropertyValue('top'));

            // Calculate the new left and top positions for each patch
            const newLeft = prevLeft + offsetX;
            const newTop = prevTop + offsetY;

            // Apply the new positions
            patch.style.left = `${newLeft}px`;
            patch.style.top = `${newTop}px`;
        });
    } else {
        console.log("Container or patches not found.");
    }
       checkPatchOverlapping();
}
</script>
<script>
    $(document).on('click', '.front-selected-patches-select', function() {
      // Add the 'patch-selected' class to all elements with the class 'selected-patch-for-customization-for-front'
      $('.selected-patch-for-customization-for-front').addClass('patch-selected-by-btn');
      $('.centerBox > .patches-container > .patch-').addClass('patch-action');
      changefillColors();
  });

  $(document).on('click', '.front-selected-patches-unselect', function() {
      // Remove the 'patch-selected' class from all elements with the class 'selected-patch-for-customization-for-front'
      $('.selected-patch-for-customization-for-front').removeClass('patch-selected-by-btn');
    $('.centerBox > .patches-container > .patch-').removeClass('patch-action');
    $('.selected-patch-for-customization-for-front').removeClass('patch-selected');
    $('.selected-patch-for-customization-for-front').removeClass('patch-selected-by-both');
    $('.selected-patch-for-customization-for-front > .selected-patch-order').remove();
    console.log('this is order',order)
    order=1;
    console.log('this is new order',order)
    changefillColors();
  });
    $(document).on('click', '.back-selected-patches-select', function() {
      // Add the 'patch-selected' class to all elements with the class 'selected-patch-for-customization-for-front'
      $('.selected-patch-for-customization-for-back').addClass('patch-selected-by-btn');
      $('.BackcenterBox > .patches-containerr > .patch-').addClass('patch-action');

      changefillColors();
  });

  $(document).on('click', '.back-selected-patches-unselect', function() {
      // Remove the 'patch-selected' class from all elements with the class 'selected-patch-for-customization-for-front'
      $('.selected-patch-for-customization-for-back').removeClass('patch-selected-by-btn');
    $('.BackcenterBox > .patches-containerr > .patch-').removeClass('patch-action');
      $('.BackcenterBox > .patches-containerr > .patch-').removeClass('patch-selected');
        $('.selected-patch-for-customization-for-back').removeClass('patch-selected');
    $('.selected-patch-for-customization-for-back').removeClass('patch-selected-by-both');
    $('.selected-patch-for-customization-for-back > .selected-patch-order').remove();

    changefillColors();
      orderBack=1;
  });
</script>
    <script>// Function to resize patches and adjust positions dynamically
// Function to initialize the dataset for a patch
function initializePatch(patch, referenceWidth, referenceHeight, containerWidth, containerHeight) {
    if (!patch.dataset.originalWidth) {
        // Use reference dimensions for initialization
        patch.dataset.originalWidth = (patch.offsetWidth / containerWidth) * referenceWidth;
        patch.dataset.originalHeight = (patch.offsetHeight / containerHeight) * referenceHeight;
        patch.dataset.originalTop = (patch.offsetTop / containerHeight) * referenceHeight;
        patch.dataset.originalLeft = (patch.offsetLeft / containerWidth) * referenceWidth;
    }
}

// Main function to resize and reposition patches
function adjustPatches(deleteDatasetOnly = false) {
    const patchesContainer = document.querySelector(".patches-container");
    const patches = document.querySelectorAll(".patch-");
    const container = document.querySelector(".checkit");

    if (patchesContainer && patches.length > 0 && container) {
        const containerWidth = container.offsetWidth;
        const containerHeight = container.offsetHeight;

        const referenceWidth = 750; // Base width used during design
        const referenceHeight = 704; // Base height used during design

        console.log("Container Dimensions:", containerWidth, containerHeight);

        patches.forEach(patch => {
            if (deleteDatasetOnly) {
                console.log("Deleting dataset values...");
                delete patch.dataset.originalWidth;
                delete patch.dataset.originalHeight;
                delete patch.dataset.originalTop;
                delete patch.dataset.originalLeft;
                return; // Exit after deleting
            }

            // Ensure the patch has been initialized
            initializePatch(patch, referenceWidth, referenceHeight, containerWidth, containerHeight);

            // Retrieve original dimensions and positions
            const originalWidth = parseFloat(patch.dataset.originalWidth);
            const originalHeight = parseFloat(patch.dataset.originalHeight);
            const originalTop = parseFloat(patch.dataset.originalTop);
            const originalLeft = parseFloat(patch.dataset.originalLeft);

            // Scale dimensions and positions based on container size
            const widthScale = containerWidth / referenceWidth;
            const heightScale = containerHeight / referenceHeight;

            const newWidth = originalWidth * widthScale;
            const newHeight = originalHeight * heightScale;
            const newTop = originalTop * heightScale;
            const newLeft = originalLeft * widthScale;

            console.log(`Resizing Patch:
                Original: ${originalWidth}x${originalHeight}, Top: ${originalTop}, Left: ${originalLeft}
                Scaled: ${newWidth}x${newHeight}, Top: ${newTop}, Left: ${newLeft}`);

            // Apply new dimensions and positions
            patch.style.width = `${newWidth}px`;
            patch.style.height = `${newHeight}px`;
            patch.style.top = `${newTop}px`;
            patch.style.left = `${newLeft}px`;
        });
    }
}

// Attach event listener for resizing
let lastOrientation = window.orientation;

window.addEventListener("resize", () => {
    const currentOrientation = window.orientation;

    // Check if the orientation has changed
    if (lastOrientation !== currentOrientation) {
        console.log("Orientation change detected. Skipping adjustPatches.");
        lastOrientation = currentOrientation; // Update the last orientation
        return; // Skip the function call
    }

    // Call the function if there's no orientation change
    adjustPatches(false);
    console.log("Screen resized. adjustPatches called.");
});




  </script>
 
